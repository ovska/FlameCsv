// <auto-generated />
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Buffers.Text;

namespace FlameCsv.Converters;

internal static partial class DefaultConverters
{
	private static void RegisterNumberConverters(Dictionary<Type, TextConverterFactory> dict)
	{
		dict.Add(typeof(byte), static options => new ByteTextConverter(options));
		dict.Add(typeof(sbyte), static options => new SByteTextConverter(options));
		dict.Add(typeof(short), static options => new Int16TextConverter(options));
		dict.Add(typeof(ushort), static options => new UInt16TextConverter(options));
		dict.Add(typeof(int), static options => new Int32TextConverter(options));
		dict.Add(typeof(uint), static options => new UInt32TextConverter(options));
		dict.Add(typeof(long), static options => new Int64TextConverter(options));
		dict.Add(typeof(ulong), static options => new UInt64TextConverter(options));
		dict.Add(typeof(nint), static options => new IntPtrTextConverter(options));
		dict.Add(typeof(nuint), static options => new UIntPtrTextConverter(options));
		dict.Add(typeof(float), static options => new FloatTextConverter(options));
		dict.Add(typeof(double), static options => new DoubleTextConverter(options));
		dict.Add(typeof(decimal), static options => new DecimalTextConverter(options));
		dict.Add(typeof(Half), static options => new HalfTextConverter(options));
	}

	private static void RegisterNumberConverters(Dictionary<Type, Utf8ConverterFactory> dict)
	{
		dict.Add(typeof(byte), static options => new ByteUtf8Converter(options));
		dict.Add(typeof(sbyte), static options => new SByteUtf8Converter(options));
		dict.Add(typeof(short), static options => new Int16Utf8Converter(options));
		dict.Add(typeof(ushort), static options => new UInt16Utf8Converter(options));
		dict.Add(typeof(int), static options => new Int32Utf8Converter(options));
		dict.Add(typeof(uint), static options => new UInt32Utf8Converter(options));
		dict.Add(typeof(long), static options => new Int64Utf8Converter(options));
		dict.Add(typeof(ulong), static options => new UInt64Utf8Converter(options));
		dict.Add(typeof(nint), static options => new IntPtrUtf8Converter(options));
		dict.Add(typeof(nuint), static options => new UIntPtrUtf8Converter(options));
		dict.Add(typeof(float), static options => new FloatUtf8Converter(options));
		dict.Add(typeof(double), static options => new DoubleUtf8Converter(options));
		dict.Add(typeof(decimal), static options => new DecimalUtf8Converter(options));
		dict.Add(typeof(Half), static options => new HalfUtf8Converter(options));
	}
}

internal sealed class ByteTextConverter : CsvConverter<char, byte>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public ByteTextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, byte value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out byte value)
    {
        return byte.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class SByteTextConverter : CsvConverter<char, sbyte>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public SByteTextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, sbyte value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out sbyte value)
    {
        return sbyte.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class Int16TextConverter : CsvConverter<char, short>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public Int16TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, short value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out short value)
    {
        return short.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt16TextConverter : CsvConverter<char, ushort>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public UInt16TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, ushort value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out ushort value)
    {
        return ushort.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class Int32TextConverter : CsvConverter<char, int>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public Int32TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, int value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out int value)
    {
        return int.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt32TextConverter : CsvConverter<char, uint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public UInt32TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, uint value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out uint value)
    {
        return uint.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class Int64TextConverter : CsvConverter<char, long>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public Int64TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, long value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out long value)
    {
        return long.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt64TextConverter : CsvConverter<char, ulong>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public UInt64TextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, ulong value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out ulong value)
    {
        return ulong.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class IntPtrTextConverter : CsvConverter<char, nint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public IntPtrTextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, nint value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out nint value)
    {
        return nint.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class UIntPtrTextConverter : CsvConverter<char, nuint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public UIntPtrTextConverter(CsvTextOptions options)
	{
		_styles = options.IntegerNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.IntegerFormat;
	}

	public override bool TryFormat(Span<char> buffer, nuint value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out nuint value)
    {
        return nuint.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class FloatTextConverter : CsvConverter<char, float>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public FloatTextConverter(CsvTextOptions options)
	{
		_styles = options.DecimalNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.DecimalFormat;
	}

	public override bool TryFormat(Span<char> buffer, float value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out float value)
    {
        return float.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class DoubleTextConverter : CsvConverter<char, double>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public DoubleTextConverter(CsvTextOptions options)
	{
		_styles = options.DecimalNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.DecimalFormat;
	}

	public override bool TryFormat(Span<char> buffer, double value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out double value)
    {
        return double.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class DecimalTextConverter : CsvConverter<char, decimal>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public DecimalTextConverter(CsvTextOptions options)
	{
		_styles = options.DecimalNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.DecimalFormat;
	}

	public override bool TryFormat(Span<char> buffer, decimal value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out decimal value)
    {
        return decimal.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class HalfTextConverter : CsvConverter<char, Half>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public HalfTextConverter(CsvTextOptions options)
	{
		_styles = options.DecimalNumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.DecimalFormat;
	}

	public override bool TryFormat(Span<char> buffer, Half value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out Half value)
    {
        return Half.TryParse(field, _styles, _formatProvider, out value);
    }
}

internal sealed class ByteUtf8Converter : CsvConverter<byte, byte>
{
    private readonly char _standardFormat;

	public ByteUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, byte value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out byte value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class SByteUtf8Converter : CsvConverter<byte, sbyte>
{
    private readonly char _standardFormat;

	public SByteUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, sbyte value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out sbyte value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class Int16Utf8Converter : CsvConverter<byte, short>
{
    private readonly char _standardFormat;

	public Int16Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, short value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out short value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class UInt16Utf8Converter : CsvConverter<byte, ushort>
{
    private readonly char _standardFormat;

	public UInt16Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, ushort value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out ushort value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class Int32Utf8Converter : CsvConverter<byte, int>
{
    private readonly char _standardFormat;

	public Int32Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, int value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out int value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class UInt32Utf8Converter : CsvConverter<byte, uint>
{
    private readonly char _standardFormat;

	public UInt32Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, uint value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out uint value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class Int64Utf8Converter : CsvConverter<byte, long>
{
    private readonly char _standardFormat;

	public Int64Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, long value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out long value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class UInt64Utf8Converter : CsvConverter<byte, ulong>
{
    private readonly char _standardFormat;

	public UInt64Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, ulong value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out ulong value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class IntPtrUtf8Converter : CsvConverter<byte, nint>
{
    private readonly char _standardFormat;

	public IntPtrUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, nint value, out int charsWritten)
    {
		return Utf8Formatter.TryFormat((long)value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out nint value)
    {
		if (Utf8Parser.TryParse(field, out long longValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length &&
			longValue <= nint.MaxValue &&
			longValue >= nint.MinValue)
		{
			value = checked((nint)longValue);
			return true;
		}
		value = default;
		return false;
    }
}

internal sealed class UIntPtrUtf8Converter : CsvConverter<byte, nuint>
{
    private readonly char _standardFormat;

	public UIntPtrUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.IntegerFormat;
	}

	public override bool TryFormat(Span<byte> buffer, nuint value, out int charsWritten)
    {
		return Utf8Formatter.TryFormat((ulong)value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out nuint value)
    {
		if (Utf8Parser.TryParse(field, out ulong ulongValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length &&
			ulongValue <= nuint.MaxValue)
		{
			value = checked((nuint)ulongValue);
			return true;
		}
		value = default;
		return false;
    }
}

internal sealed class FloatUtf8Converter : CsvConverter<byte, float>
{
    private readonly char _standardFormat;

	public FloatUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.DecimalFormat;
	}

	public override bool TryFormat(Span<byte> buffer, float value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out float value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class DoubleUtf8Converter : CsvConverter<byte, double>
{
    private readonly char _standardFormat;

	public DoubleUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.DecimalFormat;
	}

	public override bool TryFormat(Span<byte> buffer, double value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out double value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class DecimalUtf8Converter : CsvConverter<byte, decimal>
{
    private readonly char _standardFormat;

	public DecimalUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.DecimalFormat;
	}

	public override bool TryFormat(Span<byte> buffer, decimal value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out decimal value)
    {
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
    }
}

internal sealed class HalfUtf8Converter : CsvConverter<byte, Half>
{
    private readonly char _standardFormat;

	public HalfUtf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.DecimalFormat;
	}

	public override bool TryFormat(Span<byte> buffer, Half value, out int charsWritten)
    {
		return Utf8Formatter.TryFormat((float)value, buffer, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out Half value)
    {
		if (Utf8Parser.TryParse(field, out float floatValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length)
		{
			value = (Half)floatValue;
			return true;
		}

		value = default;
		return false;
    }
}

