// <auto-generated />
#nullable enable
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Buffers;
using System.Buffers.Text;

namespace FlameCsv.Converters;

static partial class DefaultConverters
{
    /// <summary>Returns an user-defined converter for <see cref="System.Byte"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, byte> CreateByte(CsvTextOptions options) => options.GetOrCreate(static o => new ByteTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.SByte"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, sbyte> CreateSByte(CsvTextOptions options) => options.GetOrCreate(static o => new SByteTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int16"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, short> CreateInt16(CsvTextOptions options) => options.GetOrCreate(static o => new Int16TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt16"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, ushort> CreateUInt16(CsvTextOptions options) => options.GetOrCreate(static o => new UInt16TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int32"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, int> CreateInt32(CsvTextOptions options) => options.GetOrCreate(static o => new Int32TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt32"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, uint> CreateUInt32(CsvTextOptions options) => options.GetOrCreate(static o => new UInt32TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int64"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, long> CreateInt64(CsvTextOptions options) => options.GetOrCreate(static o => new Int64TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt64"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, ulong> CreateUInt64(CsvTextOptions options) => options.GetOrCreate(static o => new UInt64TextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.IntPtr"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, nint> CreateIntPtr(CsvTextOptions options) => options.GetOrCreate(static o => new IntPtrTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UIntPtr"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, nuint> CreateUIntPtr(CsvTextOptions options) => options.GetOrCreate(static o => new UIntPtrTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Float"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, float> CreateFloat(CsvTextOptions options) => options.GetOrCreate(static o => new FloatTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Double"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, double> CreateDouble(CsvTextOptions options) => options.GetOrCreate(static o => new DoubleTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Decimal"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, decimal> CreateDecimal(CsvTextOptions options) => options.GetOrCreate(static o => new DecimalTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Half"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<char, Half> CreateHalf(CsvTextOptions options) => options.GetOrCreate(static o => new HalfTextConverter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Byte"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, byte> CreateByte(CsvUtf8Options options) => options.GetOrCreate(static o => new ByteUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.SByte"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, sbyte> CreateSByte(CsvUtf8Options options) => options.GetOrCreate(static o => new SByteUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int16"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, short> CreateInt16(CsvUtf8Options options) => options.GetOrCreate(static o => new Int16Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt16"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, ushort> CreateUInt16(CsvUtf8Options options) => options.GetOrCreate(static o => new UInt16Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int32"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, int> CreateInt32(CsvUtf8Options options) => options.GetOrCreate(static o => new Int32Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt32"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, uint> CreateUInt32(CsvUtf8Options options) => options.GetOrCreate(static o => new UInt32Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Int64"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, long> CreateInt64(CsvUtf8Options options) => options.GetOrCreate(static o => new Int64Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UInt64"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, ulong> CreateUInt64(CsvUtf8Options options) => options.GetOrCreate(static o => new UInt64Utf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.IntPtr"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, nint> CreateIntPtr(CsvUtf8Options options) => options.GetOrCreate(static o => new IntPtrUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.UIntPtr"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, nuint> CreateUIntPtr(CsvUtf8Options options) => options.GetOrCreate(static o => new UIntPtrUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Float"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, float> CreateFloat(CsvUtf8Options options) => options.GetOrCreate(static o => new FloatUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Double"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, double> CreateDouble(CsvUtf8Options options) => options.GetOrCreate(static o => new DoubleUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Decimal"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, decimal> CreateDecimal(CsvUtf8Options options) => options.GetOrCreate(static o => new DecimalUtf8Converter(o));

    /// <summary>Returns an user-defined converter for <see cref="System.Half"/>, or returns the built-in converter. </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<byte, Half> CreateHalf(CsvUtf8Options options) => options.GetOrCreate(static o => new HalfUtf8Converter(o));


    private static void RegisterNumberConverters(List<KeyValuePair<Type, TextConverterFactory>> list)
    {
        list.EnsureCapacity(list.Count + 14);
        list.Add(new(typeof(byte), static options => new ByteTextConverter(options)));
        list.Add(new(typeof(sbyte), static options => new SByteTextConverter(options)));
        list.Add(new(typeof(short), static options => new Int16TextConverter(options)));
        list.Add(new(typeof(ushort), static options => new UInt16TextConverter(options)));
        list.Add(new(typeof(int), static options => new Int32TextConverter(options)));
        list.Add(new(typeof(uint), static options => new UInt32TextConverter(options)));
        list.Add(new(typeof(long), static options => new Int64TextConverter(options)));
        list.Add(new(typeof(ulong), static options => new UInt64TextConverter(options)));
        list.Add(new(typeof(nint), static options => new IntPtrTextConverter(options)));
        list.Add(new(typeof(nuint), static options => new UIntPtrTextConverter(options)));
        list.Add(new(typeof(float), static options => new FloatTextConverter(options)));
        list.Add(new(typeof(double), static options => new DoubleTextConverter(options)));
        list.Add(new(typeof(decimal), static options => new DecimalTextConverter(options)));
        list.Add(new(typeof(Half), static options => new HalfTextConverter(options)));
    }

    private static void RegisterNumberConverters(List<KeyValuePair<Type, Utf8ConverterFactory>> list)
    {
        list.EnsureCapacity(list.Count + 14);
        list.Add(new(typeof(byte), static options => new ByteUtf8Converter(options)));
        list.Add(new(typeof(sbyte), static options => new SByteUtf8Converter(options)));
        list.Add(new(typeof(short), static options => new Int16Utf8Converter(options)));
        list.Add(new(typeof(ushort), static options => new UInt16Utf8Converter(options)));
        list.Add(new(typeof(int), static options => new Int32Utf8Converter(options)));
        list.Add(new(typeof(uint), static options => new UInt32Utf8Converter(options)));
        list.Add(new(typeof(long), static options => new Int64Utf8Converter(options)));
        list.Add(new(typeof(ulong), static options => new UInt64Utf8Converter(options)));
        list.Add(new(typeof(nint), static options => new IntPtrUtf8Converter(options)));
        list.Add(new(typeof(nuint), static options => new UIntPtrUtf8Converter(options)));
        list.Add(new(typeof(float), static options => new FloatUtf8Converter(options)));
        list.Add(new(typeof(double), static options => new DoubleUtf8Converter(options)));
        list.Add(new(typeof(decimal), static options => new DecimalUtf8Converter(options)));
        list.Add(new(typeof(Half), static options => new HalfUtf8Converter(options)));
    }
}

internal sealed class ByteTextConverter : CsvConverter<char, byte>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public ByteTextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, byte value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out byte value)
    {
        return byte.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class SByteTextConverter : CsvConverter<char, sbyte>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public SByteTextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, sbyte value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out sbyte value)
    {
        return sbyte.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class Int16TextConverter : CsvConverter<char, short>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public Int16TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, short value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out short value)
    {
        return short.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt16TextConverter : CsvConverter<char, ushort>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public UInt16TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, ushort value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out ushort value)
    {
        return ushort.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class Int32TextConverter : CsvConverter<char, int>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public Int32TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, int value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out int value)
    {
        return int.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt32TextConverter : CsvConverter<char, uint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public UInt32TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, uint value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out uint value)
    {
        return uint.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class Int64TextConverter : CsvConverter<char, long>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public Int64TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, long value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out long value)
    {
        return long.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class UInt64TextConverter : CsvConverter<char, ulong>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public UInt64TextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, ulong value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out ulong value)
    {
        return ulong.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class IntPtrTextConverter : CsvConverter<char, nint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public IntPtrTextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, nint value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out nint value)
    {
        return nint.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class UIntPtrTextConverter : CsvConverter<char, nuint>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public UIntPtrTextConverter(CsvTextOptions options)
    {
        _styles = options.IntegerNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.IntegerFormat;
    }

    public override bool TryFormat(Span<char> destination, nuint value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out nuint value)
    {
        return nuint.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class FloatTextConverter : CsvConverter<char, float>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public FloatTextConverter(CsvTextOptions options)
    {
        _styles = options.DecimalNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.DecimalFormat;
    }

    public override bool TryFormat(Span<char> destination, float value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out float value)
    {
        return float.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class DoubleTextConverter : CsvConverter<char, double>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public DoubleTextConverter(CsvTextOptions options)
    {
        _styles = options.DecimalNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.DecimalFormat;
    }

    public override bool TryFormat(Span<char> destination, double value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out double value)
    {
        return double.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class DecimalTextConverter : CsvConverter<char, decimal>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public DecimalTextConverter(CsvTextOptions options)
    {
        _styles = options.DecimalNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.DecimalFormat;
    }

    public override bool TryFormat(Span<char> destination, decimal value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out decimal value)
    {
        return decimal.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class HalfTextConverter : CsvConverter<char, Half>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public HalfTextConverter(CsvTextOptions options)
    {
        _styles = options.DecimalNumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.DecimalFormat;
    }

    public override bool TryFormat(Span<char> destination, Half value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out Half value)
    {
        return Half.TryParse(source, _styles, _formatProvider, out value);
    }
}

internal sealed class ByteUtf8Converter : CsvConverter<byte, byte>
{
    private readonly StandardFormat _standardFormat;

    public ByteUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, byte value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out byte value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class SByteUtf8Converter : CsvConverter<byte, sbyte>
{
    private readonly StandardFormat _standardFormat;

    public SByteUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, sbyte value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out sbyte value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class Int16Utf8Converter : CsvConverter<byte, short>
{
    private readonly StandardFormat _standardFormat;

    public Int16Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, short value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out short value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class UInt16Utf8Converter : CsvConverter<byte, ushort>
{
    private readonly StandardFormat _standardFormat;

    public UInt16Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, ushort value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out ushort value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class Int32Utf8Converter : CsvConverter<byte, int>
{
    private readonly StandardFormat _standardFormat;

    public Int32Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, int value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out int value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class UInt32Utf8Converter : CsvConverter<byte, uint>
{
    private readonly StandardFormat _standardFormat;

    public UInt32Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, uint value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out uint value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class Int64Utf8Converter : CsvConverter<byte, long>
{
    private readonly StandardFormat _standardFormat;

    public Int64Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, long value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out long value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class UInt64Utf8Converter : CsvConverter<byte, ulong>
{
    private readonly StandardFormat _standardFormat;

    public UInt64Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, ulong value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out ulong value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class IntPtrUtf8Converter : CsvConverter<byte, nint>
{
    private readonly StandardFormat _standardFormat;

    public IntPtrUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, nint value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat((long)value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out nint value)
    {
        if (Utf8Parser.TryParse(source, out long longValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = checked((nint)longValue);
            return true;
        }
        value = default;
        return false;
    }
}

internal sealed class UIntPtrUtf8Converter : CsvConverter<byte, nuint>
{
    private readonly StandardFormat _standardFormat;

    public UIntPtrUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.IntegerFormat;
    }

    public override bool TryFormat(Span<byte> destination, nuint value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat((ulong)value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out nuint value)
    {
        if (Utf8Parser.TryParse(source, out ulong ulongValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = checked((nuint)ulongValue);
            return true;
        }
        value = default;
        return false;
    }
}

internal sealed class FloatUtf8Converter : CsvConverter<byte, float>
{
    private readonly StandardFormat _standardFormat;

    public FloatUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.DecimalFormat;
    }

    public override bool TryFormat(Span<byte> destination, float value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out float value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class DoubleUtf8Converter : CsvConverter<byte, double>
{
    private readonly StandardFormat _standardFormat;

    public DoubleUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.DecimalFormat;
    }

    public override bool TryFormat(Span<byte> destination, double value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out double value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class DecimalUtf8Converter : CsvConverter<byte, decimal>
{
    private readonly StandardFormat _standardFormat;

    public DecimalUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.DecimalFormat;
    }

    public override bool TryFormat(Span<byte> destination, decimal value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out decimal value)
    {
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
    }
}

internal sealed class HalfUtf8Converter : CsvConverter<byte, Half>
{
    private readonly StandardFormat _standardFormat;

    public HalfUtf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.DecimalFormat;
    }

    public override bool TryFormat(Span<byte> destination, Half value, out int charsWritten)
    {
        return Utf8Formatter.TryFormat((float)value, destination, out charsWritten, _standardFormat);
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out Half value)
    {
        if (Utf8Parser.TryParse(source, out float floatValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = (Half)floatValue;
            return true;
        }

        value = default;
        return false;
    }
}

