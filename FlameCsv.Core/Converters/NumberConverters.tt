<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	(string typeName, string keyWord)[] types =
	{
		("Byte", "byte"),
		("SByte", "sbyte"),
		("Int16", "short"),
		("UInt16", "ushort"),
		("Int32", "int"),
		("UInt32", "uint"),
		("Int64", "long"),
		("UInt64", "ulong"),
		("IntPtr", "nint"),
		("UIntPtr", "nuint"),
		("Float", "float"),
		("Double", "double"),
		("Decimal", "decimal"),
		("Half", "Half"),
	};
#>
// <auto-generated />
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Buffers.Text;

namespace FlameCsv.Converters;

internal static partial class DefaultConverters
{
	private static void RegisterNumberConverters(Dictionary<Type, TextConverterFactory> dict)
	{
<# foreach (var (typeName, keyWord) in types) { #>
		dict.Add(typeof(<#= keyWord #>), static options => new <#= typeName #>TextConverter(options));
<# } #>
	}

	private static void RegisterNumberConverters(Dictionary<Type, Utf8ConverterFactory> dict)
	{
<# foreach (var (typeName, keyWord) in types) { #>
		dict.Add(typeof(<#= keyWord #>), static options => new <#= typeName #>Utf8Converter(options));
<# } #>
	}
}

<#
	foreach (var (typeName, keyWord) in types) {
	bool isInteger = keyWord != "float" && keyWord != "double" && keyWord != "decimal" && keyWord != "Half";
	string textStyles = isInteger ? "Integer" : "Decimal";
#>
internal sealed class <#= typeName #>TextConverter : CsvConverter<char, <#= keyWord #>>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
	private readonly string? _format;

	public <#= typeName #>TextConverter(CsvTextOptions options)
	{
		_styles = options.<#= isInteger ? "Integer" : "Decimal" #>NumberStyles;
		_formatProvider = options.FormatProvider;
		_format = options.<#= isInteger ? "Integer" : "Decimal" #>Format;
	}

	public override bool TryFormat(Span<char> buffer, <#= keyWord #> value, out int charsWritten)
    {
        return value.TryFormat(buffer, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> field, [MaybeNullWhen(false)] out <#= keyWord #> value)
    {
        return <#= keyWord #>.TryParse(field, _styles, _formatProvider, out value);
    }
}

<# }
	foreach (var (typeName, keyWord) in types) {
	bool isInteger = keyWord != "float" && keyWord != "double" && keyWord != "decimal" && keyWord != "Half";
#>
internal sealed class <#= typeName #>Utf8Converter : CsvConverter<byte, <#= keyWord #>>
{
    private readonly char _standardFormat;

	public <#= typeName #>Utf8Converter(CsvUtf8Options options)
	{
		_standardFormat = options.<#= isInteger ? "Integer" : "Decimal" #>Format;
	}

	public override bool TryFormat(Span<byte> buffer, <#= keyWord #> value, out int charsWritten)
    {
<# if (typeName == "Half") { #>
		return Utf8Formatter.TryFormat((float)value, buffer, out charsWritten, _standardFormat);
<# } else if (typeName == "IntPtr") { #>
		return Utf8Formatter.TryFormat((long)value, buffer, out charsWritten, _standardFormat);
<# } else if (typeName == "UIntPtr") { #>
		return Utf8Formatter.TryFormat((ulong)value, buffer, out charsWritten, _standardFormat);
<# } else { #>
        return Utf8Formatter.TryFormat(value, buffer, out charsWritten, _standardFormat);
<# } #>
    }

    public override bool TryParse(ReadOnlySpan<byte> field, [MaybeNullWhen(false)] out <#= keyWord #> value)
    {
<# if (typeName == "Half") { #>
		if (Utf8Parser.TryParse(field, out float floatValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length)
		{
			value = (Half)floatValue;
			return true;
		}

		value = default;
		return false;
<# } else if (typeName == "IntPtr") { #>
		if (Utf8Parser.TryParse(field, out long longValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length &&
			longValue <= nint.MaxValue &&
			longValue >= nint.MinValue)
		{
			value = checked((nint)longValue);
			return true;
		}
		value = default;
		return false;
<# } else if (typeName == "UIntPtr") { #>
		if (Utf8Parser.TryParse(field, out ulong ulongValue, out int bytesConsumed, _standardFormat) &&
			bytesConsumed == field.Length &&
			ulongValue <= nuint.MaxValue)
		{
			value = checked((nuint)ulongValue);
			return true;
		}
		value = default;
		return false;
<# } else { #>
        return Utf8Parser.TryParse(field, out value, out int bytesConsumed, _standardFormat) && bytesConsumed == field.Length;
<# } #>
    }
}

<# } #>