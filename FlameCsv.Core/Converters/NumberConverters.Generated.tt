<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    (string typeName, string keyWord, bool isInteger)[] types =
    {
        ("Byte", "byte", true),
        ("SByte", "sbyte", true),
        ("Int16", "short", true),
        ("UInt16", "ushort", true),
        ("Int32", "int", true),
        ("UInt32", "uint", true),
        ("Int64", "long", true),
        ("UInt64", "ulong", true),
        ("IntPtr", "nint", true),
        ("UIntPtr", "nuint", true),
        ("Float", "float", false),
        ("Double", "double", false),
        ("Decimal", "decimal", false),
        ("Half", "Half", false),
    };
#>
// <auto-generated />
#nullable enable
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Buffers;
using System.Buffers.Text;

namespace FlameCsv.Converters;

static partial class DefaultConverters
{
<# 
foreach (var (tokenType, optionsType) in new (string, string)[] { ("char", "Text"), ("byte", "Utf8") }) {
foreach (var (typeName, keyWord, _) in types) {
#>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static CsvConverter<<#= tokenType #>, <#= keyWord #>> Create<#= typeName #>(Csv<#= optionsType #>Options options) => new <#= typeName #><#= optionsType #>Converter(options);

<# }} #>

    private static void RegisterNumberConverters(List<KeyValuePair<Type, TextConverterFactory>> list)
    {
        list.EnsureCapacity(list.Count + <#= types.Length #>);
<# foreach (var (typeName, keyWord, _) in types) { #>
        list.Add(new(typeof(<#= keyWord #>), static options => new <#= typeName #>TextConverter(options)));
<# } #>
    }

    private static void RegisterNumberConverters(List<KeyValuePair<Type, Utf8ConverterFactory>> list)
    {
        list.EnsureCapacity(list.Count + <#= types.Length #>);
<# foreach (var (typeName, keyWord, _) in types) { #>
        list.Add(new(typeof(<#= keyWord #>), static options => new <#= typeName #>Utf8Converter(options)));
<# } #>
    }
}

<#
    foreach (var (typeName, keyWord, isInteger) in types) {
    string textStyles = isInteger ? "Integer" : "Decimal";
#>
internal sealed class <#= typeName #>TextConverter : CsvConverter<char, <#= keyWord #>>
{
    private readonly NumberStyles _styles;
    private readonly IFormatProvider? _formatProvider;
    private readonly string? _format;

    public <#= typeName #>TextConverter(CsvTextOptions options)
    {
        _styles = options.<#= isInteger ? "Integer" : "Decimal" #>NumberStyles;
        _formatProvider = options.FormatProvider;
        _format = options.<#= isInteger ? "Integer" : "Decimal" #>Format;
    }

    public override bool TryFormat(Span<char> destination, <#= keyWord #> value, out int charsWritten)
    {
        return value.TryFormat(destination, out charsWritten, _format, _formatProvider);
    }

    public override bool TryParse(ReadOnlySpan<char> source, [MaybeNullWhen(false)] out <#= keyWord #> value)
    {
        return <#= keyWord #>.TryParse(source, _styles, _formatProvider, out value);
    }
}

<# }
    foreach (var (typeName, keyWord, isInteger) in types) {
#>
internal sealed class <#= typeName #>Utf8Converter : CsvConverter<byte, <#= keyWord #>>
{
    private readonly StandardFormat _standardFormat;

    public <#= typeName #>Utf8Converter(CsvUtf8Options options)
    {
        _standardFormat = options.<#= isInteger ? "Integer" : "Decimal" #>Format;
    }

    public override bool TryFormat(Span<byte> destination, <#= keyWord #> value, out int charsWritten)
    {
<# if (typeName == "Half") { #>
        return Utf8Formatter.TryFormat((float)value, destination, out charsWritten, _standardFormat);
<# } else if (typeName == "IntPtr") { #>
        return Utf8Formatter.TryFormat((long)value, destination, out charsWritten, _standardFormat);
<# } else if (typeName == "UIntPtr") { #>
        return Utf8Formatter.TryFormat((ulong)value, destination, out charsWritten, _standardFormat);
<# } else { #>
        return Utf8Formatter.TryFormat(value, destination, out charsWritten, _standardFormat);
<# } #>
    }

    public override bool TryParse(ReadOnlySpan<byte> source, [MaybeNullWhen(false)] out <#= keyWord #> value)
    {
<# if (typeName == "Half") { #>
        if (Utf8Parser.TryParse(source, out float floatValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = (<#= typeName #>)floatValue;
            return true;
        }

        value = default;
        return false;
<# } else if (typeName == "IntPtr") { #>
        if (Utf8Parser.TryParse(source, out long longValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = checked((nint)longValue);
            return true;
        }
        value = default;
        return false;
<# } else if (typeName == "UIntPtr") { #>
        if (Utf8Parser.TryParse(source, out ulong ulongValue, out int bytesConsumed, _standardFormat.Symbol) &&
            bytesConsumed == source.Length)
        {
            value = checked((nuint)ulongValue);
            return true;
        }
        value = default;
        return false;
<# } else { #>
        return Utf8Parser.TryParse(source, out value, out int bytesConsumed, _standardFormat.Symbol) && bytesConsumed == source.Length;
<# } #>
    }
}

<# } #>