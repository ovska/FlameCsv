<#@ template language="C#" #>
// <auto-generated />
#nullable enable
using System.IO.Pipelines;
using System.Runtime.CompilerServices;
using System.Text;
using FlameCsv.Binding;
using FlameCsv.Writing;

namespace FlameCsv;

static partial class CsvWriter
{
<#
    const string docPath = "<param name=\"path\">Path of the destination file. Existing files are overwritten</param>";
    const string docValues = "<param name=\"values\">Values to write</param>";
    const string docOptions = "<param name=\"options\">Options to use, <see cref=\"CsvOptions{T}.Default\"/> used by default</param>";
    const string docToken = "<param name=\"cancellationToken\">Token to cancel the writing operation</param>";
    const string docReturns = "<returns>Task representing the asynchronous writing operation</returns>";
    const string docBuffersize = "<param name=\"bufferSize\">Buffer size to use for writing</param>";
    const string docEncoding = "<param name=\"encoding\">Encoding to pass to the inner <see cref=\"StreamWriter\"/></param>";
    const string docRemarks =
        """
        <remarks>
            /// Data is written even if <paramref name="values"/> empty,
            /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <see langword="false"/>.
            /// </remarks>
        """;

    foreach (var sourceGen in (bool[])[false, true])
    {
        string docSuffix = sourceGen
            ? " using the type map"
            : " using <see cref=\"CsvOptions{T}.TypeBinder\"/>";

        string attrs = sourceGen
            ? ""
            : "[RUF(Messages.Reflection), RDC(Messages.DynamicCode)]\n    ";

        string typeAttrs = sourceGen
            ? ""
            : "[DAM(Messages.ReflectionBound)] ";

        string bindValue = sourceGen
            ? "typeMap.GetDematerializer(options)"
            : "options.TypeBinder.GetDematerializer<TValue>()";

        string typeMapByte = sourceGen
            ? "\n        CsvTypeMap<byte, TValue> typeMap,"
            : "";

        string typeMapChar = sourceGen
            ? "\n        CsvTypeMap<char, TValue> typeMap,"
            : "";

        string typeMapDocs = sourceGen
            ? "\n    /// <param name=\"typeMap\">Type map to use for writing</param>"
            : "";
#>
    /// <summary>
    /// Writes the values as CSV records to a string<#= docSuffix #>.
    /// </summary>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <param name="builder">Optional builder to write the CSV to.</param>
    /// <returns>
    /// <see cref="StringBuilder"/> containing the CSV (same instance as <paramref name="builder"/> if provided)
    /// </returns>
    /// <#= docRemarks #>
    <#= attrs #>public static StringBuilder WriteToString<<#= typeAttrs #>TValue>(
        IEnumerable<TValue> values,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        StringBuilder? builder = null)
    {
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = <#= bindValue #>;

        builder ??= new();
        using var writer = CsvFieldWriter.Create(new StringWriter(builder), options, bufferSize: -1, leaveOpen: false);
        WriteCore(values, writer, dematerializer);
        return builder;
    }

    /// <summary>
    /// Writes the values as CSV records to a file<#= docSuffix #>.
    /// </summary>
    /// <#= docPath #>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docRemarks #>
    <#= attrs #>public static void WriteToFile<<#= typeAttrs #>TValue>(
        string path,
        IEnumerable<TValue> values,<#= typeMapByte #>
        CsvOptions<byte>? options = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = <#= bindValue #>;

        using FileStream stream = GetFileStream(path, isAsync: false);

        using var writer = CsvFieldWriter.Create(stream, options);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to a file<#= docSuffix #>.
    /// </summary>
    /// <#= docPath #>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docBuffersize #>
    /// <#= docRemarks #>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    <#= attrs #>public static void WriteToFile<<#= typeAttrs #>TValue>(
        string path,
        IEnumerable<TValue> values,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = <#= bindValue #>;

        if (bufferSize == -1) bufferSize = DefaultFileStreamBufferSize;

        using FileStream stream = GetFileStream(path, isAsync: false, bufferSize);
        using var writer = CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false);

        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="TextWriter"/><#= docSuffix #>.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docBuffersize #>
    /// <param name="leaveOpen">Whether to leave the writer open after writing</param>
    /// <#= docRemarks #>
    <#= attrs #>public static void Write<<#= typeAttrs #>TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = <#= bindValue #>;

        using var writer = CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="Stream"/><#= docSuffix #>.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <param name="bufferSize">Buffer size to use for writing</param>
    /// <param name="leaveOpen">Whether to leave the stream open after writing</param>
    /// <#= docRemarks #>
    <#= attrs #>public static void Write<<#= typeAttrs #>TValue>(
        Stream stream,
        IEnumerable<TValue> values,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        FlameCsv.Extensions.Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = <#= bindValue #>;

        using var writer = CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen);
        WriteCore(values, writer, dematerializer);
    }

<#
        foreach (var enumerableType in (string[])["IEnumerable<TValue>", "IAsyncEnumerable<TValue>"])
        {
#>
    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="TextWriter"/><#= docSuffix #>.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <param name="bufferSize">Buffer size to use for writing</param>
    /// <param name="leaveOpen">Whether to leave the writer open after writing</param>
    /// <#= docToken #>
    /// <#= docReturns #>
    /// <#= docRemarks #>
    <#= attrs #>public static async Task WriteAsync<<#= typeAttrs #>TValue>(
        TextWriter textWriter,
        <#= enumerableType #> values,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = <#= bindValue #>;

            using var writer = CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="Stream"/><#= docSuffix #>.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <param name="bufferSize">Buffer size to use for writing</param>
    /// <param name="leaveOpen">Whether to leave the stream open after writing</param>
    /// <#= docToken #>
    /// <#= docReturns #>
    /// <#= docRemarks #>
    <#= attrs #>public static async Task WriteAsync<<#= typeAttrs #>TValue>(
        Stream stream,
        <#= enumerableType #> values,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        FlameCsv.Extensions.Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();
            options ??= CsvOptions<byte>.Default;
            IDematerializer<byte, TValue> dematerializer = <#= bindValue #>;

            using var writer = CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
        finally
        {
            if (!leaveOpen) await stream.DisposeAsync().ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="PipeWriter"/><#= docSuffix #>.
    /// </summary>
    /// <param name="pipe">Pipe to write the CSV to</param>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docToken #>
    /// <#= docReturns #>
    /// <#= docRemarks #>
    <#= attrs #>public static async Task WriteAsync<<#= typeAttrs #>TValue>(
        PipeWriter pipe,
        <#= enumerableType #> values,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        if (cancellationToken.IsCancellationRequested)
        {
            OperationCanceledException exception = new(cancellationToken);
            await pipe.CompleteAsync(exception).ConfigureAwait(false);
            throw exception;
        }

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = <#= bindValue #>;

        using var writer = CsvFieldWriter.Create(pipe, options);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file<#= docSuffix #>.
    /// </summary>
    /// <#= docPath #>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docToken #>
    /// <#= docReturns #>
    /// <#= docRemarks #>
    <#= attrs #>public static async Task WriteToFileAsync<<#= typeAttrs #>TValue>(
        string path,
        <#= enumerableType #> values,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = <#= bindValue #>;

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            using var writer = CsvFieldWriter.Create(stream, options);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file<#= docSuffix #>.
    /// </summary>
    /// <#= docPath #>
    /// <#= docValues #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docBuffersize #>
    /// <#= docToken #>
    /// <#= docReturns #>
    /// <#= docRemarks #>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    <#= attrs #>public static async Task WriteToFileAsync<<#= typeAttrs #>TValue>(
        string path,
        <#= enumerableType #> values,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = <#= bindValue #>;

        if (bufferSize == -1) bufferSize = DefaultFileStreamBufferSize;

        FileStream stream = GetFileStream(path, isAsync: true, bufferSize);
        await using (stream.ConfigureAwait(false))
        {
            using var writer = CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

<#
        }
    }
#>
}
