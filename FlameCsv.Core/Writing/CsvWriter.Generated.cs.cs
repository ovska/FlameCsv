// <auto-generated />
#nullable enable
using System.IO.Pipelines;
using System.Runtime.CompilerServices;
using System.Text;
using FlameCsv.Binding;
using FlameCsv.Writing;

namespace FlameCsv;

static partial class CsvWriter
{
    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static void WriteToFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using FileStream stream = GetFileStream(path, isAsync: false);

        WriteCore(
            values,
            CsvFieldWriter.Create(stream, options),
            dematerializer);
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static void WriteToFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using FileStream stream = GetFileStream(path, isAsync: false, bufferSize);

        WriteCore(
            values,
            CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
            dematerializer);
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static void Write<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        WriteCore(
            values,
            CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
            dematerializer);
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static void Write<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        WriteCore(
            values,
            CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
            dematerializer);
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();
            options ??= CsvOptions<byte>.Default;
            IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            if (!leaveOpen) await stream.DisposeAsync().ConfigureAwait(false);
        }
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        PipeWriter pipe,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        if (cancellationToken.IsCancellationRequested)
        {
            OperationCanceledException exception = new(cancellationToken);
            await pipe.CompleteAsync(exception).ConfigureAwait(false);
            throw exception;
        }

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        await WriteAsyncCore(
            values,
            CsvFieldWriter.Create(pipe, options),
            dematerializer,
            cancellationToken).ConfigureAwait(false);
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IAsyncEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();
            options ??= CsvOptions<byte>.Default;
            IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            if (!leaveOpen) await stream.DisposeAsync().ConfigureAwait(false);
        }
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        PipeWriter pipe,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        if (cancellationToken.IsCancellationRequested)
        {
            OperationCanceledException exception = new(cancellationToken);
            await pipe.CompleteAsync(exception).ConfigureAwait(false);
            throw exception;
        }

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        await WriteAsyncCore(
            values,
            CsvFieldWriter.Create(pipe, options),
            dematerializer,
            cancellationToken).ConfigureAwait(false);
    }

    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.CompiledExpressions), RDC(Messages.CompiledExpressions)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    public static void WriteToFile<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using FileStream stream = GetFileStream(path, isAsync: false);

        WriteCore(
            values,
            CsvFieldWriter.Create(stream, options),
            dematerializer);
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static void WriteToFile<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        using FileStream stream = GetFileStream(path, isAsync: false, bufferSize);

        WriteCore(
            values,
            CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
            dematerializer);
    }

    public static void Write<TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        WriteCore(
            values,
            CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
            dematerializer);
    }

    public static void Write<TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        WriteCore(
            values,
            CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
            dematerializer);
    }

    public static async Task WriteAsync<TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    public static async Task WriteAsync<TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();
            options ??= CsvOptions<byte>.Default;
            IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            if (!leaveOpen) await stream.DisposeAsync().ConfigureAwait(false);
        }
    }

    public static async Task WriteAsync<TValue>(
        PipeWriter pipe,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        if (cancellationToken.IsCancellationRequested)
        {
            OperationCanceledException exception = new(cancellationToken);
            await pipe.CompleteAsync(exception).ConfigureAwait(false);
            throw exception;
        }

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        await WriteAsyncCore(
            values,
            CsvFieldWriter.Create(pipe, options),
            dematerializer,
            cancellationToken).ConfigureAwait(false);
    }

    public static async Task WriteToFileAsync<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    public static async Task WriteAsync<TValue>(
        TextWriter textWriter,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(textWriter, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    public static async Task WriteAsync<TValue>(
        Stream stream,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        int bufferSize = -1,
        bool leaveOpen = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(values);
        FlameCsv.Extensions.Guard.CanRead(stream);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();
            options ??= CsvOptions<byte>.Default;
            IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options, bufferSize, leaveOpen),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            if (!leaveOpen) await stream.DisposeAsync().ConfigureAwait(false);
        }
    }

    public static async Task WriteAsync<TValue>(
        PipeWriter pipe,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        if (cancellationToken.IsCancellationRequested)
        {
            OperationCanceledException exception = new(cancellationToken);
            await pipe.CompleteAsync(exception).ConfigureAwait(false);
            throw exception;
        }

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        await WriteAsyncCore(
            values,
            CsvFieldWriter.Create(pipe, options),
            dematerializer,
            cancellationToken).ConfigureAwait(false);
    }

    public static async Task WriteToFileAsync<TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(stream, options),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        int bufferSize = -1,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        FileStream stream = GetFileStream(path, isAsync: true);
        await using (stream.ConfigureAwait(false))
        {
            await WriteAsyncCore(
                values,
                CsvFieldWriter.Create(new StreamWriter(stream, encoding, bufferSize, false), options, bufferSize, leaveOpen: false),
                dematerializer,
                cancellationToken).ConfigureAwait(false);
        }
    }

}
