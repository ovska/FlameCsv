<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 16;
    var indexes = Enumerable.Range(0, TotalCount);
    var genericTypes = indexes.Select(i => $"T{i}").ToArray();
    var parsers = indexes.Select(i => $"ICsvParser<T, T{i}> parser{i}").ToArray();
    var values = indexes.Select(i => $"v{i}").ToArray();
#>
// <auto-generated />
using System.IO.Pipelines;
using FlameCsv.Reading;
using FlameCsv.Runtime;

namespace FlameCsv;

public static partial class CsvReader
{
    [System.Diagnostics.StackTraceHidden]
    private static void ValidateReadRecordsArgs(object reader, object options, object recordFactory, bool? hasHeader)
    {
        ArgumentNullException.ThrowIfNull(reader);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(recordFactory);
        if (hasHeader.GetValueOrDefault()) ThrowArgumentExceptionReadRecordsHasHeader();
    }

    private static void ThrowArgumentExceptionReadRecordsHasHeader()
    {
        throw new ArgumentException(
            "The options were configured to read a CSV with a header record, " +
            "which is not supported by ReadRecordsAsync.");
    }

<#
for (var _tokenType = 0; _tokenType < 2; _tokenType++)
{
    string tokenType = _tokenType == 0 ? "char" : "byte";
    string parameterReaderType = _tokenType == 0 ? "TextReader" : "PipeReader";
    string readerType = _tokenType == 0 ? "TextPipeReader" : "CsvBytePipeReader";
    string readerStructType =_tokenType == 0 ? "TextPipeReaderWrapper" : "PipeReaderWrapper";
#>
<#
    for (var current = 1; current <= TotalCount; current++)
    {
        var generics = string.Join(", ", genericTypes.Take(current)) + ", TValue";
#>
    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and parsers</param>
    /// <param name="recordFactory">Function to create the record from parsed column values</param>
    /// <param name="cancellationToken">Token to cancel the enumeration</param>
    /// <remarks>The CSV records must have <#= current #> column<# if (current != 1) Write("s"); #>.</remarks>
    public static IAsyncEnumerable<TValue> ReadRecordsAsync<<#= generics #>>(
        <#= parameterReaderType #> reader,
        CsvReaderOptions<<#= tokenType #>> options,
        Func<<#= generics #>> recordFactory,
        CancellationToken cancellationToken = default)
    {
        ValidateReadRecordsArgs(reader, options, recordFactory, options?.HasHeader);

        Materializer<<#= tokenType #>, <#= generics #>> materializer = new(recordFactory<#
            for (int i = 0; i < current; i++)
            {
                Write(", options.GetParser<");
                Write(genericTypes[i]);
                Write(">()");
            }
        #>);
        CsvProcessor<<#= tokenType #>, TValue> processor = new(options, materializer);

<# if (tokenType == "char") { #>
        var pipeReader = new TextPipeReaderWrapper(new <#= readerType #>(reader, options.ArrayPool));
<# } else { #>
        var pipeReader = new PipeReaderWrapper(reader);
<# } #>

        return ReadCoreAsync<<#= tokenType #>, TValue, <#= readerStructType #>, CsvProcessor<<#= tokenType #>, TValue>>(
            pipeReader,
            processor,
            cancellationToken: cancellationToken);
    }

<#
}
}
#>
}