<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 16;
    var indexes = Enumerable.Range(0, TotalCount);
    var genericTypes = indexes.Select(i => $"T{i}").ToArray();
    var formatters = indexes.Select(i => $"ICsvFormatter<T, T{i}> parser{i}").ToArray();
    var properties = indexes.Select(i => $"Item{i + 1}").ToArray();
#>
// <auto-generated />
using FlameCsv.Writers;

namespace FlameCsv;

internal static class WriteTestGen<T, TWriter>
    where T : unmanaged, IEquatable<T>
    where TWriter : struct, IAsyncBufferWriter<T>
{
    private static void EnsureNoHeader(CsvWriterOptions<T> options)
	{
		if (options.WriteHeader)
            ThrowForHeaderRecordWhenWritingTuples();
	}

    private static void ThrowForHeaderRecordWhenWritingTuples()
    {
        throw new InvalidOperationException("Cannot write header when writing value tuples.");
    }

<#
    for (int i = 1; i < TotalCount; i++)
	{
		var generics = string.Join(", ", genericTypes.Take(i + 1));
    foreach (var isAsync in new[] { false, true })
	{
        var moniker = isAsync ? "Async" : "";
        var waiter = isAsync ? "await " : "";
#>
    public static async Task Write<#= moniker #><<#= generics #>>(
        CsvWriteOperation<T, TWriter> writer,
        CsvWriterOptions<T> options,
        I<#= moniker #>Enumerable<(<#= generics #>)> records,
        CancellationToken cancellationToken)
    {
        EnsureNoHeader(options);
        cancellationToken.ThrowIfCancellationRequested();

        <#= waiter #>using var enumerator = records.Get<#= moniker #>Enumerator(<# if (isAsync) Write("cancellationToken"); #>);

        if (!<#= waiter #>enumerator.MoveNext<#= moniker #>())
			return;

<#
    for (int j = 0; j <= i; j++)
	{
        Write("        var formatter");
        Write(j.ToString());
        Write(" = options.GetFormatter<");
        Write(genericTypes[j]);
        WriteLine(">();");
    }
#>

        do
        {
            var record = enumerator.Current;
<#
    for (int j = 0; j <= i; j++)
	{
#>
<# if (j != 0) { #>
            writer.WriteDelimiter();
<# }#>
            await writer.WriteValueAsync(formatter<#= j #>, record.<#= properties[j] #>, cancellationToken);
<#
    }
#>
            writer.WriteNewline();
        } while (<#= waiter #>enumerator.MoveNext<#= moniker #>());
    }

<#
        }
    }
#>
}