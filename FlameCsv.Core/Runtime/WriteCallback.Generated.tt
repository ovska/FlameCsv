<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 16;
    var indexes = Enumerable.Range(0, TotalCount);
    var genericTypes = indexes.Select(i => $"T{i}").ToArray();
    var formatters = indexes.Select(i => $"ICsvFormatter<T, T{i}> parser{i}").ToArray();
    var properties = indexes.Select(i => $"Item{i + 1}").ToArray();
#>
#if false
// <auto-generated />
using FlameCsv.Writers;

namespace FlameCsv;

internal static class WriteTestGen<T, TWriter>
    where T : unmanaged, IEquatable<T>
    where TWriter : struct, IAsyncBufferWriter<T>
{
    private static void WriteHeader<TTuple>(CsvWriteOperation<T, TWriter> writer, CsvWriterOptions<T> options)
        where TTuple : struct, System.Runtime.CompilerServices.ITuple
	{
        if (options.WriteHeader)
        {
            int count = new TTuple().Length;
            int current = 0;
            
            while (current < count)
			{
                if (current != 0) writer.WriteDelimiter();
                writer.WriteString($"Item{++current}");
		    }

            writer.WriteNewline();
        }
	}

<#
    for (int i = 1; i < TotalCount; i++)
	{
		var generics = string.Join(", ", genericTypes.Take(i + 1));
#>
    public static async Task WriteAsync<<#= generics #>>(
        CsvWriteOperation<T, TWriter> writer,
        CsvWriterOptions<T> options,
        IAsyncEnumerable<(<#= generics #>)> records,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        WriteHeader<(<#= generics #>)>(writer, options);

        await using var enumerator = records.GetAsyncEnumerator(cancellationToken);

        if (!await enumerator.MoveNextAsync())
			return;

<#
    for (int j = 0; j <= i; j++)
	{
        Write("        var formatter");
        Write(j.ToString());
        Write(" = options.GetFormatter<");
        Write(genericTypes[j]);
        WriteLine(">();");
    }
#>

        do
        {
            if (writer.NeedsFlush)
                await writer.FlushAsync(cancellationToken);

            var record = enumerator.Current;
<#
    for (int j = 0; j <= i; j++)
	{
#>
<# if (j != 0) { #>
            writer.WriteDelimiter();
<# }#>
            writer.WriteValue(formatter<#= j #>, record.<#= properties[j] #>);
<#
    }
#>
            writer.WriteNewline();
        }
        while (await enumerator.MoveNextAsync());
    }

<#
    }
#>
}
#endif