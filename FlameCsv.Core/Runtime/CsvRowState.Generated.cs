// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using CommunityToolkit.Diagnostics;
using FlameCsv.Binding;
using FlameCsv.Parsers;
using FlameCsv.Reading;

namespace FlameCsv.Runtime;

internal abstract partial class CsvRowState
{
    /// <summary>
    /// Returns a constructor that returns a row state used for parsing <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="genericTypeParameters">Types of parsed columns in order</param>
    /// <typeparam name="T">CSV token type</typeparam>
    /// <typeparam name="TResult">Row parse return type</typeparam>
    [ExcludeFromCodeCoverage]
    internal static ConstructorInfo GetConstructor<T, TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
        where T : unmanaged, IEquatable<T>
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(CsvRowState<,,>),
            4 => typeof(CsvRowState<,,,>),
            5 => typeof(CsvRowState<,,,,>),
            6 => typeof(CsvRowState<,,,,,>),
            7 => typeof(CsvRowState<,,,,,,>),
            8 => typeof(CsvRowState<,,,,,,,>),
            9 => typeof(CsvRowState<,,,,,,,,>),
            10 => typeof(CsvRowState<,,,,,,,,,>),
            11 => typeof(CsvRowState<,,,,,,,,,,>),
            12 => typeof(CsvRowState<,,,,,,,,,,,>),
            13 => typeof(CsvRowState<,,,,,,,,,,,,>),
            14 => typeof(CsvRowState<,,,,,,,,,,,,,>),
            15 => typeof(CsvRowState<,,,,,,,,,,,,,,>),
            16 => typeof(CsvRowState<,,,,,,,,,,,,,,,>),
            17 => typeof(CsvRowState<,,,,,,,,,,,,,,,,>),
            18 => typeof(CsvRowState<,,,,,,,,,,,,,,,,,>),
            _ => ThrowHelper.ThrowArgumentException<Type>($"Unsupported typeparam count: {bindings.Length}"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 1;

    private readonly Func<T0, TResult> valueFactory;

    public CsvRowState(
        Func<T0, TResult> valueFactory,
        ICsvParser<T, T0> parser0)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
    }

    private readonly ICsvParser<T, T0> parser0;

    private T0 value0;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 2;

    private readonly Func<T0, T1, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;

    private T0 value0;
    private T1 value1;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 3;

    private readonly Func<T0, T1, T2, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;

    private T0 value0;
    private T1 value1;
    private T2 value2;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 4;

    private readonly Func<T0, T1, T2, T3, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 5;

    private readonly Func<T0, T1, T2, T3, T4, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 6;

    private readonly Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 7;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 8;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 9;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 10;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 11;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 12;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    private T11 value11;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        ParseNext(ref enumerator, parser11, out value11);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T11>()) value11 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 13;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    private T11 value11;
    private T12 value12;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        ParseNext(ref enumerator, parser11, out value11);
        ParseNext(ref enumerator, parser12, out value12);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T11>()) value11 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T12>()) value12 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 14;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    private T11 value11;
    private T12 value12;
    private T13 value13;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        ParseNext(ref enumerator, parser11, out value11);
        ParseNext(ref enumerator, parser12, out value12);
        ParseNext(ref enumerator, parser13, out value13);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T11>()) value11 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T12>()) value12 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T13>()) value13 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 15;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13,
        ICsvParser<T, T14> parser14)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
        this.parser14 = parser14;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;
    private readonly ICsvParser<T, T14> parser14;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    private T11 value11;
    private T12 value12;
    private T13 value13;
    private T14 value14;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        ParseNext(ref enumerator, parser11, out value11);
        ParseNext(ref enumerator, parser12, out value12);
        ParseNext(ref enumerator, parser13, out value13);
        ParseNext(ref enumerator, parser14, out value14);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T11>()) value11 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T12>()) value12 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T13>()) value13 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T14>()) value14 = default;
    }

    public void Dispose() => ResetValues();
}

[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => 16;

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory;

    public CsvRowState(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13,
        ICsvParser<T, T14> parser14,
        ICsvParser<T, T15> parser15)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
        this.parser14 = parser14;
        this.parser15 = parser15;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;
    private readonly ICsvParser<T, T14> parser14;
    private readonly ICsvParser<T, T15> parser15;

    private T0 value0;
    private T1 value1;
    private T2 value2;
    private T3 value3;
    private T4 value4;
    private T5 value5;
    private T6 value6;
    private T7 value7;
    private T8 value8;
    private T9 value9;
    private T10 value10;
    private T11 value11;
    private T12 value12;
    private T13 value13;
    private T14 value14;
    private T15 value15;

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
        ParseNext(ref enumerator, parser0, out value0);
        ParseNext(ref enumerator, parser1, out value1);
        ParseNext(ref enumerator, parser2, out value2);
        ParseNext(ref enumerator, parser3, out value3);
        ParseNext(ref enumerator, parser4, out value4);
        ParseNext(ref enumerator, parser5, out value5);
        ParseNext(ref enumerator, parser6, out value6);
        ParseNext(ref enumerator, parser7, out value7);
        ParseNext(ref enumerator, parser8, out value8);
        ParseNext(ref enumerator, parser9, out value9);
        ParseNext(ref enumerator, parser10, out value10);
        ParseNext(ref enumerator, parser11, out value11);
        ParseNext(ref enumerator, parser12, out value12);
        ParseNext(ref enumerator, parser13, out value13);
        ParseNext(ref enumerator, parser14, out value14);
        ParseNext(ref enumerator, parser15, out value15);
        enumerator.EnsureAllColumnsRead();

        var result = valueFactory(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T0>()) value0 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T1>()) value1 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T2>()) value2 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T3>()) value3 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T4>()) value4 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T5>()) value5 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T6>()) value6 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T7>()) value7 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T8>()) value8 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T9>()) value9 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T10>()) value10 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T11>()) value11 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T12>()) value12 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T13>()) value13 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T14>()) value14 = default;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T15>()) value15 = default;
    }

    public void Dispose() => ResetValues();
}

