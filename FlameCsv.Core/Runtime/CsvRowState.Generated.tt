<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 16;
    var indexes = Enumerable.Range(0, TotalCount).ToArray();
    var genericTypes = indexes.Select(i => $"T{i}").ToArray();
    var parsers = indexes.Select(i => $"ICsvParser<T, T{i}> parser{i}").ToArray();
    var values = indexes.Select(i => $"value{i}").ToArray();
#>
// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using CommunityToolkit.Diagnostics;
using FlameCsv.Binding;
using FlameCsv.Parsers;
using FlameCsv.Readers;

namespace FlameCsv.Runtime;

internal abstract partial class CsvRowState
{
    /// <summary>
    /// Returns a constructor that returns a row state used for parsing <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="genericTypeParameters">Types of parsed columns in order</param>
    /// <typeparam name="T">CSV token type</typeparam>
    /// <typeparam name="TResult">Row parse return type</typeparam>
    [ExcludeFromCodeCoverage]
    internal static ConstructorInfo GetConstructor<T, TResult>(ReadOnlySpan<CsvBinding> bindings)
        where T : unmanaged, IEquatable<T>
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
<#
    for (var i = 1; i <= TotalCount; i++)
    {
        Write("            ");
        Write((i + 2).ToString()); // T + generics# + TResult
        Write(" => typeof(CsvRowState<,,");

        for (var j = 1; j < i; j++)
        {
            Write(",");
        }

        WriteLine(">),");
    }
#>
            _ => ThrowHelper.ThrowArgumentException<Type>($"Unsupported typeparam count: {bindings.Length}"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

<#
    for (var current = 1; current <= TotalCount; current++)
    {
        var generics = string.Join(", ", genericTypes.Take(current)) + ", TResult";
#>
[ExcludeFromCodeCoverage]
internal sealed class CsvRowState<T, <#= generics #>> :
    CsvRowState, ICsvRowState<T, TResult>
    where T : unmanaged, IEquatable<T>
{
    public override int ColumnCount => <#= current #>;

    private readonly Func<<#= generics #>> valueFactory;

    public CsvRowState(
        Func<<#= generics #>> valueFactory,
<#
        for (var i = 0; i < current; i++)
        {
            if (i != 0)
                WriteLine(",");
            Write("        ");
            Write(parsers[i]);
        }
#>)
    {
        this.valueFactory = valueFactory;
<#
        for (var i = 0; i < current; i++)
        {
            var ix = i.ToString();
            Write("        this.parser");
            Write(ix);
            Write(" = parser");
            Write(ix);
            WriteLine(";");
        }
#>    }

<#
        for (var i = 0; i < current; i++)
        {
            Write("    private readonly ");
            Write(parsers[i]);
            WriteLine(";");
        }
#>

<#
        for (var i = 0; i < current; i++)
        {
            Write("    private ");
            Write(genericTypes[i]);
            Write(" ");
            Write(values[i]);
            WriteLine(";");
        }
#>

    public TResult Parse(ref CsvColumnEnumerator<T> enumerator)
    {
<#
        for (var i = 0; i < current; i++)
        {
            Write("        ParseNext(ref enumerator, parser");
            Write(i.ToString());
            Write(", out ");
            Write(values[i]);
            WriteLine(");");
        }
#>
        enumerator.EnsureAllColumnsRead();

<#
        Write("        var result = valueFactory(");
        for (var i = 0; i < current; i++)
        {
            if (i != 0)
                Write(", ");
            Write(values[i]);
        }
        WriteLine(");");
#>
        ResetValues();

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ResetValues()
    {
<#
        for (var i = 0; i < current; i++)
        {
            Write("        if (RuntimeHelpers.IsReferenceOrContainsReferences<T");
            Write(i.ToString());
            Write(">()) ");
            Write(values[i]);
            WriteLine(" = default;");
        }
#>
    }

    public void Dispose() => ResetValues();
}

<#
    }
#>