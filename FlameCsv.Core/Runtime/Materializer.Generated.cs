// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using FlameCsv.Binding;
using FlameCsv.Exceptions;
using FlameCsv.Reading;

namespace FlameCsv.Runtime;

internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RequiresUnreferencedCode("Trimmed Materializer<...> implementations may not be available during runtime.")]
    [RequiresDynamicCode("MakeGenericType is called on Materializer<...>")]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            > 18 => throw new NotSupportedException($"Type params up to {bindings.Length} are not supported (max: 16)"),
            _ => throw new ArgumentException($"Unsupported typeparam count: {bindings.Length}"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, TResult> valueFactory;

    public Materializer(
        Func<T0, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
    }

    private readonly CsvConverter<T, T0> converter0;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 1) CsvReadException.ThrowForInvalidFieldCount(1, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        return valueFactory(v0);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 2) CsvReadException.ThrowForInvalidFieldCount(2, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        return valueFactory(v0, v1);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 3) CsvReadException.ThrowForInvalidFieldCount(3, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        return valueFactory(v0, v1, v2);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 4) CsvReadException.ThrowForInvalidFieldCount(4, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        return valueFactory(v0, v1, v2, v3);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 5) CsvReadException.ThrowForInvalidFieldCount(5, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        return valueFactory(v0, v1, v2, v3, v4);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 6) CsvReadException.ThrowForInvalidFieldCount(6, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        return valueFactory(v0, v1, v2, v3, v4, v5);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 7) CsvReadException.ThrowForInvalidFieldCount(7, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 8) CsvReadException.ThrowForInvalidFieldCount(8, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 9) CsvReadException.ThrowForInvalidFieldCount(9, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 10) CsvReadException.ThrowForInvalidFieldCount(10, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 11) CsvReadException.ThrowForInvalidFieldCount(11, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 12) CsvReadException.ThrowForInvalidFieldCount(12, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        if (!converter11.TryParse(reader[11], out T11 v11)) CsvParseException.Throw(reader[11], converter11, GetName(11));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 13) CsvReadException.ThrowForInvalidFieldCount(13, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        if (!converter11.TryParse(reader[11], out T11 v11)) CsvParseException.Throw(reader[11], converter11, GetName(11));
        if (!converter12.TryParse(reader[12], out T12 v12)) CsvParseException.Throw(reader[12], converter12, GetName(12));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 14) CsvReadException.ThrowForInvalidFieldCount(14, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        if (!converter11.TryParse(reader[11], out T11 v11)) CsvParseException.Throw(reader[11], converter11, GetName(11));
        if (!converter12.TryParse(reader[12], out T12 v12)) CsvParseException.Throw(reader[12], converter12, GetName(12));
        if (!converter13.TryParse(reader[13], out T13 v13)) CsvParseException.Throw(reader[13], converter13, GetName(13));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 15) CsvReadException.ThrowForInvalidFieldCount(15, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        if (!converter11.TryParse(reader[11], out T11 v11)) CsvParseException.Throw(reader[11], converter11, GetName(11));
        if (!converter12.TryParse(reader[12], out T12 v12)) CsvParseException.Throw(reader[12], converter12, GetName(12));
        if (!converter13.TryParse(reader[13], out T13 v13)) CsvParseException.Throw(reader[13], converter13, GetName(13));
        if (!converter14.TryParse(reader[14], out T14 v14)) CsvParseException.Throw(reader[14], converter14, GetName(14));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory,
        CsvBindingCollection<TResult> bindingCollection,
        CsvOptions<T> options)
        : base(bindingCollection)
    {
        this.valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvRecordFields<T>, allows ref struct
    {
        if (reader.FieldCount != 16) CsvReadException.ThrowForInvalidFieldCount(16, reader.FieldCount);
        if (!converter0.TryParse(reader[0], out T0 v0)) CsvParseException.Throw(reader[0], converter0, GetName(0));
        if (!converter1.TryParse(reader[1], out T1 v1)) CsvParseException.Throw(reader[1], converter1, GetName(1));
        if (!converter2.TryParse(reader[2], out T2 v2)) CsvParseException.Throw(reader[2], converter2, GetName(2));
        if (!converter3.TryParse(reader[3], out T3 v3)) CsvParseException.Throw(reader[3], converter3, GetName(3));
        if (!converter4.TryParse(reader[4], out T4 v4)) CsvParseException.Throw(reader[4], converter4, GetName(4));
        if (!converter5.TryParse(reader[5], out T5 v5)) CsvParseException.Throw(reader[5], converter5, GetName(5));
        if (!converter6.TryParse(reader[6], out T6 v6)) CsvParseException.Throw(reader[6], converter6, GetName(6));
        if (!converter7.TryParse(reader[7], out T7 v7)) CsvParseException.Throw(reader[7], converter7, GetName(7));
        if (!converter8.TryParse(reader[8], out T8 v8)) CsvParseException.Throw(reader[8], converter8, GetName(8));
        if (!converter9.TryParse(reader[9], out T9 v9)) CsvParseException.Throw(reader[9], converter9, GetName(9));
        if (!converter10.TryParse(reader[10], out T10 v10)) CsvParseException.Throw(reader[10], converter10, GetName(10));
        if (!converter11.TryParse(reader[11], out T11 v11)) CsvParseException.Throw(reader[11], converter11, GetName(11));
        if (!converter12.TryParse(reader[12], out T12 v12)) CsvParseException.Throw(reader[12], converter12, GetName(12));
        if (!converter13.TryParse(reader[13], out T13 v13)) CsvParseException.Throw(reader[13], converter13, GetName(13));
        if (!converter14.TryParse(reader[14], out T14 v14)) CsvParseException.Throw(reader[14], converter14, GetName(14));
        if (!converter15.TryParse(reader[15], out T15 v15)) CsvParseException.Throw(reader[15], converter15, GetName(15));
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }
}

