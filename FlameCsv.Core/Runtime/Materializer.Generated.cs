// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using FlameCsv.Binding;
using FlameCsv.Reading;

namespace FlameCsv.Runtime;

internal abstract partial class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="T">CSV token type</typeparam>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RequiresUnreferencedCode("Trimmed Materializer<...> implementations may not be available during runtime.")]
    [RequiresDynamicCode("MakeGenericType is called on Materializer<...>")]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            _ => throw new ArgumentException($"Unsupported typeparam count: {bindings.Length}"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 1;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, TResult> valueFactory;

    public Materializer(
        Func<T0, TResult> valueFactory,
        CsvConverter<T, T0> converter0)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
    }

    private readonly CsvConverter<T, T0> converter0;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        reader.Dispose();
        return valueFactory(v0);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 2;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        reader.Dispose();
        return valueFactory(v0, v1);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 3;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        reader.Dispose();
        return valueFactory(v0, v1, v2);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 4;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 5;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 6;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 7;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 8;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 9;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 10;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 11;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 12;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10,
        CsvConverter<T, T11> converter11)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
        this.converter11 = converter11;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        T11 v11 = ParseNext(ref reader, converter11);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 13;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10,
        CsvConverter<T, T11> converter11,
        CsvConverter<T, T12> converter12)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
        this.converter11 = converter11;
        this.converter12 = converter12;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        T11 v11 = ParseNext(ref reader, converter11);
        T12 v12 = ParseNext(ref reader, converter12);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 14;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10,
        CsvConverter<T, T11> converter11,
        CsvConverter<T, T12> converter12,
        CsvConverter<T, T13> converter13)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
        this.converter11 = converter11;
        this.converter12 = converter12;
        this.converter13 = converter13;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        T11 v11 = ParseNext(ref reader, converter11);
        T12 v12 = ParseNext(ref reader, converter12);
        T13 v13 = ParseNext(ref reader, converter13);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 15;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10,
        CsvConverter<T, T11> converter11,
        CsvConverter<T, T12> converter12,
        CsvConverter<T, T13> converter13,
        CsvConverter<T, T14> converter14)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
        this.converter11 = converter11;
        this.converter12 = converter12;
        this.converter13 = converter13;
        this.converter14 = converter14;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        T11 v11 = ParseNext(ref reader, converter11);
        T12 v12 = ParseNext(ref reader, converter12);
        T13 v13 = ParseNext(ref reader, converter13);
        T14 v14 = ParseNext(ref reader, converter14);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 16;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory,
        CsvConverter<T, T0> converter0,
        CsvConverter<T, T1> converter1,
        CsvConverter<T, T2> converter2,
        CsvConverter<T, T3> converter3,
        CsvConverter<T, T4> converter4,
        CsvConverter<T, T5> converter5,
        CsvConverter<T, T6> converter6,
        CsvConverter<T, T7> converter7,
        CsvConverter<T, T8> converter8,
        CsvConverter<T, T9> converter9,
        CsvConverter<T, T10> converter10,
        CsvConverter<T, T11> converter11,
        CsvConverter<T, T12> converter12,
        CsvConverter<T, T13> converter13,
        CsvConverter<T, T14> converter14,
        CsvConverter<T, T15> converter15)
    {
        this.valueFactory = valueFactory;
        this.converter0 = converter0;
        this.converter1 = converter1;
        this.converter2 = converter2;
        this.converter3 = converter3;
        this.converter4 = converter4;
        this.converter5 = converter5;
        this.converter6 = converter6;
        this.converter7 = converter7;
        this.converter8 = converter8;
        this.converter9 = converter9;
        this.converter10 = converter10;
        this.converter11 = converter11;
        this.converter12 = converter12;
        this.converter13 = converter13;
        this.converter14 = converter14;
        this.converter15 = converter15;
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;

    public TResult Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<T>, allows ref struct
    {
        T0 v0 = ParseNext(ref reader, converter0);
        T1 v1 = ParseNext(ref reader, converter1);
        T2 v2 = ParseNext(ref reader, converter2);
        T3 v3 = ParseNext(ref reader, converter3);
        T4 v4 = ParseNext(ref reader, converter4);
        T5 v5 = ParseNext(ref reader, converter5);
        T6 v6 = ParseNext(ref reader, converter6);
        T7 v7 = ParseNext(ref reader, converter7);
        T8 v8 = ParseNext(ref reader, converter8);
        T9 v9 = ParseNext(ref reader, converter9);
        T10 v10 = ParseNext(ref reader, converter10);
        T11 v11 = ParseNext(ref reader, converter11);
        T12 v12 = ParseNext(ref reader, converter12);
        T13 v13 = ParseNext(ref reader, converter13);
        T14 v14 = ParseNext(ref reader, converter14);
        T15 v15 = ParseNext(ref reader, converter15);
        reader.Dispose();
        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }
}

