// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using CommunityToolkit.Diagnostics;
using FlameCsv.Binding;
using FlameCsv.Extensions;
using FlameCsv.Parsers;
using FlameCsv.Reading;

namespace FlameCsv.Runtime;

internal abstract partial class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="T">CSV token type</typeparam>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            _ => ThrowHelper.ThrowArgumentException<Type>("Unsupported typeparam count: " + bindings.Length),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 1;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, TResult> valueFactory;

    public Materializer(
        Func<T0, TResult> valueFactory,
        ICsvParser<T, T0> parser0)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
    }

    private readonly ICsvParser<T, T0> parser0;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);

        return valueFactory(v0);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 2;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);

        return valueFactory(v0, v1);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 3;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);

        return valueFactory(v0, v1, v2);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 4;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);

        return valueFactory(v0, v1, v2, v3);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 5;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);

        return valueFactory(v0, v1, v2, v3, v4);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 6;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);

        return valueFactory(v0, v1, v2, v3, v4, v5);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 7;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 8;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 9;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 10;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 11;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 12;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);
        T11 v11 = ParseNext(ref state, parser11);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);
        T11 v11 = ParseKnown(fields[11].Span, parser11);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 13;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);
        T11 v11 = ParseNext(ref state, parser11);
        T12 v12 = ParseNext(ref state, parser12);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);
        T11 v11 = ParseKnown(fields[11].Span, parser11);
        T12 v12 = ParseKnown(fields[12].Span, parser12);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 14;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);
        T11 v11 = ParseNext(ref state, parser11);
        T12 v12 = ParseNext(ref state, parser12);
        T13 v13 = ParseNext(ref state, parser13);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);
        T11 v11 = ParseKnown(fields[11].Span, parser11);
        T12 v12 = ParseKnown(fields[12].Span, parser12);
        T13 v13 = ParseKnown(fields[13].Span, parser13);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 15;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13,
        ICsvParser<T, T14> parser14)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
        this.parser14 = parser14;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;
    private readonly ICsvParser<T, T14> parser14;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);
        T11 v11 = ParseNext(ref state, parser11);
        T12 v12 = ParseNext(ref state, parser12);
        T13 v13 = ParseNext(ref state, parser13);
        T14 v14 = ParseNext(ref state, parser14);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);
        T11 v11 = ParseKnown(fields[11].Span, parser11);
        T12 v12 = ParseKnown(fields[12].Span, parser12);
        T13 v13 = ParseKnown(fields[13].Span, parser13);
        T14 v14 = ParseKnown(fields[14].Span, parser14);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>
    : Materializer<T>, IMaterializer<T, TResult> where T : unmanaged, IEquatable<T>
{
    public override int FieldCount => 16;

    protected override Type RecordType => typeof(TResult);

    private readonly Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory;

    public Materializer(
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFactory,
        ICsvParser<T, T0> parser0,
        ICsvParser<T, T1> parser1,
        ICsvParser<T, T2> parser2,
        ICsvParser<T, T3> parser3,
        ICsvParser<T, T4> parser4,
        ICsvParser<T, T5> parser5,
        ICsvParser<T, T6> parser6,
        ICsvParser<T, T7> parser7,
        ICsvParser<T, T8> parser8,
        ICsvParser<T, T9> parser9,
        ICsvParser<T, T10> parser10,
        ICsvParser<T, T11> parser11,
        ICsvParser<T, T12> parser12,
        ICsvParser<T, T13> parser13,
        ICsvParser<T, T14> parser14,
        ICsvParser<T, T15> parser15)
    {
        this.valueFactory = valueFactory;
        this.parser0 = parser0;
        this.parser1 = parser1;
        this.parser2 = parser2;
        this.parser3 = parser3;
        this.parser4 = parser4;
        this.parser5 = parser5;
        this.parser6 = parser6;
        this.parser7 = parser7;
        this.parser8 = parser8;
        this.parser9 = parser9;
        this.parser10 = parser10;
        this.parser11 = parser11;
        this.parser12 = parser12;
        this.parser13 = parser13;
        this.parser14 = parser14;
        this.parser15 = parser15;
    }

    private readonly ICsvParser<T, T0> parser0;
    private readonly ICsvParser<T, T1> parser1;
    private readonly ICsvParser<T, T2> parser2;
    private readonly ICsvParser<T, T3> parser3;
    private readonly ICsvParser<T, T4> parser4;
    private readonly ICsvParser<T, T5> parser5;
    private readonly ICsvParser<T, T6> parser6;
    private readonly ICsvParser<T, T7> parser7;
    private readonly ICsvParser<T, T8> parser8;
    private readonly ICsvParser<T, T9> parser9;
    private readonly ICsvParser<T, T10> parser10;
    private readonly ICsvParser<T, T11> parser11;
    private readonly ICsvParser<T, T12> parser12;
    private readonly ICsvParser<T, T13> parser13;
    private readonly ICsvParser<T, T14> parser14;
    private readonly ICsvParser<T, T15> parser15;

    public TResult Parse(ref CsvEnumerationStateRef<T> state)
    {
        T0 v0 = ParseNext(ref state, parser0);
        T1 v1 = ParseNext(ref state, parser1);
        T2 v2 = ParseNext(ref state, parser2);
        T3 v3 = ParseNext(ref state, parser3);
        T4 v4 = ParseNext(ref state, parser4);
        T5 v5 = ParseNext(ref state, parser5);
        T6 v6 = ParseNext(ref state, parser6);
        T7 v7 = ParseNext(ref state, parser7);
        T8 v8 = ParseNext(ref state, parser8);
        T9 v9 = ParseNext(ref state, parser9);
        T10 v10 = ParseNext(ref state, parser10);
        T11 v11 = ParseNext(ref state, parser11);
        T12 v12 = ParseNext(ref state, parser12);
        T13 v13 = ParseNext(ref state, parser13);
        T14 v14 = ParseNext(ref state, parser14);
        T15 v15 = ParseNext(ref state, parser15);

        state.EnsureFullyConsumed(FieldCount);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }

    public TResult Parse(ReadOnlySpan<ReadOnlyMemory<T>> fields)
    {
        if (FieldCount != fields.Length)
            Throw.InvalidData_FieldCount(FieldCount, fields.Length);

        T0 v0 = ParseKnown(fields[0].Span, parser0);
        T1 v1 = ParseKnown(fields[1].Span, parser1);
        T2 v2 = ParseKnown(fields[2].Span, parser2);
        T3 v3 = ParseKnown(fields[3].Span, parser3);
        T4 v4 = ParseKnown(fields[4].Span, parser4);
        T5 v5 = ParseKnown(fields[5].Span, parser5);
        T6 v6 = ParseKnown(fields[6].Span, parser6);
        T7 v7 = ParseKnown(fields[7].Span, parser7);
        T8 v8 = ParseKnown(fields[8].Span, parser8);
        T9 v9 = ParseKnown(fields[9].Span, parser9);
        T10 v10 = ParseKnown(fields[10].Span, parser10);
        T11 v11 = ParseKnown(fields[11].Span, parser11);
        T12 v12 = ParseKnown(fields[12].Span, parser12);
        T13 v13 = ParseKnown(fields[13].Span, parser13);
        T14 v14 = ParseKnown(fields[14].Span, parser14);
        T15 v15 = ParseKnown(fields[15].Span, parser15);

        return valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }
}

