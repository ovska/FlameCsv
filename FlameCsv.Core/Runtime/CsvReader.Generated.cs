#if false
// <auto-generated />
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.IO.Pipelines;
using FlameCsv.Enumeration;
using FlameCsv.Extensions;
using FlameCsv.Reading;
using FlameCsv.Runtime;
using FlameCsv.Utilities;

namespace FlameCsv;

public static partial class CsvReader
{
    public sealed class CsvRecordFactoryAsyncEnumerable<T, TValue> : IAsyncEnumerable<TValue>
        where T : unmanaged, IBinaryInteger<T>
    {
        private readonly CsvOptions<T> _options;
        private readonly ICsvPipeReader<T> _reader;
        private readonly IMaterializer<T, TValue> _materializer;

        internal CsvRecordFactoryAsyncEnumerable(CsvOptions<T> options, ICsvPipeReader<T> reader, IMaterializer<T, TValue> materializer)
        {
            _options = options;
            _reader = reader;
            _materializer = materializer;
        }

        public CsvValueAsyncEnumerator<T, TValue> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            return new CsvValueAsyncEnumerator<T, TValue>(
                _options,
                _materializer,
                _reader,
                cancellationToken);
        }

        IAsyncEnumerator<TValue> IAsyncEnumerable<TValue>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAsyncEnumerator(cancellationToken);
        }
    }

    [System.Diagnostics.StackTraceHidden]
    private static void ValidateReadRecordsArgs<T>(
        [NotNull] object? reader,
        [NotNull] CsvOptions<T>? options,
        [NotNull] Delegate? recordFactory,
        ref ValueListBuilder<string> list)
        where T : unmanaged, IBinaryInteger<T>
    {
        ArgumentNullException.ThrowIfNull(reader);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(recordFactory);

        options.MakeReadOnly();

        var parameters = recordFactory.Method.GetParameters();
        for (int i = 0; i < parameters.Length; i++)
        {
            var parameter = parameters[i];
            list.Append(parameter.Name ?? $"arg{i}");
        }
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 1 field.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), names[0]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 2 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), names[0], names[1]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 3 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), names[0], names[1], names[2]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 4 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), names[0], names[1], names[2], names[3]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 5 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), names[0], names[1], names[2], names[3], names[4]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 6 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), names[0], names[1], names[2], names[3], names[4], names[5]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 7 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 8 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 9 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 10 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 11 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 12 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 13 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 14 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 15 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), options.GetConverter<T14>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13], names[14]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 16 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<char, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue>(
        TextReader reader,
        CsvOptions<char> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<char, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), options.GetConverter<T14>(), options.GetConverter<T15>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13], names[14], names[15]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<char, TValue>(
            options,
            new TextPipeReader(reader, DefaultBufferSize, options._memoryPool),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 1 field.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), names[0]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 2 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), names[0], names[1]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 3 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), names[0], names[1], names[2]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 4 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), names[0], names[1], names[2], names[3]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 5 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), names[0], names[1], names[2], names[3], names[4]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 6 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), names[0], names[1], names[2], names[3], names[4], names[5]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 7 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 8 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 9 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 10 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 11 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 12 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 13 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 14 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 15 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), options.GetConverter<T14>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13], names[14]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

    /// <summary>Asynchronously reads <typeparamref name="TValue"/> from the reader.</summary>
    /// <param name="reader">Reader to read the CSV records from</param>
    /// <param name="options">Options instance containing tokens and converters</param>
    /// <param name="recordFactory">Function to create the record from parsed field values</param>
    /// <remarks>
    /// The CSV records must have 16 fields.<br/>Possible binding attributes placed
    /// on the parameter factory are ignored, and parameter position is always used to determine the field index.
    /// </remarks>
    public static CsvRecordFactoryAsyncEnumerable<byte, TValue> ReadRecordsAsync<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue>(
        PipeReader reader,
        CsvOptions<byte> options,
        Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue> recordFactory)
    {
        StringScratch scratch = default;
        var list = new ValueListBuilder<string>(scratch!);
        ValidateReadRecordsArgs(reader, options, recordFactory, ref list);
        ReadOnlySpan<string> names = list.AsSpan();

        Materializer<byte, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TValue> materializer = new(recordFactory, options.GetConverter<T0>(), options.GetConverter<T1>(), options.GetConverter<T2>(), options.GetConverter<T3>(), options.GetConverter<T4>(), options.GetConverter<T5>(), options.GetConverter<T6>(), options.GetConverter<T7>(), options.GetConverter<T8>(), options.GetConverter<T9>(), options.GetConverter<T10>(), options.GetConverter<T11>(), options.GetConverter<T12>(), options.GetConverter<T13>(), options.GetConverter<T14>(), options.GetConverter<T15>(), names[0], names[1], names[2], names[3], names[4], names[5], names[6], names[7], names[8], names[9], names[10], names[11], names[12], names[13], names[14], names[15]);

        list.Dispose();

        return new CsvRecordFactoryAsyncEnumerable<byte, TValue>(
            options,
            new PipeReaderWrapper(reader),
            materializer);
    }

}
#endif
