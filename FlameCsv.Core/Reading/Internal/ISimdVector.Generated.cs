// <auto-generated />
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.Wasm;
using System.Runtime.Intrinsics.X86;
using System.Text;

#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value

namespace FlameCsv.Reading.Internal;

// this code borrows heavily from Ascii.Utility.cs in System.Text.Ascii (MIT license)

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class SimdVector
{
    /// <summary>
    /// Returns true if T is supported by SIMD vector types, and in case of <see langword="char"/>,
    /// all tokens are ASCII.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsSupported<T>(ref readonly CsvDialect<T> dialect) where T : unmanaged, IBinaryInteger<T>
    {
        return dialect.IsAscii && TryGetMaxSupportedCount<T>(out int count) && count > 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryGetMaxSupportedCount<T>(out int count) where T : unmanaged
    {
        if (Unsafe.SizeOf<T>() == sizeof(char))
        {
            if (Vec256Char.IsSupported)
            {
                count = Vec256Char.Count;
                return true;
            }
            if (Vec128Char.IsSupported)
            {
                count = Vec128Char.Count;
                return true;
            }
            if (Vec64Char.IsSupported)
            {
                count = Vec64Char.Count;
                return true;
            }
        }
        if (Unsafe.SizeOf<T>() == sizeof(byte))
        {
            if (Vec256Byte.IsSupported)
            {
                count = Vec256Byte.Count;
                return true;
            }
            if (Vec128Byte.IsSupported)
            {
                count = Vec128Byte.Count;
                return true;
            }
            if (Vec64Byte.IsSupported)
            {
                count = Vec64Byte.Count;
                return true;
            }
        }
        count = 0;
        return false;
    }
}

/// <summary>Generic type wrapping a byte vector.</summary>
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal interface ISimdVector<T, TVector>
    where T : unmanaged, IBinaryInteger<T>
    where TVector : struct, ISimdVector<T, TVector>
{
    static abstract bool IsSupported { get; }
    static abstract int Count { get; }
    static abstract TVector Zero { get; }
    static abstract TVector Equals(TVector left, TVector right);
    static abstract TVector Create(T value);
    static abstract TVector LoadUnsafe(ref readonly T source, nuint offset);
    static abstract TVector Or(TVector left, TVector right);
    static abstract bool operator ==(TVector left, TVector right);
    static abstract bool operator !=(TVector left, TVector right);
    [JetBrains.Annotations.Pure] nuint ExtractMostSignificantBits();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec64Char : ISimdVector<char, Vec64Char>
{
    private readonly Vector64<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector64<byte>.IsSupported
#if RELEASE
            && Vector64.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector64<byte>.Count;
    }

    public static Vec64Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector64<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Char Equals(Vec64Char left, Vec64Char right) => Vector64.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Char Create(char value) => Vector64.Create(unchecked((byte)value));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Char LoadUnsafe(ref readonly char source, nuint offset)
    {
        ref byte asByte = ref Unsafe.As<char, byte>(ref Unsafe.Add(ref Unsafe.AsRef(in source), offset));
        var v0 = Unsafe.ReadUnaligned<Vector64<ushort>>(ref asByte);
        var v1 = Unsafe.ReadUnaligned<Vector64<ushort>>(ref Unsafe.Add(ref asByte, Vector64<byte>.Count));
        var maxAscii = Vector64.Create((ushort)127);
        var lower = Vector64.Min(v0, maxAscii);
        var upper = Vector64.Min(v1, maxAscii);
        return Vector64.Narrow(lower, upper);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Char Or(Vec64Char left, Vec64Char right) => Vector64.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec64Char left, Vec64Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec64Char left, Vec64Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec64Char(Vector64<byte> value) => Unsafe.As<Vector64<byte>, Vec64Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector64<byte>(Vec64Char value) => Unsafe.As<Vec64Char, Vector64<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec128Char : ISimdVector<char, Vec128Char>
{
    private readonly Vector128<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector128<byte>.IsSupported
#if RELEASE
            && Vector128.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector128<byte>.Count;
    }

    public static Vec128Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector128<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Char Equals(Vec128Char left, Vec128Char right) => Vector128.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Char Create(char value) => Vector128.Create(unchecked((byte)value));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Char LoadUnsafe(ref readonly char source, nuint offset)
    {
        ref byte asByte = ref Unsafe.As<char, byte>(ref Unsafe.Add(ref Unsafe.AsRef(in source), offset));
        var v0 = Unsafe.ReadUnaligned<Vector128<ushort>>(ref asByte);
        var v1 = Unsafe.ReadUnaligned<Vector128<ushort>>(ref Unsafe.Add(ref asByte, Vector128<byte>.Count));
        var maxAscii = Vector128.Create((ushort)127);
        var lower = Vector128.Min(v0, maxAscii);
        var upper = Vector128.Min(v1, maxAscii);

        if (Sse2.IsSupported)
        {
            return Sse2.PackUnsignedSaturate(lower.AsInt16(), upper.AsInt16());
        }
        else if (AdvSimd.Arm64.IsSupported)
        {
            return AdvSimd.Arm64.UnzipEven(lower.AsByte(), upper.AsByte());
        }
        else if (PackedSimd.IsSupported)
        {
            return PackedSimd.ConvertNarrowingSaturateUnsigned(lower.AsInt16(), upper.AsInt16());
        }
        else
        {
            return Vector128.Narrow(lower, upper);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Char Or(Vec128Char left, Vec128Char right) => Vector128.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => 
        Avx.IsSupported ? (nuint)(uint)Avx.MoveMask(_value) : 
        Sse2.IsSupported ? (nuint)(uint)Sse2.MoveMask(_value) : 
        (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec128Char left, Vec128Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec128Char left, Vec128Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec128Char(Vector128<byte> value) => Unsafe.As<Vector128<byte>, Vec128Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector128<byte>(Vec128Char value) => Unsafe.As<Vec128Char, Vector128<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec256Char : ISimdVector<char, Vec256Char>
{
    private readonly Vector256<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector256<byte>.IsSupported
#if RELEASE
            && Vector256.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector256<byte>.Count;
    }

    public static Vec256Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector256<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Char Equals(Vec256Char left, Vec256Char right) => Vector256.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Char Create(char value) => Vector256.Create(unchecked((byte)value));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Char LoadUnsafe(ref readonly char source, nuint offset)
    {
        ref byte asByte = ref Unsafe.As<char, byte>(ref Unsafe.Add(ref Unsafe.AsRef(in source), offset));
        var v0 = Unsafe.ReadUnaligned<Vector256<ushort>>(ref asByte);
        var v1 = Unsafe.ReadUnaligned<Vector256<ushort>>(ref Unsafe.Add(ref asByte, Vector256<byte>.Count));
        var maxAscii = Vector256.Create((ushort)127);
        var lower = Vector256.Min(v0, maxAscii);
        var upper = Vector256.Min(v1, maxAscii);

        if (Avx2.IsSupported)
        {
            var packed = Avx2.PackUnsignedSaturate(lower.AsInt16(), upper.AsInt16());
            return Avx2.Permute4x64(packed.AsInt64(), 0b_11_01_10_00).AsByte();
        }
        else
        {
            return Vector256.Narrow(lower, upper);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Char Or(Vec256Char left, Vec256Char right) => Vector256.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => 
        Avx2.IsSupported ? (nuint)(uint)Avx2.MoveMask(_value) : 
        (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec256Char left, Vec256Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec256Char left, Vec256Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec256Char(Vector256<byte> value) => Unsafe.As<Vector256<byte>, Vec256Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector256<byte>(Vec256Char value) => Unsafe.As<Vec256Char, Vector256<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec64Byte : ISimdVector<byte, Vec64Byte>
{
    private readonly Vector64<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector64<byte>.IsSupported
#if RELEASE
            && Vector64.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector64<byte>.Count;
    }

    public static Vec64Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector64<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Byte Equals(Vec64Byte left, Vec64Byte right) => Vector64.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Byte Create(byte value) => Vector64.Create(value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Byte LoadUnsafe(ref readonly byte source, nuint offset) => Vector64.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec64Byte Or(Vec64Byte left, Vec64Byte right) => Vector64.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec64Byte left, Vec64Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec64Byte left, Vec64Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec64Byte(Vector64<byte> value) => Unsafe.As<Vector64<byte>, Vec64Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector64<byte>(Vec64Byte value) => Unsafe.As<Vec64Byte, Vector64<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec128Byte : ISimdVector<byte, Vec128Byte>
{
    private readonly Vector128<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector128<byte>.IsSupported
#if RELEASE
            && Vector128.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector128<byte>.Count;
    }

    public static Vec128Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector128<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Byte Equals(Vec128Byte left, Vec128Byte right) => Vector128.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Byte Create(byte value) => Vector128.Create(value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Byte LoadUnsafe(ref readonly byte source, nuint offset) => Vector128.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec128Byte Or(Vec128Byte left, Vec128Byte right) => Vector128.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => 
        Avx.IsSupported ? (nuint)(uint)Avx.MoveMask(_value) : 
        Sse2.IsSupported ? (nuint)(uint)Sse2.MoveMask(_value) : 
        (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec128Byte left, Vec128Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec128Byte left, Vec128Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec128Byte(Vector128<byte> value) => Unsafe.As<Vector128<byte>, Vec128Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector128<byte>(Vec128Byte value) => Unsafe.As<Vec128Byte, Vector128<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec256Byte : ISimdVector<byte, Vec256Byte>
{
    private readonly Vector256<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
            => Vector256<byte>.IsSupported
#if RELEASE
            && Vector256.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector256<byte>.Count;
    }

    public static Vec256Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Vector256<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Byte Equals(Vec256Byte left, Vec256Byte right) => Vector256.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Byte Create(byte value) => Vector256.Create(value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Byte LoadUnsafe(ref readonly byte source, nuint offset) => Vector256.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vec256Byte Or(Vec256Byte left, Vec256Byte right) => Vector256.BitwiseOr(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public nuint ExtractMostSignificantBits() => 
        Avx2.IsSupported ? (nuint)(uint)Avx2.MoveMask(_value) : 
        (nuint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vec256Byte left, Vec256Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vec256Byte left, Vec256Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Vec256Byte(Vector256<byte> value) => Unsafe.As<Vector256<byte>, Vec256Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Vector256<byte>(Vec256Byte value) => Unsafe.As<Vec256Byte, Vector256<byte>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
internal readonly struct NoOpVector<T> : ISimdVector<T, NoOpVector<T>> where T : unmanaged, IBinaryInteger<T>
{
    public static bool IsSupported => false;
    public static int Count => 0;
    public static NoOpVector<T> Zero => throw new NotSupportedException();
    public static NoOpVector<T> Equals(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public static NoOpVector<T> Create(T value) => throw new NotSupportedException();
    public static NoOpVector<T> LoadUnsafe(ref readonly T source, nuint offset) => throw new NotSupportedException();
    public static NoOpVector<T> Or(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public nuint ExtractMostSignificantBits() => throw new NotSupportedException();
    public static bool operator ==(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public static bool operator !=(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public override string ToString() => "NoOpVector";
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

