<#@ template language="C#" #>
<#
    const string MethodImpl = "MethodImpl(MethodImplOptions.AggressiveInlining)";
    const string PragmaCondition = "RELEASE";

    // TODO: Add support for AVX-512 etc.
    (string size, string[] moveMask)[] intrinsics = [
        ("64", []),
        ("128", ["Sse2", "Avx"]),
        ("256", ["Avx2"]),
        // ("512", ["Avx512F", "Avx512BW"]),
        ];

    (string keyword, string name)[] types = [("char", "Char"), ("byte", "Byte")];
#>
/// <auto-generated />
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Text;

#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value

namespace FlameCsv.Reading.Internal;

internal static class SimdVector
{
    /// <summary>
    /// Returns true if T is supported by SIMD vector types, and in case of <see langword="char"/>,
    /// all tokens are ASCII.
    /// </summary>
    [<#= MethodImpl #>]
    public static bool IsSupported<T>(ref readonly CsvDialect<T> d)
        where T : unmanaged, IBinaryInteger<T> =>
        d.IsAscii &&
<#
    for (var index = types.Length - 1; index >= 0; index--)
    {
        var (keyword, name) = types[index];
        Write("        ");
        Write(index != 0 ? "((" : " (");
        Write("Unsafe.SizeOf<T>() == sizeof(");
        Write(keyword);
        Write(") && (");
        for (int i = intrinsics.Length - 1; i >= 0; i--)
        {
            Write("Vec");
            Write(intrinsics[i].size);
            Write(name);
            Write(".IsSupported");
            if (i != 0)
                Write(" || ");
        }

        WriteLine(index != 0 ? ")) ||" : ")));");
    }
#>

    [<#= MethodImpl #>]
    public static bool TryGetMaxSupportedCount<T>(out int count) where T : unmanaged
    {
<#
    foreach (var (keyword, name) in types)
    {
#>
        if (Unsafe.SizeOf<T>() == sizeof(<#= keyword #>))
        {
<#
        for (int i = intrinsics.Length - 1; i >= 0; i--)
        {
            var size = intrinsics[i].size;
#>
            if (Vec<#= size #><#= name #>.IsSupported)
            {
                count = Vec<#= size #><#= name #>.Count;
                return true;
            }
<#
        }
#>
        }
<#
    }
#>
        count = 0;
        return false;
    }
}

/// <summary>Generic type wrapping a byte vector.</summary>
internal interface ISimdVector<T, TVector>
    where T : unmanaged, IBinaryInteger<T>
    where TVector : struct, ISimdVector<T, TVector>
{
    static abstract bool IsSupported { get; }
    static abstract int Count { get; }
    static abstract TVector Zero { get; }
    static abstract TVector Equals(TVector left, TVector right);
    static abstract TVector Create(T value);
    static abstract TVector LoadUnsafe(ref readonly T source, nuint offset);
    static abstract TVector Or(TVector left, TVector right);
    static abstract bool operator ==(TVector left, TVector right);
    static abstract bool operator !=(TVector left, TVector right);
    [JetBrains.Annotations.Pure] nuint ExtractMostSignificantBits();
}
<#
    foreach (var (keyword, name) in types)
        foreach (var (size, isa) in intrinsics)
        {
            string typeName = $"Vec{size}{name}";
#>

internal readonly struct <#= typeName #> : ISimdVector<<#= keyword #>, <#= typeName #>>
{
    private readonly Vector<#= size #><byte> _value;

    public static bool IsSupported
    {
        [<#= MethodImpl #>]
        get
            => Vector<#= size #><byte>.IsSupported
#if <#= PragmaCondition #>
            && Vector<#= size#>.IsHardwareAccelerated
#endif
        ;
    }

    public static int Count
    {
        [<#= MethodImpl #>]
        get => Vector<#= size #><byte>.Count;
    }

    public static <#= typeName #> Zero
    {
        [<#= MethodImpl #>]
        get => Vector<#= size #><byte>.Zero;
    }

    [<#= MethodImpl #>]
    public static <#= typeName #> Equals(<#= typeName #> left, <#= typeName #> right) => Vector<#= size #>.Equals(left._value, right._value);

    [<#= MethodImpl #>]
    public static <#= typeName #> Create(<#= keyword #> value) => Vector<#= size #>.Create(<#
            Write(keyword != "byte" ? "unchecked((byte)value)" : "value");
#>);

    [<#= MethodImpl #>]
    public static <#= typeName #> LoadUnsafe(ref readonly <#= keyword #> source, nuint offset)<#
            if (keyword == "byte")
            {
                Write(" => Vector");
                Write(size);
                Write(".LoadUnsafe(in source, offset);");
            }
            else if (size is "64" or "128" or "256" or "512")
            {
#>

    {
        ref byte asByte = ref Unsafe.As<char, byte>(ref Unsafe.Add(ref Unsafe.AsRef(in source), offset));
        var v0 = Unsafe.ReadUnaligned<Vector<#= size #><ushort>>(ref asByte);
        var v1 = Unsafe.ReadUnaligned<Vector<#= size #><ushort>>(ref Unsafe.Add(ref asByte, Vector<#= size #><byte>.Count));
        var maxAscii = Vector<#= size #>.Create((ushort)127);
        var lower = Vector<#= size #>.Min(v0, maxAscii);
        var upper = Vector<#= size #>.Min(v1, maxAscii);
        return Vector<#= size #>.Narrow(lower, upper);
    }<#
            }
            else
            {
                Write(" => throw new NotImplementedException();");
            }
#>


    [<#= MethodImpl #>]
    public static <#= typeName #> Or(<#= typeName #> left, <#= typeName #> right) => Vector<#= size #>.BitwiseOr(left._value, right._value);

    [<#= MethodImpl #>]
    public nuint ExtractMostSignificantBits() => (nuint)_value.ExtractMostSignificantBits();
<#
            // if (isa.Length == 0)
            // {
            //     WriteLine("(nuint)_value.ExtractMostSignificantBits();");
            // }
            // else
            // {
            //     WriteLine("");
            //
            //     for (var index = isa.Length - 1; index >= 0; index--)
            //     {
            //         var instructionSet = isa[index];
            //         Write("        ");
            //         Write(instructionSet);
            //         Write(".IsSupported ? (nuint)");
            //         Write(instructionSet);
            //         WriteLine(".MoveMask(_value) : ");
            //     }
            //     WriteLine("        (nuint)_value.ExtractMostSignificantBits();");
            // }
#>

    [<#= MethodImpl #>]
    public static bool operator ==(<#= typeName #> left, <#= typeName #> right) => left._value == right._value;

    [<#= MethodImpl #>]
    public static bool operator !=(<#= typeName #> left, <#= typeName #> right) => left._value != right._value;

    [<#= MethodImpl #>]
    public static implicit operator <#= typeName #>(Vector<#= size #><byte> value) => Unsafe.As<Vector<#= size #><byte>, <#= typeName #>>(ref value);

    public override string ToString() => _value.ToString();
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}
<#
        }
#>

internal readonly struct NoOpVector<T> : ISimdVector<T, NoOpVector<T>> where T : unmanaged, IBinaryInteger<T>
{
    public static bool IsSupported => false;
    public static int Count => 0;
    public static NoOpVector<T> Zero => throw new NotSupportedException();
    public static NoOpVector<T> Equals(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public static NoOpVector<T> Create(T value) => throw new NotSupportedException();
    public static NoOpVector<T> LoadUnsafe(ref readonly T source, nuint offset) => throw new NotSupportedException();
    public static NoOpVector<T> Or(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public nuint ExtractMostSignificantBits() => throw new NotSupportedException();
    public static bool operator ==(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public static bool operator !=(NoOpVector<T> left, NoOpVector<T> right) => throw new NotSupportedException();
    public override string ToString() => "NoOpVector";
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

