// <auto-generated/>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Numerics;
using FlameCsv.Fuzzing.Utilities;

namespace FlameCsv.Fuzzing.Utilities;

#nullable enable
internal sealed class BoundedMemoryPool<T>(PoisonPagePlacement placement = PoisonPagePlacement.After)
    : MemoryPool<T> where T : unmanaged
{
    public override int MaxBufferSize => 4096 * 2;

    public override IMemoryOwner<T> Rent(int minBufferSize = -1)
    {
        if (minBufferSize == -1) minBufferSize = 256;
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(minBufferSize);
        return PooledBoundedMemory<T>.Rent((int)BitOperations.RoundUpToPowerOf2((uint)minBufferSize), placement);
    }

    protected override void Dispose(bool disposing)
    {
    }
}

internal sealed class PooledBoundedMemory<T> : IMemoryOwner<T> where T : unmanaged
{
    // Default libFuzzer max_len for inputs is 4096.
    private const int MaxLength = 4096 * 2;

    private static readonly PooledBoundedMemory<T>?[] s_memoryWithPoisonBefore = new PooledBoundedMemory<T>?[MaxLength + 1];
    private static readonly PooledBoundedMemory<T>?[] s_memoryWithPoisonAfter = new PooledBoundedMemory<T>?[MaxLength + 1];

    private readonly BoundedMemory<T> _memory;
    private readonly PooledBoundedMemory<T>?[]? _pool;

    private PooledBoundedMemory(PooledBoundedMemory<T>?[]? pool, int elementCount, PoisonPagePlacement placement)
    {
        _pool = pool;
        _memory = BoundedMemory.Allocate<T>(elementCount, placement);
    }

    public BoundedMemory<T> InnerMemory => _memory;
    public Memory<T> Memory => _memory.Memory;
    public Span<T> Span => _memory.Span;

    public void Dispose()
    {
        if (_pool is null ||
            Interlocked.CompareExchange(ref _pool[_memory.Length], this, null) is not null)
        {
            _memory.Dispose();
        }
    }

    public static PooledBoundedMemory<T> Rent(int elementCount, PoisonPagePlacement placement)
    {
        if ((uint)elementCount >= MaxLength)
        {
            return new PooledBoundedMemory<T>(null, elementCount, placement);
        }

        PooledBoundedMemory<T>?[] pool = placement switch
        {
            PoisonPagePlacement.Before => s_memoryWithPoisonBefore,
            PoisonPagePlacement.After => s_memoryWithPoisonAfter,
            _ => throw new ArgumentOutOfRangeException(nameof(placement))
        };

        return
            Interlocked.Exchange(ref pool[elementCount], null) ??
            new PooledBoundedMemory<T>(pool, elementCount, placement);
    }

    public static PooledBoundedMemory<T> Rent(ReadOnlySpan<T> data, PoisonPagePlacement placement)
    {
        PooledBoundedMemory<T> memory = Rent(data.Length, placement);
        data.CopyTo(memory.Span);
        return memory;
    }
}
