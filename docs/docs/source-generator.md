---
uid: source-generator
---

# Source Generator

## Foreword

_There is nothing inherently bad about reflection and compiled expressions._

For 99% of applications, they work perfectly and are straightforward to set up with minimal configuration.
However, reflection and compiled expressions are incompatible with AOT compilation and trimming, so an alternative API is provided.
Aside from the start-up cost, performance differences between reflection and source generation in FlameCsv are not significant (see: [benchmarks](benchmarks.md)).

## Introduction

FlameCsv includes a source generator that creates code for binding .NET types to/from CSV headers.
This enables writing [trimmable code](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained)
without any reflection or dynamic code generation â€” a necessity for [Native AOT](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot) applications.

To use the source generator, create a `partial class` and apply @"FlameCsv.Attributes.CsvTypeMapAttribute`2":

# [UTF-16](#tab/utf16)
```cs
[CsvTypeMap<char, User>]
partial class UserTypeMap;

// example usage
IEnumerable<User> users = CsvReader.Read(csv, UserTypeMap.Default);
```

# [UTF-8](#tab/utf8)
```cs
[CsvTypeMap<byte, User>]
partial class UserTypeMap;

// example usage
IEnumerable<User> users = CsvReader.Read(csv, UserTypeMap.Default);
```

---

The source generator implements @"FlameCsv.Binding.CsvTypeMap`2" on the target type, and generates a static
`Default`-property that can be used to get a thread-safe singleton instance of the type map.

Source generation offers many advantages, such as improved performance due to no reflection and improved JIT
optimization, and easier development as you can debug the code as if you wrote it yourself. On the other hand, while great care has
been given to the performance of the incremental source generator to keep the impact as small as possible,
it still has _some_ effect on compile-times and CPU use during development.

## Configuration

The source generator uses [attribute configuration](attributes.md) to determine the generated code.
All features of the reflection-based API are supported.

The code generation can be configured with these properties on @"FlameCsv.Attributes.CsvTypeMapAttribute`2":

 - @"FlameCsv.Attributes.CsvTypeMapAttribute`2.IgnoreUnmatched": Allows unmatched CSV headers to be ignored when reading. Useful when you only need a subset of fields, e.g., reading 3rd party data with unwanted metadata.
 - @"FlameCsv.Attributes.CsvTypeMapAttribute`2.ThrowOnDuplicate": Configures the typemap to throw if the same member is matched multiple times. This can happen with duplicate headers or when using [header aliases](attributes.md#header-names).
 - @"FlameCsv.Attributes.CsvTypeMapAttribute`2.NoCaching": Disables internal caching. By default, bindings with the same typemap and options instances are cached since they produce identical output. The caching is lightweight, and uses weak references and periodic trimming.
 - @"FlameCsv.Attributes.CsvTypeMapAttribute`2.SupportsAssemblyAttributes": Configures the source generator to scan the assembly for configuration attributes. By default, only attributes directly on the type and its members are scanned.

# [UTF-16](#tab/utf16)
```cs
[CsvTypeMap<char, User>(SupportsAssemblyAttributes = true)]
partial class UserTypeMap;
```

# [UTF-8](#tab/utf8)
```cs
[CsvTypeMap<byte, User>(SupportsAssemblyAttributes = true)]
partial class UserTypeMap;
```

---

> [!NOTE]
> These properties on the attribute affect only the generated `Default` instance. If you create a typemap manually with `new()`,
> you need to configure it separately.

## Limitations

Due to how generic constraints and @"FlameCsv.CsvConverterFactory`1" work, converter factories are not supported by the source generator.
However, since the type is known at compile time, you can add the required converters explicitly beforehand.

## Example

Below is an example of the code generated by the source generator at the time of writing. The actual generated code may differ in later versions:

# [UTF-16](#tab/utf16)
```cs
class User : IActive
{
    [CsvHeader("id", "user_id")]
    public int Id { get; set; }

    [CsvOrder(999)]
    public string? Name { get; set; }

    public bool IsAdmin { get; set; }

    [CsvRequired]
    bool IActive.IsActive { get; set; }
}

interface IActive
{
    bool IsActive { get; set; }
}

[CsvTypeMap<char, User>]
partial class UserTypeMap;
```

# [UTF-8](#tab/utf8)
```cs
class User : IActive
{
    [CsvHeader("id", "user_id")]
    public int Id { get; set; }

    [CsvOrder(999)]
    public string? Name { get; set; }

    public bool IsAdmin { get; set; }

    [CsvRequired]
    bool IActive.IsActive { get; set; }
}

interface IActive
{
    bool IsActive { get; set; }
}

[CsvTypeMap<byte, User>]
partial class UserTypeMap;
```

---

# [UTF-16](#tab/utf16)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>

// <global namespace>

partial class UserTypeMap : global::FlameCsv.Binding.CsvTypeMap<char, global::User>
{
    /// <summary>
    /// Returns a thread-safe instance of the typemap with default options.
    /// </summary>
    /// <remarks>
    /// Unmatched headers cause an exception.<br/>
    /// Duplicate headers are ignored.<br/>
    /// De/materializer caching is enabled.
    /// </remarks>
    public static global::UserTypeMap Default { get; } = new global::UserTypeMap()
    {
        IgnoreUnmatched = false,
        ThrowOnDuplicate = false,
        NoCaching = false,
    };

    private const int @s__Id_IActive_IsActive = 1;
    private const int @s__Id_Id = 2;
    private const int @s__Id_IsAdmin = 3;
    private const int @s__Id_Name = 4;
    private const int @s__MinId = 1;
    private const int @s__MaxId = 4;

    protected override global::FlameCsv.Reading.IMaterializer<char, global::User> BindForReading(scoped global::System.ReadOnlySpan<string> headers, global::FlameCsv.CsvOptions<char> options)
    {
        TypeMapMaterializer materializer = new TypeMapMaterializer(headers.Length);

        global::System.Collections.Generic.IEqualityComparer<string> comparer = options.Comparer;

        for (int index = 0; index < headers.Length; index++)
        {
            string name = headers[index];


            if ((materializer.@s__Converter_IActive_IsActive is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsActive"))
            {
                if (materializer.@s__Converter_IActive_IsActive is null)
                {
                    materializer.@s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IActive_IsActive;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsActive", name, headers);
                }
            }

            if ((materializer.@s__Converter_Id is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "user_id"))
            {
                if (materializer.@s__Converter_Id is null)
                {
                    materializer.@s__Converter_Id = options.Aot.GetConverter<int>();
                    materializer.Targets[index] = @s__Id_Id;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Id", name, headers);
                }
            }

            if ((materializer.@s__Converter_IsAdmin is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsAdmin"))
            {
                if (materializer.@s__Converter_IsAdmin is null)
                {
                    materializer.@s__Converter_IsAdmin = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IsAdmin;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsAdmin", name, headers);
                }
            }

            if ((materializer.@s__Converter_Name is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "Name")) // Explicit order: 999
            {
                if (materializer.@s__Converter_Name is null)
                {
                    materializer.@s__Converter_Name = options.Aot.GetConverter<string>();
                    materializer.Targets[index] = @s__Id_Name;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Name", name, headers);
                }
            }

            if (this.IgnoreUnmatched)
            {
                materializer.Targets[index] = -1;
            }
            else
            {
                base.ThrowUnmatched(name, index);
            }
        }

        if (!global::System.MemoryExtensions.ContainsAnyInRange(materializer.Targets, @s__MinId, @s__MaxId))
        {
            base.ThrowNoFieldsBound(headers);
        }
        if (materializer.@s__Converter_IActive_IsActive is null)
        {
            base.ThrowRequiredNotRead(GetMissingRequiredFields(materializer), headers);
        }

        return materializer;
    }

    protected override global::FlameCsv.Reading.IMaterializer<char, global::User> BindForReading(global::FlameCsv.CsvOptions<char> options)
    {
        throw new global::System.NotSupportedException("Index binding is not yet supported for the source generator.");
    }

    private static System.Collections.Generic.IEnumerable<string> GetMissingRequiredFields(TypeMapMaterializer materializer)
    {
        if (materializer.@s__Converter_IActive_IsActive is null) yield return "IActive_IsActive";
    }

    private struct ParseState
    {
        public bool IActive_IsActive;
        public int Id;
        public bool IsAdmin;
        public string Name;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class TypeMapMaterializer : global::FlameCsv.Reading.IMaterializer<char, global::User>
    {
        public global::FlameCsv.CsvConverter<char, bool> @s__Converter_IActive_IsActive;
        public global::FlameCsv.CsvConverter<char, int> @s__Converter_Id;
        public global::FlameCsv.CsvConverter<char, bool> @s__Converter_IsAdmin;
        public global::FlameCsv.CsvConverter<char, string> @s__Converter_Name;

        public readonly int[] Targets;

        public TypeMapMaterializer(int length)
        {
            Targets = new int[length];
        }

        public global::User Parse<TReader>(ref TReader reader) where TReader : global::FlameCsv.Reading.ICsvRecordFields<char>, allows ref struct
        {
            int[] targets = Targets;

            if (targets.Length != reader.FieldCount)
            {
                global::FlameCsv.Exceptions.CsvReadException.ThrowForInvalidFieldCount(expected: targets.Length, actual: reader.FieldCount);
            }

#if RELEASE
            global::System.Runtime.CompilerServices.Unsafe.SkipInit(out ParseState state);
#else
            ParseState state = default;
#endif
            for (int target = 0; target < targets.Length; target++)
            {
                global::System.ReadOnlySpan<char> @field = reader[target];

                bool result = targets[target] switch
                {
                    @s__Id_IActive_IsActive => @s__Converter_IActive_IsActive.TryParse(@field, out state.IActive_IsActive),
                    @s__Id_Id => @s__Converter_Id.TryParse(@field, out state.Id),
                    @s__Id_IsAdmin => @s__Converter_IsAdmin.TryParse(@field, out state.IsAdmin),
                    @s__Id_Name => @s__Converter_Name.TryParse(@field, out state.Name),
                    0 => ThrowForInvalidTarget(target), // Should never happen
                    _ => true, // Ignored fields have target set to -1
                };

                if (!result)
                {
                    ThrowForFailedParse(@field, target);
                }
            }

            // Required fields are guaranteed to be non-null.
            // Optional fields are null-checked to only write a value when one was read.
            global::User obj = new global::User();
            if (@s__Converter_Name is not null) obj.Name = state.Name;
            if (@s__Converter_Id is not null) obj.Id = state.Id;
            if (@s__Converter_IsAdmin is not null) obj.IsAdmin = state.IsAdmin;
            ((global::IActive)obj).IsActive = state.IActive_IsActive;
            return obj;
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private static bool ThrowForInvalidTarget(int target) => throw new global::System.Diagnostics.UnreachableException($"Converter {target} was uninitialized");

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void ThrowForFailedParse(scoped global::System.ReadOnlySpan<char> field, int target)
        {
            if (target == @s__Id_IActive_IsActive) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IActive_IsActive, "IsActive");
            if (target == @s__Id_Id) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Id, "Id");
            if (target == @s__Id_IsAdmin) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IsAdmin, "IsAdmin");
            if (target == @s__Id_Name) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Name, "Name");
            throw new global::System.Diagnostics.UnreachableException("Invalid target: " + target.ToString());
        }
    }

    protected override global::FlameCsv.Writing.IDematerializer<char, global::User> BindForWriting(global::FlameCsv.CsvOptions<char> options)
    {
        return new Dematerializer
        {
            @s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>(),
            @s__Converter_Id = options.Aot.GetConverter<int>(),
            @s__Converter_IsAdmin = options.Aot.GetConverter<bool>(),
            @s__Converter_Name = options.Aot.GetConverter<string>(),
        };
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class Dematerializer : global::FlameCsv.Writing.IDematerializer<char, global::User>
    {
        public int FieldCount => 4;

        public required global::FlameCsv.CsvConverter<char, bool> @s__Converter_IActive_IsActive { get; init; }
        public required global::FlameCsv.CsvConverter<char, int> @s__Converter_Id { get; init; }
        public required global::FlameCsv.CsvConverter<char, bool> @s__Converter_IsAdmin { get; init; }
        public required global::FlameCsv.CsvConverter<char, string> @s__Converter_Name { get; init; }

        public void Write(ref readonly global::FlameCsv.Writing.CsvFieldWriter<char> writer, global::User obj)
        {
            writer.WriteField(@s__Converter_IActive_IsActive, ((global::IActive)obj).IsActive);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Id, obj.Id);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_IsAdmin, obj.IsAdmin);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Name, obj.Name);
        }

        public void WriteHeader(ref readonly global::FlameCsv.Writing.CsvFieldWriter<char> writer)
        {
            writer.WriteRaw("IsActive");
            writer.WriteDelimiter();
            writer.WriteRaw("id");
            writer.WriteDelimiter();
            writer.WriteRaw("IsAdmin");
            writer.WriteDelimiter();
            writer.WriteRaw("Name");
        }
    }
}
```

# [UTF-8](#tab/utf8)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>

// <global namespace>

partial class UserTypeMap : global::FlameCsv.Binding.CsvTypeMap<byte, global::User>
{
    /// <summary>
    /// Returns a thread-safe instance of the typemap with default options.
    /// </summary>
    /// <remarks>
    /// Unmatched headers cause an exception.<br/>
    /// Duplicate headers are ignored.<br/>
    /// De/materializer caching is enabled.
    /// </remarks>
    public static global::UserTypeMap Default { get; } = new global::UserTypeMap()
    {
        IgnoreUnmatched = false,
        ThrowOnDuplicate = false,
        NoCaching = false,
    };

    private const int @s__Id_IActive_IsActive = 1;
    private const int @s__Id_Id = 2;
    private const int @s__Id_IsAdmin = 3;
    private const int @s__Id_Name = 4;
    private const int @s__MinId = 1;
    private const int @s__MaxId = 4;

    protected override global::FlameCsv.Reading.IMaterializer<byte, global::User> BindForReading(scoped global::System.ReadOnlySpan<string> headers, global::FlameCsv.CsvOptions<byte> options)
    {
        TypeMapMaterializer materializer = new TypeMapMaterializer(headers.Length);

        global::System.Collections.Generic.IEqualityComparer<string> comparer = options.Comparer;

        for (int index = 0; index < headers.Length; index++)
        {
            string name = headers[index];


            if ((materializer.@s__Converter_IActive_IsActive is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsActive"))
            {
                if (materializer.@s__Converter_IActive_IsActive is null)
                {
                    materializer.@s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IActive_IsActive;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsActive", name, headers);
                }
            }

            if ((materializer.@s__Converter_Id is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "user_id"))
            {
                if (materializer.@s__Converter_Id is null)
                {
                    materializer.@s__Converter_Id = options.Aot.GetConverter<int>();
                    materializer.Targets[index] = @s__Id_Id;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Id", name, headers);
                }
            }

            if ((materializer.@s__Converter_IsAdmin is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsAdmin"))
            {
                if (materializer.@s__Converter_IsAdmin is null)
                {
                    materializer.@s__Converter_IsAdmin = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IsAdmin;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsAdmin", name, headers);
                }
            }

            if ((materializer.@s__Converter_Name is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "Name")) // Explicit order: 999
            {
                if (materializer.@s__Converter_Name is null)
                {
                    materializer.@s__Converter_Name = options.Aot.GetConverter<string>();
                    materializer.Targets[index] = @s__Id_Name;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Name", name, headers);
                }
            }

            if (this.IgnoreUnmatched)
            {
                materializer.Targets[index] = -1;
            }
            else
            {
                base.ThrowUnmatched(name, index);
            }
        }

        if (!global::System.MemoryExtensions.ContainsAnyInRange(materializer.Targets, @s__MinId, @s__MaxId))
        {
            base.ThrowNoFieldsBound(headers);
        }
        if (materializer.@s__Converter_IActive_IsActive is null)
        {
            base.ThrowRequiredNotRead(GetMissingRequiredFields(materializer), headers);
        }

        return materializer;
    }

    protected override global::FlameCsv.Reading.IMaterializer<byte, global::User> BindForReading(global::FlameCsv.CsvOptions<byte> options)
    {
        throw new global::System.NotSupportedException("Index binding is not yet supported for the source generator.");
    }

    private static System.Collections.Generic.IEnumerable<string> GetMissingRequiredFields(TypeMapMaterializer materializer)
    {
        if (materializer.@s__Converter_IActive_IsActive is null) yield return "IActive_IsActive";
    }

    private struct ParseState
    {
        public bool IActive_IsActive;
        public int Id;
        public bool IsAdmin;
        public string Name;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class TypeMapMaterializer : global::FlameCsv.Reading.IMaterializer<byte, global::User>
    {
        public global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IActive_IsActive;
        public global::FlameCsv.CsvConverter<byte, int> @s__Converter_Id;
        public global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IsAdmin;
        public global::FlameCsv.CsvConverter<byte, string> @s__Converter_Name;

        public readonly int[] Targets;

        public TypeMapMaterializer(int length)
        {
            Targets = new int[length];
        }

        public global::User Parse<TReader>(ref TReader reader) where TReader : global::FlameCsv.Reading.ICsvRecordFields<byte>, allows ref struct
        {
            int[] targets = Targets;

            if (targets.Length != reader.FieldCount)
            {
                global::FlameCsv.Exceptions.CsvReadException.ThrowForInvalidFieldCount(expected: targets.Length, actual: reader.FieldCount);
            }

#if RELEASE
            global::System.Runtime.CompilerServices.Unsafe.SkipInit(out ParseState state);
#else
            ParseState state = default;
#endif
            for (int target = 0; target < targets.Length; target++)
            {
                global::System.ReadOnlySpan<byte> @field = reader[target];

                bool result = targets[target] switch
                {
                    @s__Id_IActive_IsActive => @s__Converter_IActive_IsActive.TryParse(@field, out state.IActive_IsActive),
                    @s__Id_Id => @s__Converter_Id.TryParse(@field, out state.Id),
                    @s__Id_IsAdmin => @s__Converter_IsAdmin.TryParse(@field, out state.IsAdmin),
                    @s__Id_Name => @s__Converter_Name.TryParse(@field, out state.Name),
                    0 => ThrowForInvalidTarget(target), // Should never happen
                    _ => true, // Ignored fields have target set to -1
                };

                if (!result)
                {
                    ThrowForFailedParse(@field, target);
                }
            }

            // Required fields are guaranteed to be non-null.
            // Optional fields are null-checked to only write a value when one was read.
            global::User obj = new global::User();
            if (@s__Converter_Name is not null) obj.Name = state.Name;
            if (@s__Converter_Id is not null) obj.Id = state.Id;
            if (@s__Converter_IsAdmin is not null) obj.IsAdmin = state.IsAdmin;
            ((global::IActive)obj).IsActive = state.IActive_IsActive;
            return obj;
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private static bool ThrowForInvalidTarget(int target) => throw new global::System.Diagnostics.UnreachableException($"Converter {target} was uninitialized");

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void ThrowForFailedParse(scoped global::System.ReadOnlySpan<byte> field, int target)
        {
            if (target == @s__Id_IActive_IsActive) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IActive_IsActive, "IsActive");
            if (target == @s__Id_Id) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Id, "Id");
            if (target == @s__Id_IsAdmin) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IsAdmin, "IsAdmin");
            if (target == @s__Id_Name) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Name, "Name");
            throw new global::System.Diagnostics.UnreachableException("Invalid target: " + target.ToString());
        }
    }

    protected override global::FlameCsv.Writing.IDematerializer<byte, global::User> BindForWriting(global::FlameCsv.CsvOptions<byte> options)
    {
        return new Dematerializer
        {
            @s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>(),
            @s__Converter_Id = options.Aot.GetConverter<int>(),
            @s__Converter_IsAdmin = options.Aot.GetConverter<bool>(),
            @s__Converter_Name = options.Aot.GetConverter<string>(),
        };
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class Dematerializer : global::FlameCsv.Writing.IDematerializer<byte, global::User>
    {
        public int FieldCount => 4;

        public required global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IActive_IsActive { get; init; }
        public required global::FlameCsv.CsvConverter<byte, int> @s__Converter_Id { get; init; }
        public required global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IsAdmin { get; init; }
        public required global::FlameCsv.CsvConverter<byte, string> @s__Converter_Name { get; init; }

        public void Write(ref readonly global::FlameCsv.Writing.CsvFieldWriter<byte> writer, global::User obj)
        {
            writer.WriteField(@s__Converter_IActive_IsActive, ((global::IActive)obj).IsActive);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Id, obj.Id);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_IsAdmin, obj.IsAdmin);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Name, obj.Name);
        }

        public void WriteHeader(ref readonly global::FlameCsv.Writing.CsvFieldWriter<byte> writer)
        {
            writer.WriteRaw("IsActive"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("id"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("IsAdmin"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("Name"u8);
        }
    }
}
```

---
