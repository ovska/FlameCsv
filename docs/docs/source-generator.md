---
uid: source-generator
---

# Source Generator

## Foreword

For 99% of applications, reflection works perfectly and is straightforward to set up with minimal configuration.
However, reflection and compiled expressions are incompatible with AOT compilation, trimming, and platforms without JIT.

The performance differences between reflection and source generation in FlameCsv are extremely small, and you should pick
the approach that best fits your application's needs.

The source-generated [enum converter](#enum-converter-generator) however is significantly faster than `Enum.TryParse` and `TryFormat`,
especially when reading UTF-8 (bytes). For more details, see the [benchmarks](benchmarks.md#enums).

All source generators in FlameCSV are implemented as low-footprint incremental generators, and they include diagnostics
for common pitfalls and configuration problems.

## Type Map Generator

FlameCsv includes a source generator that creates code for binding .NET types to/from CSV headers.
This enables writing [trimmable code](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained)
without any reflection or dynamic code generation â€” a necessity for [Native AOT](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot) applications.

To use the source generator, create a `partial class` and apply @"FlameCsv.Attributes.CsvTypeMapAttribute`2". The source generator
will inherit from @"FlameCsv.Binding.CsvTypeMap`2" and generate the required code based on the attributes on the target type,
including a static property to get a thread-safe singleton instance of the type map.

```cs
[CsvTypeMap<char, User>]
partial class UserTypeMap;

// example usage
IEnumerable<User> users = CsvReader.Read(csv, UserTypeMap.Default);
```

The source generator has lower startup overhead than reflection, and allows debugging the code as if you wrote it yourself.
All configuration is done via the options as normal.

### Limitations

Due to how generic constraints and @"FlameCsv.CsvConverterFactory`1" work, converter factories are not supported by the source generator.
However, since the types are known at compile time, you can add the required converters explicitly beforehand, e.g.: `[CsvConverter<char, MyListConverter>]`.

### Example

```cs
class User : IActive
{
    [CsvHeader("id", "user_id")]
    public int Id { get; set; }

    [CsvOrder(999)]
    public string? Name { get; set; }

    public bool IsAdmin { get; set; }

    [CsvRequired]
    bool IActive.IsActive { get; set; }
}

interface IActive
{
    bool IsActive { get; set; }
}

[CsvTypeMap<char, User>]
partial class UserTypeMap;
```

# [UTF-16](#tab/utf16)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>

// <global namespace>

partial class UserTypeMap : global::FlameCsv.Binding.CsvTypeMap<char, global::User>
{
    /// <summary>
    /// Returns a thread-safe instance of the typemap with default options.
    /// </summary>
    /// <remarks>
    /// Unmatched headers cause an exception.<br/>
    /// Duplicate headers are ignored.<br/>
    /// De/materializer caching is enabled.
    /// </remarks>
    public static global::UserTypeMap Default { get; } = new global::UserTypeMap()
    {
        IgnoreUnmatched = false,
        ThrowOnDuplicate = false,
    };

    private const int @s__Id_IActive_IsActive = 1;
    private const int @s__Id_Id = 2;
    private const int @s__Id_IsAdmin = 3;
    private const int @s__Id_Name = 4;
    private const int @s__MinId = 1;
    private const int @s__MaxId = 4;

    protected override global::FlameCsv.Reading.IMaterializer<char, global::User> BindForReading(scoped global::System.ReadOnlySpan<string> headers, global::FlameCsv.CsvOptions<char> options)
    {
        TypeMapMaterializer materializer = new TypeMapMaterializer(headers.Length);

        global::System.Collections.Generic.IEqualityComparer<string> comparer = options.Comparer;

        for (int index = 0; index < headers.Length; index++)
        {
            string name = headers[index];


            if ((materializer.@s__Converter_IActive_IsActive is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsActive"))
            {
                if (materializer.@s__Converter_IActive_IsActive is null)
                {
                    materializer.@s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IActive_IsActive;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsActive", name, headers);
                }
            }

            if ((materializer.@s__Converter_Id is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "user_id"))
            {
                if (materializer.@s__Converter_Id is null)
                {
                    materializer.@s__Converter_Id = options.Aot.GetConverter<int>();
                    materializer.Targets[index] = @s__Id_Id;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Id", name, headers);
                }
            }

            if ((materializer.@s__Converter_IsAdmin is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsAdmin"))
            {
                if (materializer.@s__Converter_IsAdmin is null)
                {
                    materializer.@s__Converter_IsAdmin = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IsAdmin;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsAdmin", name, headers);
                }
            }

            if ((materializer.@s__Converter_Name is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "Name")) // Explicit order: 999
            {
                if (materializer.@s__Converter_Name is null)
                {
                    materializer.@s__Converter_Name = options.Aot.GetConverter<string>();
                    materializer.Targets[index] = @s__Id_Name;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Name", name, headers);
                }
            }

            if (this.IgnoreUnmatched)
            {
                materializer.Targets[index] = -1;
            }
            else
            {
                base.ThrowUnmatched(name, index);
            }
        }

        if (!global::System.MemoryExtensions.ContainsAnyInRange(materializer.Targets, @s__MinId, @s__MaxId))
        {
            base.ThrowNoFieldsBound(headers);
        }
        if (materializer.@s__Converter_IActive_IsActive is null)
        {
            base.ThrowRequiredNotRead(GetMissingRequiredFields(materializer), headers);
        }

        return materializer;
    }

    protected override global::FlameCsv.Reading.IMaterializer<char, global::User> BindForReading(global::FlameCsv.CsvOptions<char> options)
    {
        throw new global::System.NotSupportedException("Index binding is not yet supported for the source generator.");
    }

    private static System.Collections.Generic.IEnumerable<string> GetMissingRequiredFields(TypeMapMaterializer materializer)
    {
        if (materializer.@s__Converter_IActive_IsActive is null) yield return "IActive_IsActive";
    }

    private struct ParseState
    {
        public bool IActive_IsActive;
        public int Id;
        public bool IsAdmin;
        public string Name;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class TypeMapMaterializer : global::FlameCsv.Reading.IMaterializer<char, global::User>
    {
        public global::FlameCsv.CsvConverter<char, bool> @s__Converter_IActive_IsActive;
        public global::FlameCsv.CsvConverter<char, int> @s__Converter_Id;
        public global::FlameCsv.CsvConverter<char, bool> @s__Converter_IsAdmin;
        public global::FlameCsv.CsvConverter<char, string> @s__Converter_Name;

        public readonly int[] Targets;

        public TypeMapMaterializer(int length)
        {
            Targets = new int[length];
        }

        public global::User Parse<TReader>(ref TReader reader) where TReader : global::FlameCsv.Reading.ICsvRecordFields<char>, allows ref struct
        {
            int[] targets = Targets;

            if (targets.Length != reader.FieldCount)
            {
                global::FlameCsv.Exceptions.CsvReadException.ThrowForInvalidFieldCount(expected: targets.Length, actual: reader.FieldCount);
            }

#if RELEASE
            global::System.Runtime.CompilerServices.Unsafe.SkipInit(out ParseState state);
#else
            ParseState state = default;
#endif
            for (int target = 0; target < targets.Length; target++)
            {
                global::System.ReadOnlySpan<char> @field = reader[target];

                bool result = targets[target] switch
                {
                    @s__Id_IActive_IsActive => @s__Converter_IActive_IsActive.TryParse(@field, out state.IActive_IsActive),
                    @s__Id_Id => @s__Converter_Id.TryParse(@field, out state.Id),
                    @s__Id_IsAdmin => @s__Converter_IsAdmin.TryParse(@field, out state.IsAdmin),
                    @s__Id_Name => @s__Converter_Name.TryParse(@field, out state.Name),
                    0 => ThrowForInvalidTarget(target), // Should never happen
                    _ => true, // Ignored fields have target set to -1
                };

                if (!result)
                {
                    ThrowForFailedParse(@field, target);
                }
            }

            // Required fields are guaranteed to be non-null.
            // Optional fields are null-checked to only write a value when one was read.
            global::User obj = new global::User();
            if (@s__Converter_Name is not null) obj.Name = state.Name;
            if (@s__Converter_Id is not null) obj.Id = state.Id;
            if (@s__Converter_IsAdmin is not null) obj.IsAdmin = state.IsAdmin;
            ((global::IActive)obj).IsActive = state.IActive_IsActive;
            return obj;
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private static bool ThrowForInvalidTarget(int target) => throw new global::System.Diagnostics.UnreachableException($"Converter {target} was uninitialized");

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void ThrowForFailedParse(scoped global::System.ReadOnlySpan<char> field, int target)
        {
            if (target == @s__Id_IActive_IsActive) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IActive_IsActive, "IsActive");
            if (target == @s__Id_Id) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Id, "Id");
            if (target == @s__Id_IsAdmin) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IsAdmin, "IsAdmin");
            if (target == @s__Id_Name) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Name, "Name");
            throw new global::System.Diagnostics.UnreachableException("Invalid target: " + target.ToString());
        }
    }

    protected override global::FlameCsv.Writing.IDematerializer<char, global::User> BindForWriting(global::FlameCsv.CsvOptions<char> options)
    {
        return new Dematerializer
        {
            @s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>(),
            @s__Converter_Id = options.Aot.GetConverter<int>(),
            @s__Converter_IsAdmin = options.Aot.GetConverter<bool>(),
            @s__Converter_Name = options.Aot.GetConverter<string>(),
        };
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class Dematerializer : global::FlameCsv.Writing.IDematerializer<char, global::User>
    {
        public int FieldCount => 4;

        public required global::FlameCsv.CsvConverter<char, bool> @s__Converter_IActive_IsActive { get; init; }
        public required global::FlameCsv.CsvConverter<char, int> @s__Converter_Id { get; init; }
        public required global::FlameCsv.CsvConverter<char, bool> @s__Converter_IsAdmin { get; init; }
        public required global::FlameCsv.CsvConverter<char, string> @s__Converter_Name { get; init; }

        public void Write(ref readonly global::FlameCsv.Writing.CsvFieldWriter<char> writer, global::User obj)
        {
            writer.WriteField(@s__Converter_IActive_IsActive, ((global::IActive)obj).IsActive);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Id, obj.Id);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_IsAdmin, obj.IsAdmin);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Name, obj.Name);
        }

        public void WriteHeader(ref readonly global::FlameCsv.Writing.CsvFieldWriter<char> writer)
        {
            writer.WriteRaw("IsActive");
            writer.WriteDelimiter();
            writer.WriteRaw("id");
            writer.WriteDelimiter();
            writer.WriteRaw("IsAdmin");
            writer.WriteDelimiter();
            writer.WriteRaw("Name");
        }
    }
}
```

# [UTF-8](#tab/utf8)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>

// <global namespace>

partial class UserTypeMap : global::FlameCsv.Binding.CsvTypeMap<byte, global::User>
{
    /// <summary>
    /// Returns a thread-safe instance of the typemap with default options.
    /// </summary>
    /// <remarks>
    /// Unmatched headers cause an exception.<br/>
    /// Duplicate headers are ignored.<br/>
    /// De/materializer caching is enabled.
    /// </remarks>
    public static global::UserTypeMap Default { get; } = new global::UserTypeMap()
    {
        IgnoreUnmatched = false,
        ThrowOnDuplicate = false,
    };

    private const int @s__Id_IActive_IsActive = 1;
    private const int @s__Id_Id = 2;
    private const int @s__Id_IsAdmin = 3;
    private const int @s__Id_Name = 4;
    private const int @s__MinId = 1;
    private const int @s__MaxId = 4;

    protected override global::FlameCsv.Reading.IMaterializer<byte, global::User> BindForReading(scoped global::System.ReadOnlySpan<string> headers, global::FlameCsv.CsvOptions<byte> options)
    {
        TypeMapMaterializer materializer = new TypeMapMaterializer(headers.Length);

        global::System.Collections.Generic.IEqualityComparer<string> comparer = options.Comparer;

        for (int index = 0; index < headers.Length; index++)
        {
            string name = headers[index];


            if ((materializer.@s__Converter_IActive_IsActive is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsActive"))
            {
                if (materializer.@s__Converter_IActive_IsActive is null)
                {
                    materializer.@s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IActive_IsActive;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsActive", name, headers);
                }
            }

            if ((materializer.@s__Converter_Id is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "user_id"))
            {
                if (materializer.@s__Converter_Id is null)
                {
                    materializer.@s__Converter_Id = options.Aot.GetConverter<int>();
                    materializer.Targets[index] = @s__Id_Id;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Id", name, headers);
                }
            }

            if ((materializer.@s__Converter_IsAdmin is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "IsAdmin"))
            {
                if (materializer.@s__Converter_IsAdmin is null)
                {
                    materializer.@s__Converter_IsAdmin = options.Aot.GetConverter<bool>();
                    materializer.Targets[index] = @s__Id_IsAdmin;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("IsAdmin", name, headers);
                }
            }

            if ((materializer.@s__Converter_Name is null || this.ThrowOnDuplicate) &&
                comparer.Equals(name, "Name")) // Explicit order: 999
            {
                if (materializer.@s__Converter_Name is null)
                {
                    materializer.@s__Converter_Name = options.Aot.GetConverter<string>();
                    materializer.Targets[index] = @s__Id_Name;
                    continue;
                }

                if (this.ThrowOnDuplicate)
                {
                    base.ThrowDuplicate("Name", name, headers);
                }
            }

            if (this.IgnoreUnmatched)
            {
                materializer.Targets[index] = -1;
            }
            else
            {
                base.ThrowUnmatched(name, index);
            }
        }

        if (!global::System.MemoryExtensions.ContainsAnyInRange(materializer.Targets, @s__MinId, @s__MaxId))
        {
            base.ThrowNoFieldsBound(headers);
        }
        if (materializer.@s__Converter_IActive_IsActive is null)
        {
            base.ThrowRequiredNotRead(GetMissingRequiredFields(materializer), headers);
        }

        return materializer;
    }

    protected override global::FlameCsv.Reading.IMaterializer<byte, global::User> BindForReading(global::FlameCsv.CsvOptions<byte> options)
    {
        throw new global::System.NotSupportedException("Index binding is not yet supported for the source generator.");
    }

    private static System.Collections.Generic.IEnumerable<string> GetMissingRequiredFields(TypeMapMaterializer materializer)
    {
        if (materializer.@s__Converter_IActive_IsActive is null) yield return "IActive_IsActive";
    }

    private struct ParseState
    {
        public bool IActive_IsActive;
        public int Id;
        public bool IsAdmin;
        public string Name;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class TypeMapMaterializer : global::FlameCsv.Reading.IMaterializer<byte, global::User>
    {
        public global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IActive_IsActive;
        public global::FlameCsv.CsvConverter<byte, int> @s__Converter_Id;
        public global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IsAdmin;
        public global::FlameCsv.CsvConverter<byte, string> @s__Converter_Name;

        public readonly int[] Targets;

        public TypeMapMaterializer(int length)
        {
            Targets = new int[length];
        }

        public global::User Parse<TReader>(ref TReader reader) where TReader : global::FlameCsv.Reading.ICsvRecordFields<byte>, allows ref struct
        {
            int[] targets = Targets;

            if (targets.Length != reader.FieldCount)
            {
                global::FlameCsv.Exceptions.CsvReadException.ThrowForInvalidFieldCount(expected: targets.Length, actual: reader.FieldCount);
            }

#if RELEASE
            global::System.Runtime.CompilerServices.Unsafe.SkipInit(out ParseState state);
#else
            ParseState state = default;
#endif
            for (int target = 0; target < targets.Length; target++)
            {
                global::System.ReadOnlySpan<byte> @field = reader[target];

                bool result = targets[target] switch
                {
                    @s__Id_IActive_IsActive => @s__Converter_IActive_IsActive.TryParse(@field, out state.IActive_IsActive),
                    @s__Id_Id => @s__Converter_Id.TryParse(@field, out state.Id),
                    @s__Id_IsAdmin => @s__Converter_IsAdmin.TryParse(@field, out state.IsAdmin),
                    @s__Id_Name => @s__Converter_Name.TryParse(@field, out state.Name),
                    0 => ThrowForInvalidTarget(target), // Should never happen
                    _ => true, // Ignored fields have target set to -1
                };

                if (!result)
                {
                    ThrowForFailedParse(@field, target);
                }
            }

            // Required fields are guaranteed to be non-null.
            // Optional fields are null-checked to only write a value when one was read.
            global::User obj = new global::User();
            if (@s__Converter_Name is not null) obj.Name = state.Name;
            if (@s__Converter_Id is not null) obj.Id = state.Id;
            if (@s__Converter_IsAdmin is not null) obj.IsAdmin = state.IsAdmin;
            ((global::IActive)obj).IsActive = state.IActive_IsActive;
            return obj;
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private static bool ThrowForInvalidTarget(int target) => throw new global::System.Diagnostics.UnreachableException($"Converter {target} was uninitialized");

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void ThrowForFailedParse(scoped global::System.ReadOnlySpan<byte> field, int target)
        {
            if (target == @s__Id_IActive_IsActive) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IActive_IsActive, "IsActive");
            if (target == @s__Id_Id) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Id, "Id");
            if (target == @s__Id_IsAdmin) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_IsAdmin, "IsAdmin");
            if (target == @s__Id_Name) global::FlameCsv.Exceptions.CsvParseException.Throw(@field, @s__Converter_Name, "Name");
            throw new global::System.Diagnostics.UnreachableException("Invalid target: " + target.ToString());
        }
    }

    protected override global::FlameCsv.Writing.IDematerializer<byte, global::User> BindForWriting(global::FlameCsv.CsvOptions<byte> options)
    {
        return new Dematerializer
        {
            @s__Converter_IActive_IsActive = options.Aot.GetConverter<bool>(),
            @s__Converter_Id = options.Aot.GetConverter<int>(),
            @s__Converter_IsAdmin = options.Aot.GetConverter<bool>(),
            @s__Converter_Name = options.Aot.GetConverter<string>(),
        };
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class Dematerializer : global::FlameCsv.Writing.IDematerializer<byte, global::User>
    {
        public int FieldCount => 4;

        public required global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IActive_IsActive { get; init; }
        public required global::FlameCsv.CsvConverter<byte, int> @s__Converter_Id { get; init; }
        public required global::FlameCsv.CsvConverter<byte, bool> @s__Converter_IsAdmin { get; init; }
        public required global::FlameCsv.CsvConverter<byte, string> @s__Converter_Name { get; init; }

        public void Write(ref readonly global::FlameCsv.Writing.CsvFieldWriter<byte> writer, global::User obj)
        {
            writer.WriteField(@s__Converter_IActive_IsActive, ((global::IActive)obj).IsActive);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Id, obj.Id);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_IsAdmin, obj.IsAdmin);
            writer.WriteDelimiter();
            writer.WriteField(@s__Converter_Name, obj.Name);
        }

        public void WriteHeader(ref readonly global::FlameCsv.Writing.CsvFieldWriter<byte> writer)
        {
            writer.WriteRaw("IsActive"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("id"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("IsAdmin"u8);
            writer.WriteDelimiter();
            writer.WriteRaw("Name"u8);
        }
    }
}
```

---

## Enum Converter Generator

@"FlameCsv.Attributes.CsvEnumConverterAttribute`2" can be used to generate extremely performant enum converters
that are essentially hyper-optimized hand-written implementations specific to the enum. The implementations
use @"System.Runtime.CompilerServices.Unsafe" and @"System.Runtime.InteropServices.MemoryMarshal" to avoid allocations and
optimize for performance.

Simply apply the attribute to a `partial class`. The generated converter supports parsing and formatting numbers, enum names, flags,
@"System.Runtime.Serialization.EnumMemberAttribute", and case-insensitive parsing of both UTF-16 and UTF-8 data.
The converter also correctly handles oddities on both UTF-8 and UTF-16, such as surrogates and non-ASCII data like emojis,
and intelligently switches between raw byte/memory manipulation and transcoding to chars when necessary.

```cs
[CsvEnumConverter<char, DayOfWeek>]
partial class DayOfWeekConverter;
```

### Limitations

- Hex-formatted values are not supported; the generator will defer to `Enum.TryFormat` and `Enum.TryParse`
- Custom enum names must not start with a digit or a dash (minus sign)
- Custom names must not be empty, or have duplicates among enum names.

### Example

Below is an example of the code generated by the source generator at the time of writing. The actual generated code may differ in later versions:

# [UTF-16](#tab/utf16)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>
#nullable enable

using System;
using __Unsafe = global::System.Runtime.CompilerServices.Unsafe;
using __MemoryMarshal = global::System.Runtime.InteropServices.MemoryMarshal;

namespace FlameCsv.Tests.Converters;

partial class EnumGeneratorCharTests {
[global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
partial class DayOfWeekConverter : global::FlameCsv.CsvConverter<char, global::System.DayOfWeek>
{
    private static WriteNumberImpl WriteNumberStrategy { get; } = new();
    private static WriteStringImpl WriteStringStrategy { get; } = new();
    private static ReadOrdinalImpl OrdinalStrategy { get; } = new();
    private static ReadIgnoreCaseImpl IgnoreCaseStrategy { get; } = new();

    private readonly ParseStrategy _parseStrategy;
    private readonly FormatStrategy _formatStrategy;
    private readonly bool _allowUndefinedValues;
    private readonly bool _ignoreCase;
    private readonly string? _format;

    public DayOfWeekConverter(CsvOptions<char> options)
    {
        global::System.ArgumentNullException.ThrowIfNull(options);
        _allowUndefinedValues = options.AllowUndefinedEnumValues;
        _ignoreCase = options.IgnoreEnumCase;
        _format = options.GetFormat(typeof(global::System.DayOfWeek), options.EnumFormat);
        _parseStrategy = _ignoreCase ? IgnoreCaseStrategy : OrdinalStrategy;
        _formatStrategy = _format switch
        {
            null or "g" or "G" => WriteStringStrategy,
            "d" or "D" => WriteNumberStrategy,
            "x" or "X" => throw new global::System.NotImplementedException("Hex format not supported"),
            { } configuredFormat => throw new global::System.NotSupportedException("Invalid enum format specified: " + configuredFormat)
        };
    }

    public override bool TryParse(global::System.ReadOnlySpan<char> source, out global::System.DayOfWeek value)
    {
        if (source.IsEmpty)
        {
            __Unsafe.SkipInit(out value);
            return false;
        }

        ref char first = ref __MemoryMarshal.GetReference(source);

        // Enum is small and contiguous from 0, try to use fast path
        if (source.Length == 1)
        {
            value = (global::System.DayOfWeek)(uint)(first - '0');
            return value < (global::System.DayOfWeek)7;
        }
        else if (_parseStrategy.TryParse(source, out value))
        {
            return true;
        }

        // not a known value
        return global::System.Enum.TryParse(source, _ignoreCase, out value)
            && (_allowUndefinedValues || IsDefined(value));
    }

    public override bool TryFormat(global::System.Span<char> destination, global::System.DayOfWeek value, out int charsWritten)
    {
        if (destination.IsEmpty)
        {
            __Unsafe.SkipInit(out charsWritten);
            return false;
        }

        if (_formatStrategy.TryFormat(destination, value, out charsWritten))
        {
            return true;
        }

        return ((global::System.ISpanFormattable)value).TryFormat(destination, out charsWritten, _format, provider: null);
    }

    /// <summary>
    /// Determines whether a specified value is defined for the enumeration.
    /// </summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(global::System.DayOfWeek value)
    {
        return (uint)value < 7U;
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private abstract class ParseStrategy
    {
        public abstract bool TryParse(global::System.ReadOnlySpan<char> source, out global::System.DayOfWeek value);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private abstract class FormatStrategy
    {
        public abstract bool TryFormat(global::System.Span<char> destination, global::System.DayOfWeek value, out int charsWritten);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class ReadOrdinalImpl : ParseStrategy
    {
        public override bool TryParse(global::System.ReadOnlySpan<char> source, out global::System.DayOfWeek value)
        {
            ref char first = ref __MemoryMarshal.GetReference(source);

            switch (source.Length)
            {
                case 6:
                {
                    switch (first)
                    {
                        case 'S':
                        {
                            if (source.EndsWith("unday", global::System.StringComparison.Ordinal))
                            {
                                value = global::System.DayOfWeek.Sunday;
                                return true;
                            }
                            break;
                        }
                        case 'M':
                        {
                            if (source.EndsWith("onday", global::System.StringComparison.Ordinal))
                            {
                                value = global::System.DayOfWeek.Monday;
                                return true;
                            }
                            break;
                        }
                        case 'F':
                        {
                            if (source.EndsWith("riday", global::System.StringComparison.Ordinal))
                            {
                                value = global::System.DayOfWeek.Friday;
                                return true;
                            }
                            break;
                        }
                    }
                    break;
                }
                case 7:
                {
                    if (source.Equals("Tuesday", global::System.StringComparison.Ordinal))
                    {
                        value = global::System.DayOfWeek.Tuesday;
                        return true;
                    }
                    break;
                }
                case 9:
                {
                    if (source.Equals("Wednesday", global::System.StringComparison.Ordinal))
                    {
                        value = global::System.DayOfWeek.Wednesday;
                        return true;
                    }
                    break;
                }
                case 8:
                {
                    switch (first)
                    {
                        case 'T':
                        {
                            if (source.EndsWith("hursday", global::System.StringComparison.Ordinal))
                            {
                                value = global::System.DayOfWeek.Thursday;
                                return true;
                            }
                            break;
                        }
                        case 'S':
                        {
                            if (source.EndsWith("aturday", global::System.StringComparison.Ordinal))
                            {
                                value = global::System.DayOfWeek.Saturday;
                                return true;
                            }
                            break;
                        }
                    }
                    break;
                }
                default:
                    break;
            }

            __Unsafe.SkipInit(out value);
            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class ReadIgnoreCaseImpl : ParseStrategy
    {
        public override bool TryParse(global::System.ReadOnlySpan<char> source, out global::System.DayOfWeek value)
        {
            ref char first = ref __MemoryMarshal.GetReference(source);

            switch (source.Length)
            {
                case 6:
                {
                    switch ((char)(first | 0x20))
                    {
                        case 's':
                        {
                            if (source.EndsWith("unday", global::System.StringComparison.OrdinalIgnoreCase))
                            {
                                value = global::System.DayOfWeek.Sunday;
                                return true;
                            }
                            break;
                        }
                        case 'm':
                        {
                            if (source.EndsWith("onday", global::System.StringComparison.OrdinalIgnoreCase))
                            {
                                value = global::System.DayOfWeek.Monday;
                                return true;
                            }
                            break;
                        }
                        case 'f':
                        {
                            if (source.EndsWith("riday", global::System.StringComparison.OrdinalIgnoreCase))
                            {
                                value = global::System.DayOfWeek.Friday;
                                return true;
                            }
                            break;
                        }
                    }
                    break;
                }
                case 7:
                {
                    if (source.Equals("Tuesday", global::System.StringComparison.OrdinalIgnoreCase))
                    {
                        value = global::System.DayOfWeek.Tuesday;
                        return true;
                    }
                    break;
                }
                case 9:
                {
                    if (source.Equals("Wednesday", global::System.StringComparison.OrdinalIgnoreCase))
                    {
                        value = global::System.DayOfWeek.Wednesday;
                        return true;
                    }
                    break;
                }
                case 8:
                {
                    switch ((char)(first | 0x20))
                    {
                        case 't':
                        {
                            if (source.EndsWith("hursday", global::System.StringComparison.OrdinalIgnoreCase))
                            {
                                value = global::System.DayOfWeek.Thursday;
                                return true;
                            }
                            break;
                        }
                        case 's':
                        {
                            if (source.EndsWith("aturday", global::System.StringComparison.OrdinalIgnoreCase))
                            {
                                value = global::System.DayOfWeek.Saturday;
                                return true;
                            }
                            break;
                        }
                    }
                    break;
                }
                default:
                    break;
            }

            __Unsafe.SkipInit(out value);
            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class WriteNumberImpl : FormatStrategy
    {
        public override bool TryFormat(global::System.Span<char> destination, global::System.DayOfWeek value, out int charsWritten)
        {
            __Unsafe.SkipInit(out charsWritten);

            ref char dst = ref __MemoryMarshal.GetReference(destination);

            if ((uint)value < 7)
            {
                dst = (char)('0' + value);
                charsWritten = 1;
                return true;
            }

            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class WriteStringImpl : FormatStrategy
    {
        public override bool TryFormat(global::System.Span<char> destination, global::System.DayOfWeek value, out int charsWritten)
        {
            __Unsafe.SkipInit(out charsWritten);

            ref char dst = ref __MemoryMarshal.GetReference(destination);

            switch (value)
            {
                case global::System.DayOfWeek.Sunday:
                {
                    if ("Sunday".TryCopyTo(destination))
                    {
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Monday:
                {
                    if ("Monday".TryCopyTo(destination))
                    {
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Tuesday:
                {
                    if ("Tuesday".TryCopyTo(destination))
                    {
                        charsWritten = 7;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Wednesday:
                {
                    if ("Wednesday".TryCopyTo(destination))
                    {
                        charsWritten = 9;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Thursday:
                {
                    if ("Thursday".TryCopyTo(destination))
                    {
                        charsWritten = 8;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Friday:
                {
                    if ("Friday".TryCopyTo(destination))
                    {
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Saturday:
                {
                    if ("Saturday".TryCopyTo(destination))
                    {
                        charsWritten = 8;
                        return true;
                    }
                    break;
                }
            }

            return false;
        }
    }
}
} // EnumGeneratorCharTests
```

# [UTF-8](#tab/utf8)
```cs
// <auto-generated>
// Generated by FlameCsv.SourceGen v0.1.0
// </auto-generated>
#nullable enable

using System;
using __Unsafe = global::System.Runtime.CompilerServices.Unsafe;
using __MemoryMarshal = global::System.Runtime.InteropServices.MemoryMarshal;

namespace FlameCsv.Tests.Converters;

partial class EnumGeneratorByteTests {
[global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
partial class DayOfWeekConverter : global::FlameCsv.CsvConverter<byte, global::System.DayOfWeek>
{
    private static WriteNumberImpl WriteNumberStrategy { get; } = new();
    private static WriteStringImpl WriteStringStrategy { get; } = new();
    private static ReadOrdinalImpl OrdinalStrategy { get; } = new();
    private static ReadIgnoreCaseImpl IgnoreCaseStrategy { get; } = new();

    private readonly ParseStrategy _parseStrategy;
    private readonly FormatStrategy _formatStrategy;
    private readonly bool _allowUndefinedValues;
    private readonly bool _ignoreCase;
    private readonly string? _format;

    public DayOfWeekConverter(CsvOptions<byte> options)
    {
        global::System.ArgumentNullException.ThrowIfNull(options);
        _allowUndefinedValues = options.AllowUndefinedEnumValues;
        _ignoreCase = options.IgnoreEnumCase;
        _format = options.GetFormat(typeof(global::System.DayOfWeek), options.EnumFormat);
        _parseStrategy = _ignoreCase ? IgnoreCaseStrategy : OrdinalStrategy;
        _formatStrategy = _format switch
        {
            null or "g" or "G" => WriteStringStrategy,
            "d" or "D" => WriteNumberStrategy,
            "x" or "X" => throw new global::System.NotImplementedException("Hex format not supported"),
            { } configuredFormat => throw new global::System.NotSupportedException("Invalid enum format specified: " + configuredFormat)
        };
    }

    public override bool TryParse(global::System.ReadOnlySpan<byte> source, out global::System.DayOfWeek value)
    {
        if (source.IsEmpty)
        {
            __Unsafe.SkipInit(out value);
            return false;
        }

        ref byte first = ref __MemoryMarshal.GetReference(source);

        // Enum is small and contiguous from 0, try to use fast path
        if (source.Length == 1)
        {
            value = (global::System.DayOfWeek)(uint)(first - '0');
            return value < (global::System.DayOfWeek)7;
        }
        else if (_parseStrategy.TryParse(source, out value))
        {
            return true;
        }

        // not a known value
        return TryParseSlow(source, out value);
    }

    public override bool TryFormat(global::System.Span<byte> destination, global::System.DayOfWeek value, out int charsWritten)
    {
        if (destination.IsEmpty)
        {
            __Unsafe.SkipInit(out charsWritten);
            return false;
        }

        if (_formatStrategy.TryFormat(destination, value, out charsWritten))
        {
            return true;
        }

        var handler = new global::System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler(0, 1, destination, out bool shouldAppend);
        if (shouldAppend)
        {
            handler.AppendFormatted(value, _format);
            return global::System.Text.Unicode.Utf8.TryWrite(destination, ref handler, out charsWritten);
        }

        charsWritten = 0;
        return false;
    }

    /// <summary>
    /// Determines whether a specified value is defined for the enumeration.
    /// </summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(global::System.DayOfWeek value)
    {
        return (uint)value < 7U;
    }

    private bool TryParseSlow(global::System.ReadOnlySpan<byte> source, out global::System.DayOfWeek value)
    {
        global::System.ReadOnlySpan<char> chars = GetChars(source, stackalloc char[32], out char[]? toReturn);
        bool retVal = global::System.Enum.TryParse(chars, _ignoreCase, out value) && (_allowUndefinedValues || IsDefined(value));
        if (toReturn is not null) global::System.Buffers.ArrayPool<char>.Shared.Return(toReturn, clearArray: true);
        return retVal;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
    private static global::System.ReadOnlySpan<char> GetChars(global::System.ReadOnlySpan<byte> source, global::System.Span<char> buffer, out char[]? toReturn)
    {
        global::System.Span<char> destination;
        int length = global::System.Text.Encoding.UTF8.GetMaxCharCount(source.Length);

        if (length <= buffer.Length || (length = global::System.Text.Encoding.UTF8.GetCharCount(source)) <= buffer.Length)
        {
            destination = buffer;
            toReturn = null;
        }
        else
        {
            toReturn = global::System.Buffers.ArrayPool<char>.Shared.Rent(length);
            destination = toReturn;
        }

        int written = global::System.Text.Encoding.UTF8.GetChars(source, destination);
        return destination.Slice(0, written);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private abstract class ParseStrategy
    {
        public abstract bool TryParse(global::System.ReadOnlySpan<byte> source, out global::System.DayOfWeek value);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private abstract class FormatStrategy
    {
        public abstract bool TryFormat(global::System.Span<byte> destination, global::System.DayOfWeek value, out int charsWritten);
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class ReadOrdinalImpl : ParseStrategy
    {
        public override bool TryParse(global::System.ReadOnlySpan<byte> source, out global::System.DayOfWeek value)
        {
            ref byte first = ref __MemoryMarshal.GetReference(source);

            switch (source.Length)
            {
                case 6:
                {
                    switch (first)
                    {
                        case (byte)'S':
                        {
                            if (source.EndsWith("unday"u8))
                            {
                                value = global::System.DayOfWeek.Sunday;
                                return true;
                            }
                            break;
                        }
                        case (byte)'M':
                        {
                            if (source.EndsWith("onday"u8))
                            {
                                value = global::System.DayOfWeek.Monday;
                                return true;
                            }
                            break;
                        }
                        case (byte)'F':
                        {
                            if (source.EndsWith("riday"u8))
                            {
                                value = global::System.DayOfWeek.Friday;
                                return true;
                            }
                            break;
                        }
                    }
                    break;
                }
                case 7:
                {
                    if (source.SequenceEqual("Tuesday"u8))
                    {
                        value = global::System.DayOfWeek.Tuesday;
                        return true;
                    }
                    break;
                }
                case 9:
                {
                    if (source.SequenceEqual("Wednesday"u8))
                    {
                        value = global::System.DayOfWeek.Wednesday;
                        return true;
                    }
                    break;
                }
                case 8:
                {
                    if (source.SequenceEqual("Thursday"u8))
                    {
                        value = global::System.DayOfWeek.Thursday;
                        return true;
                    }
                    if (source.SequenceEqual("Saturday"u8))
                    {
                        value = global::System.DayOfWeek.Saturday;
                        return true;
                    }
                    break;
                }
                default:
                    break;
            }

            __Unsafe.SkipInit(out value);
            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class ReadIgnoreCaseImpl : ParseStrategy
    {
        public override bool TryParse(global::System.ReadOnlySpan<byte> source, out global::System.DayOfWeek value)
        {
            ref byte first = ref __MemoryMarshal.GetReference(source);

            switch (source.Length)
            {
                case 6:
                {
                    if (__MemoryMarshal.Read<uint>("sund"u8) == (__Unsafe.ReadUnaligned<uint>(ref first) | 0x20202020U) &&
                        (source[4] | 0x20) == 'a' &&
                        (source[5] | 0x20) == 'y')
                    {
                        value = global::System.DayOfWeek.Sunday;
                        return true;
                    }
                    if (__MemoryMarshal.Read<uint>("mond"u8) == (__Unsafe.ReadUnaligned<uint>(ref first) | 0x20202020U) &&
                        (source[4] | 0x20) == 'a' &&
                        (source[5] | 0x20) == 'y')
                    {
                        value = global::System.DayOfWeek.Monday;
                        return true;
                    }
                    if (__MemoryMarshal.Read<uint>("frid"u8) == (__Unsafe.ReadUnaligned<uint>(ref first) | 0x20202020U) &&
                        (source[4] | 0x20) == 'a' &&
                        (source[5] | 0x20) == 'y')
                    {
                        value = global::System.DayOfWeek.Friday;
                        return true;
                    }
                    break;
                }
                case 7:
                {
                    if (__MemoryMarshal.Read<uint>("tues"u8) == (__Unsafe.ReadUnaligned<uint>(ref first) | 0x20202020U) &&
                        (source[4] | 0x20) == 'd' &&
                        (source[5] | 0x20) == 'a' &&
                        (source[6] | 0x20) == 'y')
                    {
                        value = global::System.DayOfWeek.Tuesday;
                        return true;
                    }
                    break;
                }
                case 9:
                {
                    if (__MemoryMarshal.Read<ulong>("wednesda"u8) == (__Unsafe.ReadUnaligned<ulong>(ref first) | 0x2020202020202020UL) &&
                        (source[8] | 0x20) == 'y')
                    {
                        value = global::System.DayOfWeek.Wednesday;
                        return true;
                    }
                    break;
                }
                case 8:
                {
                    if (__MemoryMarshal.Read<ulong>("thursday"u8) == (__Unsafe.ReadUnaligned<ulong>(ref first) | 0x2020202020202020UL))
                    {
                        value = global::System.DayOfWeek.Thursday;
                        return true;
                    }
                    if (__MemoryMarshal.Read<ulong>("saturday"u8) == (__Unsafe.ReadUnaligned<ulong>(ref first) | 0x2020202020202020UL))
                    {
                        value = global::System.DayOfWeek.Saturday;
                        return true;
                    }
                    break;
                }
                default:
                    break;
            }

            __Unsafe.SkipInit(out value);
            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class WriteNumberImpl : FormatStrategy
    {
        public override bool TryFormat(global::System.Span<byte> destination, global::System.DayOfWeek value, out int charsWritten)
        {
            __Unsafe.SkipInit(out charsWritten);

            ref byte dst = ref __MemoryMarshal.GetReference(destination);

            if ((uint)value < 7)
            {
                dst = (byte)('0' + value);
                charsWritten = 1;
                return true;
            }

            return false;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("FlameCsv.SourceGen", "0.1.0")]
    private sealed class WriteStringImpl : FormatStrategy
    {
        public override bool TryFormat(global::System.Span<byte> destination, global::System.DayOfWeek value, out int charsWritten)
        {
            __Unsafe.SkipInit(out charsWritten);

            ref byte dst = ref __MemoryMarshal.GetReference(destination);

            switch (value)
            {
                case global::System.DayOfWeek.Sunday:
                {
                    if (destination.Length >= 6)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<uint>("Sund"u8));
                        __Unsafe.Add(ref dst, 4) = (byte)'a';
                        __Unsafe.Add(ref dst, 5) = (byte)'y';
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Monday:
                {
                    if (destination.Length >= 6)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<uint>("Mond"u8));
                        __Unsafe.Add(ref dst, 4) = (byte)'a';
                        __Unsafe.Add(ref dst, 5) = (byte)'y';
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Tuesday:
                {
                    if (destination.Length >= 7)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<uint>("Tues"u8));
                        __Unsafe.Add(ref dst, 4) = (byte)'d';
                        __Unsafe.Add(ref dst, 5) = (byte)'a';
                        __Unsafe.Add(ref dst, 6) = (byte)'y';
                        charsWritten = 7;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Wednesday:
                {
                    if (destination.Length >= 9)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<ulong>("Wednesda"u8));
                        __Unsafe.Add(ref dst, 8) = (byte)'y';
                        charsWritten = 9;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Thursday:
                {
                    if (destination.Length >= 8)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<ulong>("Thursday"u8));
                        charsWritten = 8;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Friday:
                {
                    if (destination.Length >= 6)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<uint>("Frid"u8));
                        __Unsafe.Add(ref dst, 4) = (byte)'a';
                        __Unsafe.Add(ref dst, 5) = (byte)'y';
                        charsWritten = 6;
                        return true;
                    }
                    break;
                }
                case global::System.DayOfWeek.Saturday:
                {
                    if (destination.Length >= 8)
                    {
                        __Unsafe.WriteUnaligned(ref dst, __MemoryMarshal.Read<ulong>("Saturday"u8));
                        charsWritten = 8;
                        return true;
                    }
                    break;
                }
            }

            return false;
        }
    }
}
} // EnumGeneratorByteTests
```
