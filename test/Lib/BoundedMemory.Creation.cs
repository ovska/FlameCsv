// <auto-generated/>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Buffers;
using System.Runtime.InteropServices;

namespace FlameCsv.Tests;

#nullable enable

/// <summary>
/// Contains factory methods to create <see cref="BoundedMemory{T}"/> instances.
/// </summary>
public static unsafe partial class BoundedMemory
{
    public abstract class Manager<T> : MemoryManager<T>;
    
    public static bool UnixBoundsEnabled { get; set; }
    private static readonly int SystemPageSize = Environment.SystemPageSize;
    
    public static IMemoryOwner<T> AllocateLoose<T>(int elementCount, PoisonPagePlacement placement) where T : unmanaged
    {
        if (placement is PoisonPagePlacement.Before or PoisonPagePlacement.After)
        {
            return BoundedMemory.Allocate<T>(elementCount, placement);
        }
        else
        {
            return MemoryPool<T>.Shared.Rent(elementCount);
        }
    }

    /// <summary>
    /// Allocates a new <see cref="BoundedMemory{T}"/> region which is immediately preceded by
    /// or immediately followed by a poison (MEM_NOACCESS) page. If <paramref name="placement"/>
    /// is <see cref="PoisonPagePlacement.Before"/>, then attempting to read the memory
    /// immediately before the returned <see cref="BoundedMemory{T}"/> will result in an AV.
    /// If <paramref name="placement"/> is <see cref="PoisonPagePlacement.After"/>, then
    /// attempting to read the memory immediately after the returned <see cref="BoundedMemory{T}"/>
    /// will result in AV.
    /// </summary>
    /// <remarks>
    /// The newly-allocated memory will be populated with random data.
    /// </remarks>
    public static BoundedMemory<T> Allocate<T>(int elementCount, PoisonPagePlacement placement = PoisonPagePlacement.After) where T : unmanaged
    {
        if (elementCount < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(elementCount));
        }
        if (placement != PoisonPagePlacement.Before && placement != PoisonPagePlacement.After)
        {
            throw new ArgumentOutOfRangeException(nameof(placement));
        }

        BoundedMemory<T> retVal = AllocateWithoutDataPopulation<T>(elementCount, placement);
        Random.Shared.NextBytes(MemoryMarshal.AsBytes(retVal.Span));
        return retVal;
    }

    /// <summary>
    /// Similar to <see cref="Allocate{T}(int, PoisonPagePlacement)"/>, but populates the allocated
    /// native memory block from existing data rather than using random data.
    /// </summary>
    public static BoundedMemory<T> AllocateFromExistingData<T>(ReadOnlySpan<T> data, PoisonPagePlacement placement = PoisonPagePlacement.After) where T : unmanaged
    {
        if (placement != PoisonPagePlacement.Before && placement != PoisonPagePlacement.After)
        {
            throw new ArgumentOutOfRangeException(nameof(placement));
        }

        BoundedMemory<T> retVal = AllocateWithoutDataPopulation<T>(data.Length, placement);
        data.CopyTo(retVal.Span);
        return retVal;
    }

    /// <summary>
    /// Similar to <see cref="Allocate{T}(int, PoisonPagePlacement)"/>, but populates the allocated
    /// native memory block from existing data rather than using random data.
    /// </summary>
    public static BoundedMemory<T> AllocateFromExistingData<T>(T[] data, PoisonPagePlacement placement = PoisonPagePlacement.After) where T : unmanaged
    {
        return AllocateFromExistingData(new ReadOnlySpan<T>(data), placement);
    }

    private static BoundedMemory<T> AllocateWithoutDataPopulation<T>(int elementCount, PoisonPagePlacement placement) where T : unmanaged
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            return AllocateWithoutDataPopulationWindows<T>(elementCount, placement);
        }
        return AllocateWithoutDataPopulationUnix<T>(elementCount, placement);
    }

    private static UnixImplementation<T> AllocateWithoutDataPopulationUnix<T>(int elementCount, PoisonPagePlacement placement) where T : unmanaged
    {
        return new UnixImplementation<T>(elementCount, placement);
    }

    private sealed class UnixImplementation<T> : BoundedMemory<T> where T : unmanaged
    {
        private readonly MMapHandle _handle;
        private readonly int _elementCount;
        private readonly BoundedMemoryManager _memoryManager;

        public UnixImplementation(int elementCount, PoisonPagePlacement placement)
        {
            _handle = MMapHandle.Allocate(checked(elementCount * (nint)sizeof(T)), placement);
            _elementCount = elementCount;
            _memoryManager = new BoundedMemoryManager(this);
        }

        public override bool IsReadonly => false;

        public override int Length => _elementCount;

        public override Memory<T> Memory => _memoryManager.Memory;

        public override Span<T> Span
        {
            get
            {
                bool refAdded = false;
                try
                {
                    _handle.DangerousAddRef(ref refAdded);
                    return new Span<T>((void*)_handle.DangerousGetHandle(), _elementCount);
                }
                finally
                {
                    if (refAdded)
                    {
                        _handle.DangerousRelease();
                    }
                }
            }
        }

        public override void Dispose()
        {
            _handle.Dispose();
        }

        public override void MakeReadonly()
        {
            // no-op
        }

        public override void MakeWriteable()
        {
            // no-op
        }

        private sealed class BoundedMemoryManager : Manager<T>
        {
            private readonly UnixImplementation<T> _impl;

            public BoundedMemoryManager(UnixImplementation<T> impl)
            {
                _impl = impl;
            }

            public override Memory<T> Memory => CreateMemory(_impl._elementCount);

            protected override void Dispose(bool disposing)
            {
                // no-op; the handle will be disposed separately
            }

            public override Span<T> GetSpan() => _impl.Span;

            public override MemoryHandle Pin(int elementIndex)
            {
                if ((uint)elementIndex > (uint)_impl._elementCount)
                {
                    throw new ArgumentOutOfRangeException(paramName: nameof(elementIndex));
                }

                bool refAdded = false;
                try
                {
                    _impl._handle.DangerousAddRef(ref refAdded);
                    return new MemoryHandle((T*)_impl._handle.DangerousGetHandle() + elementIndex);
                }
                finally
                {
                    if (refAdded)
                    {
                        _impl._handle.DangerousRelease();
                    }
                }
            }

            public override void Unpin()
            {
                // no-op - we don't unpin native memory
            }
        }
    }

    private sealed class MMapHandle : SafeHandle
    {
        private IntPtr buffer;
        private ulong allocationSize;

        // Called by P/Invoke when returning SafeHandles
        private MMapHandle(IntPtr buffer, ulong allocationSize)
            : base(IntPtr.Zero, ownsHandle: true)
        {
            this.buffer = buffer;
            this.allocationSize = allocationSize;
        }

        internal static MMapHandle Allocate(nint byteLength, PoisonPagePlacement placement)
        {
            // Allocate number of pages to incorporate required (byteLength bytes of) memory and an additional page to create a poison page.
            int pageSize = Environment.SystemPageSize;
            int allocationSize = (int)(((byteLength / pageSize) + ((byteLength % pageSize) == 0 ? 0 : 1) + 1) * pageSize);
            IntPtr buffer = MMap(0, (ulong)allocationSize, (int)(MemoryMappedProtections.PROT_READ | MemoryMappedProtections.PROT_WRITE), (int)(MemoryMappedFlags.MAP_PRIVATE | MemoryMappedFlags.MAP_ANONYMOUS), -1, 0);

            // Depending on the PoisonPagePlacement requirement (before/after) initialise the baseAddress and poisonPageAddress to point to the location
            // in the buffer. Here the baseAddress points to the first valid allocation and poisonPageAddress points to the first invalid location.
            // For `PoisonPagePlacement.Before` the first page is made inaccessible using mprotect and baseAddress points to the start of the second page.
            // The allocation and protection is at the granularity of a page. Thus, `PoisonPagePlacement.Before` configuration has an additional accessible
            // memory at the end of the page (bytes equivalent to `pageSize - (byteLength % pageSize)`).
            // For `PoisonPagePlacement.After`, we adjust the baseAddress so that inaccessible memory is at the `byteLength` offset from the baseAddress.
            IntPtr baseAddress = buffer + pageSize;
            IntPtr poisonPageAddress = buffer;
            if (placement == PoisonPagePlacement.After)
            {
                baseAddress = buffer + (allocationSize - pageSize - byteLength);
                poisonPageAddress = buffer + (allocationSize - pageSize);
            }

            // Protect the page before/after based on the poison page placement.
            if (MProtect(poisonPageAddress, (ulong)pageSize, (int)MemoryMappedProtections.PROT_NONE) == -1)
            {
                throw new InvalidOperationException($"Failed to mark page as a poison page using mprotect with error :{Marshal.GetLastPInvokeError()}.");
            }

            MMapHandle retVal = new MMapHandle(buffer, (ulong)allocationSize);
            retVal.SetHandle(baseAddress); // this base address would be used as the start of Span that is used during unit testing.
            return retVal;
        }

        public override bool IsInvalid => (handle == IntPtr.Zero);

        protected override bool ReleaseHandle()
        {
            MUnmap(buffer, allocationSize);
            return true;
        }

        [Flags]
        private enum MemoryMappedProtections
        {
            PROT_NONE = 0x0,
            PROT_READ = 0x1,
            PROT_WRITE = 0x2,
            PROT_EXEC = 0x4
        }

        [Flags]
        private enum MemoryMappedFlags
        {
            MAP_SHARED = 0x01,
            MAP_PRIVATE = 0x02,
            MAP_ANONYMOUS = 0x10,
        }

        private const string SystemNative = "libSystem.Native";

        // NOTE: Shim returns null pointer on failure, not non-null MAP_FAILED sentinel.
        [DllImport(SystemNative, EntryPoint = "SystemNative_MMap", SetLastError = true)]
        private static extern IntPtr MMap(IntPtr addr, ulong len, int prot, int flags, IntPtr fd, long offset);

        [DllImport(SystemNative, EntryPoint = "SystemNative_MProtect", SetLastError = true)]
        private static extern int MProtect(IntPtr addr, ulong len, int prot);

        [DllImport(SystemNative, EntryPoint = "SystemNative_MUnmap", SetLastError = true)]
        internal static extern int MUnmap(IntPtr addr, ulong len);
    }

    private static WindowsImplementation<T> AllocateWithoutDataPopulationWindows<T>(int elementCount, PoisonPagePlacement placement) where T : unmanaged
    {
        long cb, totalBytesToAllocate;
        checked
        {
            cb = elementCount * sizeof(T);
            totalBytesToAllocate = cb;

            // We only need to round the count up if it's not an exact multiple
            // of the system page size.

            long leftoverBytes = totalBytesToAllocate % SystemPageSize;
            if (leftoverBytes != 0)
            {
                totalBytesToAllocate += SystemPageSize - leftoverBytes;
            }

            // Finally, account for the poison pages at the front and back.

            totalBytesToAllocate += 2 * SystemPageSize;
        }

        // Reserve and commit the entire range as NOACCESS.
        VirtualAllocHandle handle;
        checked
        {
            handle = VirtualAllocHandle.Allocate(
                lpAddress: IntPtr.Zero,
                dwSize: (IntPtr)totalBytesToAllocate /* cast throws OverflowException if out of range */,
                flAllocationType: VirtualAllocAllocationType.MEM_RESERVE | VirtualAllocAllocationType.MEM_COMMIT,
                flProtect: VirtualAllocProtection.PAGE_NOACCESS);
        }

        if (handle == null || handle.IsInvalid)
        {
            int lastError = Marshal.GetHRForLastWin32Error();
            handle?.Dispose();
            Marshal.ThrowExceptionForHR(lastError);
            throw new InvalidOperationException("VirtualAlloc failed unexpectedly.");
        }

        // Done allocating! Now carve out a READWRITE section bookended by the NOACCESS
        // pages and return that carved-out section to the caller. Since memory protection
        // flags only apply at page-level granularity, we need to "left-align" or "right-
        // align" the section we carve out so that it's guaranteed adjacent to one of
        // the NOACCESS bookend pages.

        return new WindowsImplementation<T>(
            handle: handle,
            byteOffsetIntoHandle: (placement == PoisonPagePlacement.Before)
                ? SystemPageSize /* just after leading poison page */
                : checked((int)(totalBytesToAllocate - SystemPageSize - cb)) /* just before trailing poison page */,
            elementCount: elementCount)
        {
            Protection = VirtualAllocProtection.PAGE_READWRITE
        };
    }

    private sealed class WindowsImplementation<T> : BoundedMemory<T> where T : unmanaged
    {
        private readonly VirtualAllocHandle _handle;
        private readonly int _byteOffsetIntoHandle;
        private readonly int _elementCount;
        private readonly BoundedMemoryManager _memoryManager;

        internal WindowsImplementation(VirtualAllocHandle handle, int byteOffsetIntoHandle, int elementCount)
        {
            _handle = handle;
            _byteOffsetIntoHandle = byteOffsetIntoHandle;
            _elementCount = elementCount;
            _memoryManager = new BoundedMemoryManager(this);
        }

        public override bool IsReadonly => (Protection != VirtualAllocProtection.PAGE_READWRITE);

        public override int Length => _elementCount;

        internal VirtualAllocProtection Protection
        {
            get
            {
                bool refAdded = false;
                try
                {
                    _handle.DangerousAddRef(ref refAdded);
                    MEMORY_BASIC_INFORMATION memoryInfo;
                    if (UnsafeNativeMethods.VirtualQuery(
                        lpAddress: _handle.DangerousGetHandle() + _byteOffsetIntoHandle,
                        lpBuffer: &memoryInfo,
                        dwLength: (IntPtr)sizeof(MEMORY_BASIC_INFORMATION)) == IntPtr.Zero)
                    {
                        Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
                        throw new InvalidOperationException("VirtualQuery failed unexpectedly.");
                    }
                    return memoryInfo.Protect;
                }
                finally
                {
                    if (refAdded)
                    {
                        _handle.DangerousRelease();
                    }
                }
            }
            set
            {
                if (_elementCount > 0)
                {
                    bool refAdded = false;
                    try
                    {
                        _handle.DangerousAddRef(ref refAdded);
                        VirtualAllocProtection flOldProtect;
                        if (UnsafeNativeMethods.VirtualProtect(
                            lpAddress: _handle.DangerousGetHandle() + _byteOffsetIntoHandle,
                            dwSize: (IntPtr)(&((T*)null!)[_elementCount]),
                            flNewProtect: value,
                            lpflOldProtect: &flOldProtect) == 0)
                        {
                            Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
                            throw new InvalidOperationException("VirtualProtect failed unexpectedly.");
                        }
                    }
                    finally
                    {
                        if (refAdded)
                        {
                            _handle.DangerousRelease();
                        }
                    }
                }
            }
        }

        public override Memory<T> Memory => _memoryManager.Memory;

        public override Span<T> Span
        {
            get
            {
                bool refAdded = false;
                try
                {
                    _handle.DangerousAddRef(ref refAdded);
                    return new Span<T>((void*)(_handle.DangerousGetHandle() + _byteOffsetIntoHandle), _elementCount);
                }
                finally
                {
                    if (refAdded)
                    {
                        _handle.DangerousRelease();
                    }
                }
            }
        }

        public override void Dispose()
        {
            _handle.Dispose();
        }

        public override void MakeReadonly()
        {
            Protection = VirtualAllocProtection.PAGE_READONLY;
        }

        public override void MakeWriteable()
        {
            Protection = VirtualAllocProtection.PAGE_READWRITE;
        }

        private sealed class BoundedMemoryManager : Manager<T>
        {
            private readonly WindowsImplementation<T> _impl;

            public BoundedMemoryManager(WindowsImplementation<T> impl)
            {
                _impl = impl;
            }

            public override Memory<T> Memory => CreateMemory(_impl._elementCount);

            protected override void Dispose(bool disposing)
            {
                // no-op; the handle will be disposed separately
            }

            public override Span<T> GetSpan() => _impl.Span;

            public override MemoryHandle Pin(int elementIndex)
            {
                if ((uint)elementIndex > (uint)_impl._elementCount)
                {
                    throw new ArgumentOutOfRangeException(paramName: nameof(elementIndex));
                }

                bool refAdded = false;
                try
                {
                    _impl._handle.DangerousAddRef(ref refAdded);
                    return new MemoryHandle((T*)(_impl._handle.DangerousGetHandle() + _impl._byteOffsetIntoHandle) + elementIndex);
                }
                finally
                {
                    if (refAdded)
                    {
                        _impl._handle.DangerousRelease();
                    }
                }
            }

            public override void Unpin()
            {
                // no-op - we don't unpin native memory
            }
        }
    }

    // from winnt.h
    [Flags]
    private enum VirtualAllocAllocationType : uint
    {
        MEM_COMMIT = 0x1000,
        MEM_RESERVE = 0x2000,
        MEM_DECOMMIT = 0x4000,
        MEM_RELEASE = 0x8000,
        MEM_FREE = 0x10000,
        MEM_PRIVATE = 0x20000,
        MEM_MAPPED = 0x40000,
        MEM_RESET = 0x80000,
        MEM_TOP_DOWN = 0x100000,
        MEM_WRITE_WATCH = 0x200000,
        MEM_PHYSICAL = 0x400000,
        MEM_ROTATE = 0x800000,
        MEM_LARGE_PAGES = 0x20000000,
        MEM_4MB_PAGES = 0x80000000,
    }

    // from winnt.h
    [Flags]
    private enum VirtualAllocProtection : uint
    {
        PAGE_NOACCESS = 0x01,
        PAGE_READONLY = 0x02,
        PAGE_READWRITE = 0x04,
        PAGE_WRITECOPY = 0x08,
        PAGE_EXECUTE = 0x10,
        PAGE_EXECUTE_READ = 0x20,
        PAGE_EXECUTE_READWRITE = 0x40,
        PAGE_EXECUTE_WRITECOPY = 0x80,
        PAGE_GUARD = 0x100,
        PAGE_NOCACHE = 0x200,
        PAGE_WRITECOMBINE = 0x400,
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct MEMORY_BASIC_INFORMATION
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public VirtualAllocProtection AllocationProtect;
        public IntPtr RegionSize;
        public VirtualAllocAllocationType State;
        public VirtualAllocProtection Protect;
        public VirtualAllocAllocationType Type;
    };

    private sealed class VirtualAllocHandle : SafeHandle
    {
        // Called by P/Invoke when returning SafeHandles
        public VirtualAllocHandle()
            : base(IntPtr.Zero, ownsHandle: true)
        {
        }

        internal static VirtualAllocHandle Allocate(IntPtr lpAddress, IntPtr dwSize, VirtualAllocAllocationType flAllocationType, VirtualAllocProtection flProtect)
        {
            VirtualAllocHandle retVal = new VirtualAllocHandle();
            retVal.SetHandle(UnsafeNativeMethods.VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect));
            return retVal;
        }

        // Do not provide a finalizer - SafeHandle's critical finalizer will
        // call ReleaseHandle for you.

        public override bool IsInvalid => (handle == IntPtr.Zero);

        protected override bool ReleaseHandle() =>
            UnsafeNativeMethods.VirtualFree(handle, IntPtr.Zero, VirtualAllocAllocationType.MEM_RELEASE) != 0;
    }

    private static unsafe partial class UnsafeNativeMethods
    {
        private const string KERNEL32_LIB = "kernel32.dll";

        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx
        [LibraryImport(KERNEL32_LIB, SetLastError = true)]
        public static partial IntPtr VirtualAlloc(IntPtr lpAddress, IntPtr dwSize, VirtualAllocAllocationType flAllocationType, VirtualAllocProtection flProtect);

        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa366892(v=vs.85).aspx
        [LibraryImport(KERNEL32_LIB, SetLastError = true)]
        public static partial int VirtualFree(IntPtr lpAddress, IntPtr dwSize, VirtualAllocAllocationType dwFreeType);

        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa366898(v=vs.85).aspx
        [LibraryImport(KERNEL32_LIB, SetLastError = true)]
        public static partial int VirtualProtect(IntPtr lpAddress, IntPtr dwSize, VirtualAllocProtection flNewProtect, VirtualAllocProtection* lpflOldProtect);

        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa366902(v=vs.85).aspx
        [LibraryImport(KERNEL32_LIB, SetLastError = true)]
        public static partial IntPtr VirtualQuery(IntPtr lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, IntPtr dwLength);
}
}

/// <summary>
/// Dictates where the poison page should be placed.
/// </summary>
public enum PoisonPagePlacement
{
    None = 0,
    
    /// <summary>
    /// The poison page should be placed immediately after the memory region.
    /// Attempting to access the memory page immediately following the
    /// span will result in an AV.
    /// </summary>
    After,

    /// <summary>
    /// The poison page should be placed immediately before the memory region.
    /// Attempting to access the memory page immediately before the
    /// span will result in an AV.
    /// </summary>
    Before,
}
