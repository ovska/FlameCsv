using System.Runtime.InteropServices;
using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using FlameCsv.SourceGen.Utilities;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen.Generators;

[Generator(LanguageNames.CSharp)]
internal partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(TypeMapModel typeMap, EquatableArray<Diagnostic> diagnostics)> modelAndDiagnostics =
            context
                .SyntaxProvider.ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvTypeMapAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return (
                            ContainingClass: (INamedTypeSymbol)context.TargetSymbol,
                            Attribute: context.Attributes[0]
                        );
                    }
                )
                .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
                .WithTrackingName("FlameCsv_Target")
                .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
                .Select(
                    static (tuple, cancellationToken) =>
                    {
                        var typeMap = new TypeMapModel(
                            compilation: tuple.Right,
                            containingClass: tuple.Left.ContainingClass,
                            attribute: tuple.Left.Attribute,
                            cancellationToken,
                            out EquatableArray<Diagnostic> diagnostics
                        );

                        return (typeMap, diagnostics);
                    }
                )
                .WithTrackingName("FlameCsv_TypeMapAndDiagnostics");

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .SelectMany(static (tuple, _) => tuple.diagnostics.AsImmutableArray())
                .WithTrackingName("FlameCsv_Diagnostics"),
            static (context, diagnostic) => context.ReportDiagnostic(diagnostic)
        );

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Where(static tuple => tuple.typeMap.CanGenerateCode)
                .Select(static (tuple, _) => tuple.typeMap)
                .WithTrackingName("FlameCsv_TypeMap"),
            ExecuteGenerator
        );
    }

    private static void ExecuteGenerator(SourceProductionContext context, TypeMapModel typeMap)
    {
#if WRITER_DEBUG
        try
        {
#endif
            string sourceName = GlobalConstants.GetFileName(typeMap.TypeMap.Name, typeMap.WrappingTypes);
            context.AddSource(sourceName, CreateTypeMap(typeMap, context.CancellationToken));
#if WRITER_DEBUG
        }
        catch (Exception e)
        {
            throw new System.Diagnostics.UnreachableException($"Uncaught {e.GetType().Name}: {e.StackTrace}", e);
        }
#endif
    }

    private static SourceText CreateTypeMap(TypeMapModel typeMap, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(GlobalConstants.GeneratedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine();

        if (typeMap.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {typeMap.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(GlobalConstants.CodeDomAttribute);
        writer.WriteLine(
            $"partial class {typeMap.TypeMap.Name} : global::FlameCsv.Binding.CsvTypeMap<{typeMap.TokenName}, {typeMap.Type.FullyQualifiedName}>"
        );

        using (writer.WriteBlock())
        {
            WriteDefaultInstance(writer, typeMap);
            WriteOverrideGuids(writer, typeMap);
            GetReadCode(writer, typeMap, cancellationToken);
            GetWriteCode(writer, typeMap, cancellationToken);
        }

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(writer.ToString(), Encoding.UTF8);
    }

    private static void WriteDefaultInstance(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        writer.WriteLine("/// <summary>");
        writer.WriteLine("/// Returns a thread-safe instance of the typemap with default options.");
        writer.WriteLine("/// </summary>");
        writer.WriteLine(
            $"public static {typeMap.TypeMap.FullyQualifiedName} Default {{ get; }} = new {typeMap.TypeMap.FullyQualifiedName}();"
        );
        writer.WriteLine();
    }

    private static void WriteOverrideGuids(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        bool anyGuid = false;

        foreach (var member in typeMap.AllMembers)
        {
            if (member.OverriddenConverter is null)
                continue;

            anyGuid = true;

            Guid guid = Guid.NewGuid();
            byte[] bytes = guid.ToByteArray();

            writer.Write("private static readonly global::System.Guid ");
            member.WriteOverrideId(writer);
            writer.Write(" = new global::System.Guid(");
            writer.Write($"0x{MemoryMarshal.Read<uint>(bytes):X8}, ");
            writer.Write($"0x{MemoryMarshal.Read<ushort>(bytes.AsSpan(4)):X4}, ");
            writer.Write($"0x{MemoryMarshal.Read<ushort>(bytes.AsSpan(6)):X4}, ");
            for (int i = 8; i < bytes.Length; i++)
            {
                writer.Write($"0x{bytes[i]:X2}");
                if (i < bytes.Length - 1)
                {
                    writer.Write(", ");
                }
            }

            writer.Write("); // ");
            writer.WriteLine(guid.ToString());
        }

        if (anyGuid)
        {
            writer.WriteLine();
        }
    }
}
