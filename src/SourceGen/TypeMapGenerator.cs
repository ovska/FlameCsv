using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
internal partial class TypeMapGenerator : IIncrementalGenerator
{
    const string DoesNotReturnAttr = "[global::System.Diagnostics.CodeAnalysis.DoesNotReturn]";

    const string NoInliningAttr
        = "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]";

    const string EditorBrowsableNever
        = "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(TypeMapModel typeMap, EquatableArray<Diagnostic> diagnostics)> typeMapDiagnostics
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvTypeMapAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol,
                            Attribute: context.Attributes[0]);
                    })
                .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
                .WithTrackingName("FlameCsv_Target")
#if SOURCEGEN_USE_COMPILATION
                .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
                .Select(
                    static (tuple, cancellationToken) =>
                    {
                        var typeMap = new TypeMapModel(
                            compilation: tuple.Right,
                            containingClass: tuple.Left.ContainingClass,
                            attribute: tuple.Left.Attribute,
                            cancellationToken,
                            out EquatableArray<Diagnostic> diagnostics);

                        return (typeMap, diagnostics);
                    })
#else
            .Select(
                static (value, cancellationToken) =>
                {
                    var typeMap = new TypeMapModel(
                        containingClass: value.ContainingClass,
                        attribute: value.Attribute,
                        cancellationToken,
                        out EquatableArray<Diagnostic> diagnostics);

                    return (typeMap, diagnostics);
                })
#endif
                .WithTrackingName("FlameCsv_TypeMapAndDiagnostics");

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.diagnostics).WithTrackingName("FlameCsv_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.typeMap).WithTrackingName("FlameCsv_TypeMap"),
            static (context, source) => Execute(in source, context));
    }

    private static void Execute(ref readonly TypeMapModel typeMap, SourceProductionContext context)
    {
        if (!typeMap.CanGenerateCode) return;

        string sourceName = GlobalConstants.GetFileName(typeMap.TypeMap.Name, typeMap.WrappingTypes);

        context.AddSource(sourceName, CreateTypeMap(in typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        ref readonly TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(GlobalConstants.GeneratedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine();

        if (typeMap.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {typeMap.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(GlobalConstants.CodeDomAttribute);
        writer.WriteLine(
            $"partial class {typeMap.TypeMap.Name} : global::FlameCsv.Binding.CsvTypeMap<{typeMap.Token.FullyQualifiedName}, {typeMap.Type.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            WriteDefaultInstance(writer, in typeMap);
            WriteIndexes(writer, in typeMap);
            GetReadCode(writer, in typeMap, cancellationToken);
            GetWriteCode(writer, in typeMap, cancellationToken);
        }

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(writer.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(IndentedTextWriter writer, ref readonly TypeMapModel typeMap)
    {
        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var member in typeMap.AllMembers)
        {
            if (!member.CanRead) continue;

            writer.Write("private const int ");
            member.WriteId(writer);
            writer.WriteLine($" = {index++};");
        }

        writer.WriteLine("private const int @s__MinId = 1;");
        writer.WriteLine($"private const int @s__MaxId = {index - 1};");
        writer.WriteLine();
    }
}
