using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using FlameCsv.SourceGen.Utilities;

namespace FlameCsv.SourceGen;

internal static class GlobalConstants
{
    static GlobalConstants()
    {
        string assemblyName = typeof(GlobalConstants).Assembly.GetName().Name;
        string version = typeof(GlobalConstants).Assembly.GetName().Version.ToString(3);

        GeneratedCodeComment = $"// Generated by {assemblyName} v{version}";
        CodeDomAttribute =
            $"[global::System.CodeDom.Compiler.GeneratedCode({assemblyName.ToStringLiteral()}, {version.ToStringLiteral()})]";
    }

    public static readonly string GeneratedCodeComment;
    public static readonly string CodeDomAttribute;

    public const string NoInliningAttr =
        "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]";

    public const string AggressiveInliningAttr =
        "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]";

    public const string DoesNotReturnAttr = "[global::System.Diagnostics.CodeAnalysis.DoesNotReturn]";

    public const string EditorBrowsableAttr =
        "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]";

    public static string GetFileName(string typeName, EquatableArray<NestedType> wrappingTypes)
    {
        using var builder = new ImmutableArrayBuilder<char>();

        foreach (var wrapping in wrappingTypes)
        {
            builder.AddRange(wrapping.Name.AsSpan());
            builder.Add('_');
        }

        builder.AddRange(typeName.AsSpan());
        builder.AddRange(".G.cs".AsSpan());

        return builder.WrittenSpan.ToString();
    }
}
