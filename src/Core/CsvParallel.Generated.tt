<#@ template language="C#" #>
// <auto-generated />
#nullable enable
using System.Text;
using System.Runtime.CompilerServices;
using FlameCsv.Binding;
using FlameCsv.IO;
using FlameCsv.IO.Internal;
using FlameCsv.ParallelUtils;

namespace FlameCsv;

static partial class CsvParallel
{
<#
    foreach (var sourceGen in (bool[])[false, true])
    foreach (var utf8 in (bool[])[false, true])
    foreach (var streaming in (bool[])[false, true])
    foreach (var isAsync in (bool[])[true, false])
    foreach (var fromFile in (bool[])[true, false])
    {
        if (fromFile && !streaming) continue;

        string generic = utf8 ? "byte" : "char";
        
        string source = fromFile
            ? "string"
            : streaming
                ? utf8 ? "Stream" : "TextReader"
                : utf8 ? "ReadOnlyMemory<byte>" : "ReadOnlyMemory<char>";
        
        string sourceName = fromFile
            ? "path"
            : streaming
                ? utf8 ? "stream" : "reader"
                : "csv";

        string docSuffix = sourceGen
            ? " using the type map"
            : " using reflection";

        string attrs = sourceGen
            ? ""
            : "[RUF(Messages.Reflection), RDC(Messages.DynamicCode)]\n    ";

        if (fromFile && utf8 && !sourceGen)
        {
            attrs += "[OverloadResolutionPriority(1000)] // prefer byte overload for file\r\n    ";
        }

        string typeAttrs = sourceGen
            ? ""
            : "[DAM(Messages.ReflectionBound)] ";

        string typeMapArg = sourceGen
            ? $"\r\n        CsvTypeMap<{generic}, TValue> typeMap,"
            : "";
            
        string ioOptsArg = streaming
            ? $"\r\n        CsvIOOptions ioOptions = default,"
            : "";
        
        string encodingArg = fromFile && !utf8
            ? $"\r\n        Encoding? encoding = null,"
            : "";
            
        string typeMapParam = sourceGen
            ? "typeMap, "
            : "";

        string ioOptsParam = streaming
            ? ", ioOptions"
            : ", null";
            
        string encodingParam = fromFile && !utf8
            ? ", encoding"
            : "";

        string validateTypeMap = sourceGen
            ? "\r\n        ArgumentNullException.ThrowIfNull(typeMap);\r\n"
            : "";
            
        string validateSource = fromFile
            ? $"\r\n        ArgumentException.ThrowIfNullOrEmpty(path);"
            : streaming
                ? $"\r\n        ArgumentNullException.ThrowIfNull({sourceName});"
                : "";
        
        string configureIoOpts = fromFile
            ? $"\r\n        ioOptions = ioOptions.ForFileIO();"
            : "";

        if (streaming && utf8 && !fromFile)
        {
            validateSource += $"\r\n        if (!{sourceName}.CanRead) FlameCsv.Extensions.Throw.StreamNotReadable({sourceName});";
        }

        string typeMapDocs = sourceGen
            ? "\r\n    /// <param name=\"typeMap\">Type map used to bind the CSV data</param>"
            : "";
            
        string asyncSuffix = isAsync
            ? "Async"
            : "";
        
        string fileSuffix = fromFile
            ? "FromFile"
            : "";
        
        string returnType = isAsync 
            ? "IAsyncEnumerable<ReadOnlyMemory<TValue>>"
            : "IEnumerable<ReadOnlySpan<TValue>>";
            
        string sourceComment = streaming
            ? utf8
                ? "Stream to read the CSV data from"
                : "TextReader to read the CSV data from"
            : "CSV data to read";
        
        string ioOptsComment = streaming
            ? "\r\n    /// <param name=\"ioOptions\">Options to configure the buffer size and other IO related options</param>"
            : "";
        
        string createArg = fromFile
            ? $"CsvReader.GetFileStream(path, isAsync: {(isAsync ? "true" : "false")}, in ioOptions)"
            : sourceName;
            
        string encodingDocs = fromFile && !utf8
            ? "\r\n    /// <param name=\"encoding\">Encoding to use, defaults to UTF8</param>"
            : "";
#>
    /// <summary>
    /// Parses CSV records from the CSV data <paramref name="<#= sourceName #>"/>.
    /// </summary>
    /// <param name="<#= sourceName #>"><#= sourceComment #></param><#= typeMapDocs #><#= encodingDocs #>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param><#= ioOptsComment #>
    /// <param name="parallelOptions">
    /// Options to configure batch size, cancellation, and other parallelization settings.
    /// </param>
    /// <returns>
    /// An enumerable that parses unordered batches of <typeparam name="TValue"/> from the CSV data.
    /// The yielded batches <strong>must not</strong> be used after the enumeration continues or stops.
    /// </returns>
    <#= attrs #>public static <#= returnType #> Read<#= fileSuffix #><#= asyncSuffix #><<#= typeAttrs #>TValue>(
        <#= source #> <#= sourceName #>,<#= typeMapArg #><#= encodingArg #>
        CsvOptions<<#= generic #>>? options = null,<#= ioOptsArg #>
        CsvParallelOptions parallelOptions = default
    )
    {<#= validateSource #><#= validateTypeMap #><#= configureIoOpts #>
        return As<#= asyncSuffix #>EnumerableCore(
            ParallelReader.Create(<#= createArg #><#= encodingParam #>, options ?? CsvOptions<<#= generic #>>.Default<#= ioOptsParam #>),
            ValueProducer<<#= generic #>, TValue>.Create(<#= typeMapParam #>options, parallelOptions),
            parallelOptions
        );
    }

<#
    }
#>
}
