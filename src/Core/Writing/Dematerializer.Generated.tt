<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 24;
    var genericTypes = Enumerable.Range(0, TotalCount).Select(i => $"T{i}").ToArray();
    var converters = Enumerable.Range(0, TotalCount).Select(i => $"CsvConverter<T, T{i}> converter{i}").ToArray();
    var getters = Enumerable.Range(0, TotalCount).Select(i => $"Func<TValue, T{i}> getter{i}").ToArray();
#>
// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using FlameCsv.Binding;
using FlameCsv.Writing;

namespace FlameCsv.Writing;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal abstract partial class Dematerializer<T>
{
    /// <summary>
    /// Returns the constructor info for dematerializer of <typeparamref name="TValue"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the dematerializer</param>
    /// <typeparam name="TValue">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RequiresUnreferencedCode("Trimmed Dematerializer<...> implementations may not be available during runtime.")]
    [RequiresDynamicCode("MakeGenericType is called on Dematerializer<...>")]
    internal static ConstructorInfo GetConstructor<TValue>(ReadOnlySpan<MemberCsvBinding<TValue>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TValue);

        return (types.Length switch
        {
<#
    for (var i = 1; i <= TotalCount; i++)
    {
        Write("            ");
        Write((i + 2).ToString()); // T + generics# + TValue
        Write(" => typeof(Dematerializer<,,");

        for (var j = 1; j < i; j++)
        {
            Write(",");
        }

        WriteLine(">),");
    }
#>
            _ => throw new ArgumentException($"Unsupported type param count: {bindings.Length}"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

<#
    for (var current = 1; current <= TotalCount; current++)
    {
        var generics = string.Join(", ", genericTypes.Take(current)) + ", TValue";
#>
/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.ConverterFactories), RUF(Messages.ConverterFactories)]
internal sealed class Dematerializer<T, <#= generics #>>
    : Dematerializer<T, TValue>, IDematerializer<T, TValue> where T : unmanaged, IBinaryInteger<T>
{
    public int FieldCount => <#= current #>;

    public Dematerializer(
        CsvBindingCollection<TValue> bindingCollection,
        CsvOptions<T> options<#
        for (var i = 0; i < current; i++)
        {
            WriteLine(",");
            Write("        ");
            Write(getters[i]);
        }
#>)
        : base(bindingCollection)
    {
        ReadOnlySpan<MemberCsvBinding<TValue>> bindings = bindingCollection.MemberBindings;
<#
        for (var i = 0; i < current; i++)
        {
            var ix = i.ToString();
            Write("        this.converter");
            Write(ix);
            Write(" = ResolveConverter<");
            Write(genericTypes[i]);
            Write(">(options, bindings[");
            Write(ix);
            WriteLine("]);");
        }
#><#
        for (var i = 0; i < current; i++)
        {
            var ix = i.ToString();
            Write("        this.getter");
            Write(ix);
            Write(" = getter");
            Write(ix);
            WriteLine(";");
        }
#>    }

<#
        for (var i = 0; i < current; i++)
        {
            Write("    private readonly ");
            Write(converters[i]);
            WriteLine(";");
        }
#>
<#
        for (var i = 0; i < current; i++)
        {
            Write("    private readonly ");
            Write(getters[i]);
            WriteLine(";");
        }
#>

    public void Write(ref readonly CsvFieldWriter<T> writer, [AllowNull] TValue value)
    {
<#
        for (var i = 0; i < current; i++)
        {
            Write("        writer.WriteField(converter");
            Write(i.ToString());
            Write(", getter");
            Write(i.ToString());
            WriteLine("(value));");

            if (i != (current - 1))
            {
                WriteLine("        writer.WriteDelimiter();");
            }
        }
#>
    }
}

<#
    }
#>
