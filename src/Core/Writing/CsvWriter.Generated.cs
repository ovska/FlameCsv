// <auto-generated />
#nullable enable
using System.IO.Pipelines;
using System.Runtime.CompilerServices;
using System.Text;
using FlameCsv.Binding;
using FlameCsv.IO;
using FlameCsv.Writing;
using FlameCsv.Extensions;

namespace FlameCsv;

static partial class CsvWriter
{
    /// <summary>
    /// Writes the values as CSV records to a string using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="builder">Optional builder to write the CSV to.</param>
    /// <returns>
    /// <see cref="StringBuilder"/> containing the CSV (same instance as <paramref name="builder"/> if provided)
    /// </returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static StringBuilder WriteToString<[DAM(Messages.ReflectionBound)] TValue>(
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        StringBuilder? builder = null)
    {
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        builder ??= new();
        using var writer = CsvFieldWriter.Create(new StringWriter(builder), options);
        WriteCore(values, writer, dematerializer);
        return builder;
    }

    /// <summary>
    /// Writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static void WriteToFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        using FileStream stream = GetFileStream(path, isAsync: false, in ioOptions);

        using var writer = CsvFieldWriter.Create(stream, options);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static void WriteToFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: false, options.Allocator, ioOptions);
        using var writer = CsvFieldWriter.Create(fileWriter, options);

        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="TextWriter"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static void Write<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = CsvFieldWriter.Create(textWriter, options, in ioOptions);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="Stream"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static void Write<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = CsvFieldWriter.Create(stream, options, in ioOptions);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="TextWriter"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            using var writer = await CsvFieldWriter.CreateAsync(textWriter, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="Stream"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="PipeWriter"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="pipe">Pipe to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        PipeWriter pipe,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = await CsvFieldWriter.CreateAsync(pipe, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        FileStream stream = GetFileStream(path, isAsync: true, in ioOptions);

        await using (stream.ConfigureAwait(false))
        {
            using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: true, options.Allocator, ioOptions);

        using var writer = await CsvFieldWriter.CreateAsync(fileWriter, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }
    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="TextWriter"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        TextWriter textWriter,
        IAsyncEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

            using var writer = await CsvFieldWriter.CreateAsync(textWriter, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="Stream"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="PipeWriter"/> using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="pipe">Pipe to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteAsync<[DAM(Messages.ReflectionBound)] TValue>(
        PipeWriter pipe,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        using var writer = await CsvFieldWriter.CreateAsync(pipe, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        FileStream stream = GetFileStream(path, isAsync: true, in ioOptions);

        await using (stream.ConfigureAwait(false))
        {
            using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using <see cref="CsvOptions{T}.TypeBinder"/>.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static async Task WriteToFileAsync<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = options.TypeBinder.GetDematerializer<TValue>();

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: true, options.Allocator, ioOptions);

        using var writer = await CsvFieldWriter.CreateAsync(fileWriter, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }
    /// <summary>
    /// Writes the values as CSV records to a string using the type map.
    /// </summary>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="builder">Optional builder to write the CSV to.</param>
    /// <returns>
    /// <see cref="StringBuilder"/> containing the CSV (same instance as <paramref name="builder"/> if provided)
    /// </returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static StringBuilder WriteToString<TValue>(
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        StringBuilder? builder = null)
    {
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        builder ??= new();
        using var writer = CsvFieldWriter.Create(new StringWriter(builder), options);
        WriteCore(values, writer, dematerializer);
        return builder;
    }

    /// <summary>
    /// Writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static void WriteToFile<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        using FileStream stream = GetFileStream(path, isAsync: false, in ioOptions);

        using var writer = CsvFieldWriter.Create(stream, options);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static void WriteToFile<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: false, options.Allocator, ioOptions);
        using var writer = CsvFieldWriter.Create(fileWriter, options);

        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="TextWriter"/> using the type map.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static void Write<TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = CsvFieldWriter.Create(textWriter, options, in ioOptions);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Writes the values as CSV records to the <see cref="Stream"/> using the type map.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static void Write<TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = CsvFieldWriter.Create(stream, options, in ioOptions);
        WriteCore(values, writer, dematerializer);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="TextWriter"/> using the type map.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        TextWriter textWriter,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

            using var writer = await CsvFieldWriter.CreateAsync(textWriter, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="Stream"/> using the type map.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        Stream stream,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="PipeWriter"/> using the type map.
    /// </summary>
    /// <param name="pipe">Pipe to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        PipeWriter pipe,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = await CsvFieldWriter.CreateAsync(pipe, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        FileStream stream = GetFileStream(path, isAsync: true, in ioOptions);

        await using (stream.ConfigureAwait(false))
        {
            using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: true, options.Allocator, ioOptions);

        using var writer = await CsvFieldWriter.CreateAsync(fileWriter, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }
    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="TextWriter"/> using the type map.
    /// </summary>
    /// <param name="textWriter">Writer to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        TextWriter textWriter,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(textWriter);
        ArgumentNullException.ThrowIfNull(values);

        await using (textWriter.ConfigureAwait(false))
        {
            cancellationToken.ThrowIfCancellationRequested();

            options ??= CsvOptions<char>.Default;
            IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

            using var writer = await CsvFieldWriter.CreateAsync(textWriter, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="Stream"/> using the type map.
    /// </summary>
    /// <param name="stream">Stream to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        Stream stream,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        Guard.CanWrite(stream);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to the <see cref="PipeWriter"/> using the type map.
    /// </summary>
    /// <param name="pipe">Pipe to write the CSV to</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteAsync<TValue>(
        PipeWriter pipe,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(pipe);
        ArgumentNullException.ThrowIfNull(values);

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        using var writer = await CsvFieldWriter.CreateAsync(pipe, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<byte>.Default;
        IDematerializer<byte, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        FileStream stream = GetFileStream(path, isAsync: true, in ioOptions);

        await using (stream.ConfigureAwait(false))
        {
            using var writer = await CsvFieldWriter.CreateAsync(stream, options, ioOptions).ConfigureAwait(false);

            await WriteAsyncCore(
                values,
                writer,
                dematerializer,
                cancellationToken)
                .ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Asynchronously writes the values as CSV records to a file using the type map.
    /// </summary>
    /// <param name="path">Path of the destination file. Existing files are overwritten</param>
    /// <param name="values">Values to write</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to pass to the inner <see cref="StreamWriter"/></param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <param name="cancellationToken">Token to cancel the writing operation</param>
    /// <returns>Task representing the asynchronous writing operation</returns>
    /// <remarks>
    /// Data is written even if <paramref name="values"/> empty,
    /// either just the header or an empty line if <see cref="CsvOptions{T}.HasHeader"/> is <c>false</c>.
    /// </remarks>
    [OverloadResolutionPriority(-1)] // prefer byte to char when writing to file
    public static async Task WriteToFileAsync<TValue>(
        string path,
        IAsyncEnumerable<TValue> values,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(values);

        cancellationToken.ThrowIfCancellationRequested();

        options ??= CsvOptions<char>.Default;
        IDematerializer<char, TValue> dematerializer = typeMap.GetDematerializer(options);

        ioOptions = ioOptions.ForFileIO();
        ICsvBufferWriter<char> fileWriter = GetFileBufferWriter(path, encoding, isAsync: true, options.Allocator, ioOptions);

        using var writer = await CsvFieldWriter.CreateAsync(fileWriter, options).ConfigureAwait(false);

        await WriteAsyncCore(
            values,
            writer,
            dematerializer,
            cancellationToken)
            .ConfigureAwait(false);
    }
}
