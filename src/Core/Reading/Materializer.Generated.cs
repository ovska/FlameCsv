// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using FlameCsv.Binding;
using FlameCsv.Exceptions;

namespace FlameCsv.Reading;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            19 => typeof(Materializer<,,,,,,,,,,,,,,,,,,>),
            20 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,>),
            21 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,>),
            22 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,>),
            23 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,>),
            24 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,>),
            25 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,>),
            26 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,,>),
            _ => throw new NotSupportedException($"Unsupported type param count (max: 24, got: {types.Length - 2})"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
    }

    private readonly CsvConverter<T, T0> converter0;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 1) CsvReadException.ThrowForInvalidFieldCount(1, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        return _valueFactory(v0);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 2) CsvReadException.ThrowForInvalidFieldCount(2, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        return _valueFactory(v0, v1);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 3) CsvReadException.ThrowForInvalidFieldCount(3, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        return _valueFactory(v0, v1, v2);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 4) CsvReadException.ThrowForInvalidFieldCount(4, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        return _valueFactory(v0, v1, v2, v3);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 5) CsvReadException.ThrowForInvalidFieldCount(5, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        return _valueFactory(v0, v1, v2, v3, v4);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 6) CsvReadException.ThrowForInvalidFieldCount(6, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        return _valueFactory(v0, v1, v2, v3, v4, v5);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 7) CsvReadException.ThrowForInvalidFieldCount(7, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 8) CsvReadException.ThrowForInvalidFieldCount(8, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 9) CsvReadException.ThrowForInvalidFieldCount(9, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 10) CsvReadException.ThrowForInvalidFieldCount(10, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 11) CsvReadException.ThrowForInvalidFieldCount(11, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 12) CsvReadException.ThrowForInvalidFieldCount(12, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 13) CsvReadException.ThrowForInvalidFieldCount(13, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 14) CsvReadException.ThrowForInvalidFieldCount(14, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 15) CsvReadException.ThrowForInvalidFieldCount(15, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 16) CsvReadException.ThrowForInvalidFieldCount(16, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 17) CsvReadException.ThrowForInvalidFieldCount(17, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 18) CsvReadException.ThrowForInvalidFieldCount(18, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 19) CsvReadException.ThrowForInvalidFieldCount(19, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
        this.converter19 = ResolveConverter<T19>(bindings[19], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;
    private readonly CsvConverter<T, T19> converter19;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 20) CsvReadException.ThrowForInvalidFieldCount(20, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        if (!converter19.TryParse(record[19], out T19 v19)) CsvParseException.Throw(19, typeof(T19), converter19, GetName(19));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
        this.converter19 = ResolveConverter<T19>(bindings[19], options);
        this.converter20 = ResolveConverter<T20>(bindings[20], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;
    private readonly CsvConverter<T, T19> converter19;
    private readonly CsvConverter<T, T20> converter20;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 21) CsvReadException.ThrowForInvalidFieldCount(21, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        if (!converter19.TryParse(record[19], out T19 v19)) CsvParseException.Throw(19, typeof(T19), converter19, GetName(19));
        if (!converter20.TryParse(record[20], out T20 v20)) CsvParseException.Throw(20, typeof(T20), converter20, GetName(20));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
        this.converter19 = ResolveConverter<T19>(bindings[19], options);
        this.converter20 = ResolveConverter<T20>(bindings[20], options);
        this.converter21 = ResolveConverter<T21>(bindings[21], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;
    private readonly CsvConverter<T, T19> converter19;
    private readonly CsvConverter<T, T20> converter20;
    private readonly CsvConverter<T, T21> converter21;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 22) CsvReadException.ThrowForInvalidFieldCount(22, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        if (!converter19.TryParse(record[19], out T19 v19)) CsvParseException.Throw(19, typeof(T19), converter19, GetName(19));
        if (!converter20.TryParse(record[20], out T20 v20)) CsvParseException.Throw(20, typeof(T20), converter20, GetName(20));
        if (!converter21.TryParse(record[21], out T21 v21)) CsvParseException.Throw(21, typeof(T21), converter21, GetName(21));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
        this.converter19 = ResolveConverter<T19>(bindings[19], options);
        this.converter20 = ResolveConverter<T20>(bindings[20], options);
        this.converter21 = ResolveConverter<T21>(bindings[21], options);
        this.converter22 = ResolveConverter<T22>(bindings[22], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;
    private readonly CsvConverter<T, T19> converter19;
    private readonly CsvConverter<T, T20> converter20;
    private readonly CsvConverter<T, T21> converter21;
    private readonly CsvConverter<T, T22> converter22;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 23) CsvReadException.ThrowForInvalidFieldCount(23, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        if (!converter19.TryParse(record[19], out T19 v19)) CsvParseException.Throw(19, typeof(T19), converter19, GetName(19));
        if (!converter20.TryParse(record[20], out T20 v20)) CsvParseException.Throw(20, typeof(T20), converter20, GetName(20));
        if (!converter21.TryParse(record[21], out T21 v21)) CsvParseException.Throw(21, typeof(T21), converter21, GetName(21));
        if (!converter22.TryParse(record[22], out T22 v22)) CsvParseException.Throw(22, typeof(T22), converter22, GetName(22));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, TResult> : Materializer<T, TResult>, IMaterializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        this.converter0 = ResolveConverter<T0>(bindings[0], options);
        this.converter1 = ResolveConverter<T1>(bindings[1], options);
        this.converter2 = ResolveConverter<T2>(bindings[2], options);
        this.converter3 = ResolveConverter<T3>(bindings[3], options);
        this.converter4 = ResolveConverter<T4>(bindings[4], options);
        this.converter5 = ResolveConverter<T5>(bindings[5], options);
        this.converter6 = ResolveConverter<T6>(bindings[6], options);
        this.converter7 = ResolveConverter<T7>(bindings[7], options);
        this.converter8 = ResolveConverter<T8>(bindings[8], options);
        this.converter9 = ResolveConverter<T9>(bindings[9], options);
        this.converter10 = ResolveConverter<T10>(bindings[10], options);
        this.converter11 = ResolveConverter<T11>(bindings[11], options);
        this.converter12 = ResolveConverter<T12>(bindings[12], options);
        this.converter13 = ResolveConverter<T13>(bindings[13], options);
        this.converter14 = ResolveConverter<T14>(bindings[14], options);
        this.converter15 = ResolveConverter<T15>(bindings[15], options);
        this.converter16 = ResolveConverter<T16>(bindings[16], options);
        this.converter17 = ResolveConverter<T17>(bindings[17], options);
        this.converter18 = ResolveConverter<T18>(bindings[18], options);
        this.converter19 = ResolveConverter<T19>(bindings[19], options);
        this.converter20 = ResolveConverter<T20>(bindings[20], options);
        this.converter21 = ResolveConverter<T21>(bindings[21], options);
        this.converter22 = ResolveConverter<T22>(bindings[22], options);
        this.converter23 = ResolveConverter<T23>(bindings[23], options);
    }

    private readonly CsvConverter<T, T0> converter0;
    private readonly CsvConverter<T, T1> converter1;
    private readonly CsvConverter<T, T2> converter2;
    private readonly CsvConverter<T, T3> converter3;
    private readonly CsvConverter<T, T4> converter4;
    private readonly CsvConverter<T, T5> converter5;
    private readonly CsvConverter<T, T6> converter6;
    private readonly CsvConverter<T, T7> converter7;
    private readonly CsvConverter<T, T8> converter8;
    private readonly CsvConverter<T, T9> converter9;
    private readonly CsvConverter<T, T10> converter10;
    private readonly CsvConverter<T, T11> converter11;
    private readonly CsvConverter<T, T12> converter12;
    private readonly CsvConverter<T, T13> converter13;
    private readonly CsvConverter<T, T14> converter14;
    private readonly CsvConverter<T, T15> converter15;
    private readonly CsvConverter<T, T16> converter16;
    private readonly CsvConverter<T, T17> converter17;
    private readonly CsvConverter<T, T18> converter18;
    private readonly CsvConverter<T, T19> converter19;
    private readonly CsvConverter<T, T20> converter20;
    private readonly CsvConverter<T, T21> converter21;
    private readonly CsvConverter<T, T22> converter22;
    private readonly CsvConverter<T, T23> converter23;

    public TResult Parse<TRecord>(scoped ref readonly TRecord record) where TRecord : ICsvRecord<T>, allows ref struct
    {
        if (record.FieldCount != 24) CsvReadException.ThrowForInvalidFieldCount(24, record.FieldCount);
        if (!converter0.TryParse(record[0], out T0 v0)) CsvParseException.Throw(0, typeof(T0), converter0, GetName(0));
        if (!converter1.TryParse(record[1], out T1 v1)) CsvParseException.Throw(1, typeof(T1), converter1, GetName(1));
        if (!converter2.TryParse(record[2], out T2 v2)) CsvParseException.Throw(2, typeof(T2), converter2, GetName(2));
        if (!converter3.TryParse(record[3], out T3 v3)) CsvParseException.Throw(3, typeof(T3), converter3, GetName(3));
        if (!converter4.TryParse(record[4], out T4 v4)) CsvParseException.Throw(4, typeof(T4), converter4, GetName(4));
        if (!converter5.TryParse(record[5], out T5 v5)) CsvParseException.Throw(5, typeof(T5), converter5, GetName(5));
        if (!converter6.TryParse(record[6], out T6 v6)) CsvParseException.Throw(6, typeof(T6), converter6, GetName(6));
        if (!converter7.TryParse(record[7], out T7 v7)) CsvParseException.Throw(7, typeof(T7), converter7, GetName(7));
        if (!converter8.TryParse(record[8], out T8 v8)) CsvParseException.Throw(8, typeof(T8), converter8, GetName(8));
        if (!converter9.TryParse(record[9], out T9 v9)) CsvParseException.Throw(9, typeof(T9), converter9, GetName(9));
        if (!converter10.TryParse(record[10], out T10 v10)) CsvParseException.Throw(10, typeof(T10), converter10, GetName(10));
        if (!converter11.TryParse(record[11], out T11 v11)) CsvParseException.Throw(11, typeof(T11), converter11, GetName(11));
        if (!converter12.TryParse(record[12], out T12 v12)) CsvParseException.Throw(12, typeof(T12), converter12, GetName(12));
        if (!converter13.TryParse(record[13], out T13 v13)) CsvParseException.Throw(13, typeof(T13), converter13, GetName(13));
        if (!converter14.TryParse(record[14], out T14 v14)) CsvParseException.Throw(14, typeof(T14), converter14, GetName(14));
        if (!converter15.TryParse(record[15], out T15 v15)) CsvParseException.Throw(15, typeof(T15), converter15, GetName(15));
        if (!converter16.TryParse(record[16], out T16 v16)) CsvParseException.Throw(16, typeof(T16), converter16, GetName(16));
        if (!converter17.TryParse(record[17], out T17 v17)) CsvParseException.Throw(17, typeof(T17), converter17, GetName(17));
        if (!converter18.TryParse(record[18], out T18 v18)) CsvParseException.Throw(18, typeof(T18), converter18, GetName(18));
        if (!converter19.TryParse(record[19], out T19 v19)) CsvParseException.Throw(19, typeof(T19), converter19, GetName(19));
        if (!converter20.TryParse(record[20], out T20 v20)) CsvParseException.Throw(20, typeof(T20), converter20, GetName(20));
        if (!converter21.TryParse(record[21], out T21 v21)) CsvParseException.Throw(21, typeof(T21), converter21, GetName(21));
        if (!converter22.TryParse(record[22], out T22 v22)) CsvParseException.Throw(22, typeof(T22), converter22, GetName(22));
        if (!converter23.TryParse(record[23], out T23 v23)) CsvParseException.Throw(23, typeof(T23), converter23, GetName(23));
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);
    }
}

