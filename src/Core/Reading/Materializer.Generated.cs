// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using FlameCsv.Binding;
using FlameCsv.Exceptions;

namespace FlameCsv.Reading;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            19 => typeof(Materializer<,,,,,,,,,,,,,,,,,,>),
            20 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,>),
            21 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,>),
            22 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,>),
            23 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,>),
            24 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,>),
            25 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,>),
            26 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,,>),
            _ => throw new NotSupportedException($"Unsupported type param count (max: 24, got: {types.Length - 2})"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
    }

    private readonly CsvConverter<T, T0> _converter0;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 1) CsvReadException.ThrowForInvalidFieldCount(1, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        return _valueFactory(v0);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 2) CsvReadException.ThrowForInvalidFieldCount(2, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        return _valueFactory(v0, v1);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 3) CsvReadException.ThrowForInvalidFieldCount(3, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        return _valueFactory(v0, v1, v2);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 4) CsvReadException.ThrowForInvalidFieldCount(4, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        return _valueFactory(v0, v1, v2, v3);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 5) CsvReadException.ThrowForInvalidFieldCount(5, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 6) CsvReadException.ThrowForInvalidFieldCount(6, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 7) CsvReadException.ThrowForInvalidFieldCount(7, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 8) CsvReadException.ThrowForInvalidFieldCount(8, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 9) CsvReadException.ThrowForInvalidFieldCount(9, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 10) CsvReadException.ThrowForInvalidFieldCount(10, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 11) CsvReadException.ThrowForInvalidFieldCount(11, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 12) CsvReadException.ThrowForInvalidFieldCount(12, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 13) CsvReadException.ThrowForInvalidFieldCount(13, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 14) CsvReadException.ThrowForInvalidFieldCount(14, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 15) CsvReadException.ThrowForInvalidFieldCount(15, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 16) CsvReadException.ThrowForInvalidFieldCount(16, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 17) CsvReadException.ThrowForInvalidFieldCount(17, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 18) CsvReadException.ThrowForInvalidFieldCount(18, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 19) CsvReadException.ThrowForInvalidFieldCount(19, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 20) CsvReadException.ThrowForInvalidFieldCount(20, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        if (!_converter19.TryParse(record.GetFieldUnsafe(index = 19), out T19 v19)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 21) CsvReadException.ThrowForInvalidFieldCount(21, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        if (!_converter19.TryParse(record.GetFieldUnsafe(index = 19), out T19 v19)) goto Fail;
        if (!_converter20.TryParse(record.GetFieldUnsafe(index = 20), out T20 v20)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 22) CsvReadException.ThrowForInvalidFieldCount(22, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        if (!_converter19.TryParse(record.GetFieldUnsafe(index = 19), out T19 v19)) goto Fail;
        if (!_converter20.TryParse(record.GetFieldUnsafe(index = 20), out T20 v20)) goto Fail;
        if (!_converter21.TryParse(record.GetFieldUnsafe(index = 21), out T21 v21)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 23) CsvReadException.ThrowForInvalidFieldCount(23, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        if (!_converter19.TryParse(record.GetFieldUnsafe(index = 19), out T19 v19)) goto Fail;
        if (!_converter20.TryParse(record.GetFieldUnsafe(index = 20), out T20 v20)) goto Fail;
        if (!_converter21.TryParse(record.GetFieldUnsafe(index = 21), out T21 v21)) goto Fail;
        if (!_converter22.TryParse(record.GetFieldUnsafe(index = 22), out T22 v22)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
[SkipLocalsInit]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23);

    private readonly Factory _valueFactory;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        _valueFactory = valueFactory;
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
        _converter23 = ResolveConverter<T23>(bindings[23], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;
    private readonly CsvConverter<T, T23> _converter23;

    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != 24) CsvReadException.ThrowForInvalidFieldCount(24, record);
        if (!_converter0.TryParse(record.GetFieldUnsafe(index = 0), out T0 v0)) goto Fail;
        if (!_converter1.TryParse(record.GetFieldUnsafe(index = 1), out T1 v1)) goto Fail;
        if (!_converter2.TryParse(record.GetFieldUnsafe(index = 2), out T2 v2)) goto Fail;
        if (!_converter3.TryParse(record.GetFieldUnsafe(index = 3), out T3 v3)) goto Fail;
        if (!_converter4.TryParse(record.GetFieldUnsafe(index = 4), out T4 v4)) goto Fail;
        if (!_converter5.TryParse(record.GetFieldUnsafe(index = 5), out T5 v5)) goto Fail;
        if (!_converter6.TryParse(record.GetFieldUnsafe(index = 6), out T6 v6)) goto Fail;
        if (!_converter7.TryParse(record.GetFieldUnsafe(index = 7), out T7 v7)) goto Fail;
        if (!_converter8.TryParse(record.GetFieldUnsafe(index = 8), out T8 v8)) goto Fail;
        if (!_converter9.TryParse(record.GetFieldUnsafe(index = 9), out T9 v9)) goto Fail;
        if (!_converter10.TryParse(record.GetFieldUnsafe(index = 10), out T10 v10)) goto Fail;
        if (!_converter11.TryParse(record.GetFieldUnsafe(index = 11), out T11 v11)) goto Fail;
        if (!_converter12.TryParse(record.GetFieldUnsafe(index = 12), out T12 v12)) goto Fail;
        if (!_converter13.TryParse(record.GetFieldUnsafe(index = 13), out T13 v13)) goto Fail;
        if (!_converter14.TryParse(record.GetFieldUnsafe(index = 14), out T14 v14)) goto Fail;
        if (!_converter15.TryParse(record.GetFieldUnsafe(index = 15), out T15 v15)) goto Fail;
        if (!_converter16.TryParse(record.GetFieldUnsafe(index = 16), out T16 v16)) goto Fail;
        if (!_converter17.TryParse(record.GetFieldUnsafe(index = 17), out T17 v17)) goto Fail;
        if (!_converter18.TryParse(record.GetFieldUnsafe(index = 18), out T18 v18)) goto Fail;
        if (!_converter19.TryParse(record.GetFieldUnsafe(index = 19), out T19 v19)) goto Fail;
        if (!_converter20.TryParse(record.GetFieldUnsafe(index = 20), out T20 v20)) goto Fail;
        if (!_converter21.TryParse(record.GetFieldUnsafe(index = 21), out T21 v21)) goto Fail;
        if (!_converter22.TryParse(record.GetFieldUnsafe(index = 22), out T22 v22)) goto Fail;
        if (!_converter23.TryParse(record.GetFieldUnsafe(index = 23), out T23 v23)) goto Fail;
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        23 => (typeof(T23), _converter23),
        _ => base.GetExceptionMetadata(index),
    };
}

