// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using FlameCsv.Binding;
using FlameCsv.Exceptions;

namespace FlameCsv.Reading;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            19 => typeof(Materializer<,,,,,,,,,,,,,,,,,,>),
            20 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,>),
            21 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,>),
            22 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,>),
            23 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,>),
            24 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,>),
            25 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,>),
            26 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,,>),
            _ => throw new NotSupportedException($"Unsupported type param count (max: 24, got: {types.Length - 2})"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
    }

    private readonly CsvConverter<T, T0> _converter0;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 1) CsvReadException.ThrowForInvalidFieldCount(1, record);

        Unsafe.SkipInit(out T0 v0);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 2) CsvReadException.ThrowForInvalidFieldCount(2, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 3) CsvReadException.ThrowForInvalidFieldCount(3, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 4) CsvReadException.ThrowForInvalidFieldCount(4, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 5) CsvReadException.ThrowForInvalidFieldCount(5, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 6) CsvReadException.ThrowForInvalidFieldCount(6, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 7) CsvReadException.ThrowForInvalidFieldCount(7, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 8) CsvReadException.ThrowForInvalidFieldCount(8, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 9) CsvReadException.ThrowForInvalidFieldCount(9, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 10) CsvReadException.ThrowForInvalidFieldCount(10, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 11) CsvReadException.ThrowForInvalidFieldCount(11, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 12) CsvReadException.ThrowForInvalidFieldCount(12, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 13) CsvReadException.ThrowForInvalidFieldCount(13, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 14) CsvReadException.ThrowForInvalidFieldCount(14, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 15) CsvReadException.ThrowForInvalidFieldCount(15, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 16) CsvReadException.ThrowForInvalidFieldCount(16, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 17) CsvReadException.ThrowForInvalidFieldCount(17, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 18) CsvReadException.ThrowForInvalidFieldCount(18, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 19) CsvReadException.ThrowForInvalidFieldCount(19, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 20) CsvReadException.ThrowForInvalidFieldCount(20, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored))
        {
            bool result19 = _converter19.TryParse(record.GetFieldUnsafe(f19, f20), out v19);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result19) << 19);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 21) CsvReadException.ThrowForInvalidFieldCount(21, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored))
        {
            bool result19 = _converter19.TryParse(record.GetFieldUnsafe(f19, f20), out v19);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result19) << 19);
        }
        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored))
        {
            bool result20 = _converter20.TryParse(record.GetFieldUnsafe(f20, f21), out v20);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result20) << 20);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 22) CsvReadException.ThrowForInvalidFieldCount(22, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored))
        {
            bool result19 = _converter19.TryParse(record.GetFieldUnsafe(f19, f20), out v19);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result19) << 19);
        }
        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored))
        {
            bool result20 = _converter20.TryParse(record.GetFieldUnsafe(f20, f21), out v20);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result20) << 20);
        }
        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored))
        {
            bool result21 = _converter21.TryParse(record.GetFieldUnsafe(f21, f22), out v21);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result21) << 21);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 23) CsvReadException.ThrowForInvalidFieldCount(23, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21); Unsafe.SkipInit(out T22 v22);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored))
        {
            bool result19 = _converter19.TryParse(record.GetFieldUnsafe(f19, f20), out v19);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result19) << 19);
        }
        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored))
        {
            bool result20 = _converter20.TryParse(record.GetFieldUnsafe(f20, f21), out v20);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result20) << 20);
        }
        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored))
        {
            bool result21 = _converter21.TryParse(record.GetFieldUnsafe(f21, f22), out v21);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result21) << 21);
        }
        uint f23 = Unsafe.Add(ref fields, 22);
        if (typeof(T22) != typeof(CsvIgnored))
        {
            bool result22 = _converter22.TryParse(record.GetFieldUnsafe(f22, f23), out v22);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result22) << 22);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
        _converter23 = ResolveConverter<T23>(bindings[23], options);
    }

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;
    private readonly CsvConverter<T, T23> _converter23;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 24) CsvReadException.ThrowForInvalidFieldCount(24, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21); Unsafe.SkipInit(out T22 v22); Unsafe.SkipInit(out T23 v23);

        ref uint fields = ref MemoryMarshal.GetReference(record._fields);
        uint failureFlags = 0;

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored))
        {
            bool result0 = _converter0.TryParse(record.GetFieldUnsafe(f0, f1), out v0);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result0) << 0);
        }
        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored))
        {
            bool result1 = _converter1.TryParse(record.GetFieldUnsafe(f1, f2), out v1);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result1) << 1);
        }
        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored))
        {
            bool result2 = _converter2.TryParse(record.GetFieldUnsafe(f2, f3), out v2);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result2) << 2);
        }
        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored))
        {
            bool result3 = _converter3.TryParse(record.GetFieldUnsafe(f3, f4), out v3);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result3) << 3);
        }
        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored))
        {
            bool result4 = _converter4.TryParse(record.GetFieldUnsafe(f4, f5), out v4);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result4) << 4);
        }
        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored))
        {
            bool result5 = _converter5.TryParse(record.GetFieldUnsafe(f5, f6), out v5);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result5) << 5);
        }
        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored))
        {
            bool result6 = _converter6.TryParse(record.GetFieldUnsafe(f6, f7), out v6);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result6) << 6);
        }
        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored))
        {
            bool result7 = _converter7.TryParse(record.GetFieldUnsafe(f7, f8), out v7);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result7) << 7);
        }
        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored))
        {
            bool result8 = _converter8.TryParse(record.GetFieldUnsafe(f8, f9), out v8);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result8) << 8);
        }
        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored))
        {
            bool result9 = _converter9.TryParse(record.GetFieldUnsafe(f9, f10), out v9);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result9) << 9);
        }
        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored))
        {
            bool result10 = _converter10.TryParse(record.GetFieldUnsafe(f10, f11), out v10);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result10) << 10);
        }
        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored))
        {
            bool result11 = _converter11.TryParse(record.GetFieldUnsafe(f11, f12), out v11);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result11) << 11);
        }
        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored))
        {
            bool result12 = _converter12.TryParse(record.GetFieldUnsafe(f12, f13), out v12);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result12) << 12);
        }
        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored))
        {
            bool result13 = _converter13.TryParse(record.GetFieldUnsafe(f13, f14), out v13);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result13) << 13);
        }
        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored))
        {
            bool result14 = _converter14.TryParse(record.GetFieldUnsafe(f14, f15), out v14);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result14) << 14);
        }
        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored))
        {
            bool result15 = _converter15.TryParse(record.GetFieldUnsafe(f15, f16), out v15);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result15) << 15);
        }
        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored))
        {
            bool result16 = _converter16.TryParse(record.GetFieldUnsafe(f16, f17), out v16);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result16) << 16);
        }
        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored))
        {
            bool result17 = _converter17.TryParse(record.GetFieldUnsafe(f17, f18), out v17);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result17) << 17);
        }
        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored))
        {
            bool result18 = _converter18.TryParse(record.GetFieldUnsafe(f18, f19), out v18);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result18) << 18);
        }
        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored))
        {
            bool result19 = _converter19.TryParse(record.GetFieldUnsafe(f19, f20), out v19);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result19) << 19);
        }
        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored))
        {
            bool result20 = _converter20.TryParse(record.GetFieldUnsafe(f20, f21), out v20);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result20) << 20);
        }
        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored))
        {
            bool result21 = _converter21.TryParse(record.GetFieldUnsafe(f21, f22), out v21);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result21) << 21);
        }
        uint f23 = Unsafe.Add(ref fields, 22);
        if (typeof(T22) != typeof(CsvIgnored))
        {
            bool result22 = _converter22.TryParse(record.GetFieldUnsafe(f22, f23), out v22);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result22) << 22);
        }
        uint f24 = Unsafe.Add(ref fields, 23);
        if (typeof(T23) != typeof(CsvIgnored))
        {
            bool result23 = _converter23.TryParse(record.GetFieldUnsafe(f23, f24), out v23);
            failureFlags |= ((uint)Unsafe.BitCast<bool, byte>(!result23) << 23);
        }
        if (failureFlags != 0) ThrowParseException(failureFlags);
        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        23 => (typeof(T23), _converter23),
        _ => base.GetExceptionMetadata(index),
    };
}

