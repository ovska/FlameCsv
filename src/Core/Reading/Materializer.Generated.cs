// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using FlameCsv.Binding;
using FlameCsv.Exceptions;

namespace FlameCsv.Reading;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
            3 => typeof(Materializer<,,>),
            4 => typeof(Materializer<,,,>),
            5 => typeof(Materializer<,,,,>),
            6 => typeof(Materializer<,,,,,>),
            7 => typeof(Materializer<,,,,,,>),
            8 => typeof(Materializer<,,,,,,,>),
            9 => typeof(Materializer<,,,,,,,,>),
            10 => typeof(Materializer<,,,,,,,,,>),
            11 => typeof(Materializer<,,,,,,,,,,>),
            12 => typeof(Materializer<,,,,,,,,,,,>),
            13 => typeof(Materializer<,,,,,,,,,,,,>),
            14 => typeof(Materializer<,,,,,,,,,,,,,>),
            15 => typeof(Materializer<,,,,,,,,,,,,,,>),
            16 => typeof(Materializer<,,,,,,,,,,,,,,,>),
            17 => typeof(Materializer<,,,,,,,,,,,,,,,,>),
            18 => typeof(Materializer<,,,,,,,,,,,,,,,,,>),
            19 => typeof(Materializer<,,,,,,,,,,,,,,,,,,>),
            20 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,>),
            21 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,>),
            22 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,>),
            23 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,>),
            24 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,>),
            25 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,>),
            26 => typeof(Materializer<,,,,,,,,,,,,,,,,,,,,,,,,,>),
            _ => throw new NotSupportedException($"Unsupported type param count (max: 24, got: {types.Length - 2})"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
}

    private readonly CsvConverter<T, T0> _converter0;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 1) CsvReadException.ThrowForInvalidFieldCount(1, record);

        Unsafe.SkipInit(out T0 v0);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 2) CsvReadException.ThrowForInvalidFieldCount(2, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 3) CsvReadException.ThrowForInvalidFieldCount(3, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 4) CsvReadException.ThrowForInvalidFieldCount(4, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 5) CsvReadException.ThrowForInvalidFieldCount(5, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 6) CsvReadException.ThrowForInvalidFieldCount(6, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 7) CsvReadException.ThrowForInvalidFieldCount(7, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 8) CsvReadException.ThrowForInvalidFieldCount(8, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 9) CsvReadException.ThrowForInvalidFieldCount(9, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 10) CsvReadException.ThrowForInvalidFieldCount(10, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 11) CsvReadException.ThrowForInvalidFieldCount(11, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 12) CsvReadException.ThrowForInvalidFieldCount(12, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 13) CsvReadException.ThrowForInvalidFieldCount(13, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 14) CsvReadException.ThrowForInvalidFieldCount(14, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 15) CsvReadException.ThrowForInvalidFieldCount(15, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 16) CsvReadException.ThrowForInvalidFieldCount(16, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 17) CsvReadException.ThrowForInvalidFieldCount(17, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 18) CsvReadException.ThrowForInvalidFieldCount(18, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 19) CsvReadException.ThrowForInvalidFieldCount(19, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 20) CsvReadException.ThrowForInvalidFieldCount(20, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored) && !_converter19.TryParse(record.GetFieldUnsafe(ref data, f19, f20), out v19))
        { index = 19; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 21) CsvReadException.ThrowForInvalidFieldCount(21, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored) && !_converter19.TryParse(record.GetFieldUnsafe(ref data, f19, f20), out v19))
        { index = 19; goto Fail; }

        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored) && !_converter20.TryParse(record.GetFieldUnsafe(ref data, f20, f21), out v20))
        { index = 20; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 22) CsvReadException.ThrowForInvalidFieldCount(22, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored) && !_converter19.TryParse(record.GetFieldUnsafe(ref data, f19, f20), out v19))
        { index = 19; goto Fail; }

        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored) && !_converter20.TryParse(record.GetFieldUnsafe(ref data, f20, f21), out v20))
        { index = 20; goto Fail; }

        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored) && !_converter21.TryParse(record.GetFieldUnsafe(ref data, f21, f22), out v21))
        { index = 21; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 23) CsvReadException.ThrowForInvalidFieldCount(23, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21); Unsafe.SkipInit(out T22 v22);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored) && !_converter19.TryParse(record.GetFieldUnsafe(ref data, f19, f20), out v19))
        { index = 19; goto Fail; }

        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored) && !_converter20.TryParse(record.GetFieldUnsafe(ref data, f20, f21), out v20))
        { index = 20; goto Fail; }

        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored) && !_converter21.TryParse(record.GetFieldUnsafe(ref data, f21, f22), out v21))
        { index = 21; goto Fail; }

        uint f23 = Unsafe.Add(ref fields, 22);
        if (typeof(T22) != typeof(CsvIgnored) && !_converter22.TryParse(record.GetFieldUnsafe(ref data, f22, f23), out v22))
        { index = 22; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        _ => base.GetExceptionMetadata(index),
    };
}

/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, TResult> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(T0 v0, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
        _converter0 = ResolveConverter<T0>(bindings[0], options);
        _converter1 = ResolveConverter<T1>(bindings[1], options);
        _converter2 = ResolveConverter<T2>(bindings[2], options);
        _converter3 = ResolveConverter<T3>(bindings[3], options);
        _converter4 = ResolveConverter<T4>(bindings[4], options);
        _converter5 = ResolveConverter<T5>(bindings[5], options);
        _converter6 = ResolveConverter<T6>(bindings[6], options);
        _converter7 = ResolveConverter<T7>(bindings[7], options);
        _converter8 = ResolveConverter<T8>(bindings[8], options);
        _converter9 = ResolveConverter<T9>(bindings[9], options);
        _converter10 = ResolveConverter<T10>(bindings[10], options);
        _converter11 = ResolveConverter<T11>(bindings[11], options);
        _converter12 = ResolveConverter<T12>(bindings[12], options);
        _converter13 = ResolveConverter<T13>(bindings[13], options);
        _converter14 = ResolveConverter<T14>(bindings[14], options);
        _converter15 = ResolveConverter<T15>(bindings[15], options);
        _converter16 = ResolveConverter<T16>(bindings[16], options);
        _converter17 = ResolveConverter<T17>(bindings[17], options);
        _converter18 = ResolveConverter<T18>(bindings[18], options);
        _converter19 = ResolveConverter<T19>(bindings[19], options);
        _converter20 = ResolveConverter<T20>(bindings[20], options);
        _converter21 = ResolveConverter<T21>(bindings[21], options);
        _converter22 = ResolveConverter<T22>(bindings[22], options);
        _converter23 = ResolveConverter<T23>(bindings[23], options);
}

    private readonly CsvConverter<T, T0> _converter0;
    private readonly CsvConverter<T, T1> _converter1;
    private readonly CsvConverter<T, T2> _converter2;
    private readonly CsvConverter<T, T3> _converter3;
    private readonly CsvConverter<T, T4> _converter4;
    private readonly CsvConverter<T, T5> _converter5;
    private readonly CsvConverter<T, T6> _converter6;
    private readonly CsvConverter<T, T7> _converter7;
    private readonly CsvConverter<T, T8> _converter8;
    private readonly CsvConverter<T, T9> _converter9;
    private readonly CsvConverter<T, T10> _converter10;
    private readonly CsvConverter<T, T11> _converter11;
    private readonly CsvConverter<T, T12> _converter12;
    private readonly CsvConverter<T, T13> _converter13;
    private readonly CsvConverter<T, T14> _converter14;
    private readonly CsvConverter<T, T15> _converter15;
    private readonly CsvConverter<T, T16> _converter16;
    private readonly CsvConverter<T, T17> _converter17;
    private readonly CsvConverter<T, T18> _converter18;
    private readonly CsvConverter<T, T19> _converter19;
    private readonly CsvConverter<T, T20> _converter20;
    private readonly CsvConverter<T, T21> _converter21;
    private readonly CsvConverter<T, T22> _converter22;
    private readonly CsvConverter<T, T23> _converter23;

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        if (record.FieldCount != 24) CsvReadException.ThrowForInvalidFieldCount(24, record);

        Unsafe.SkipInit(out T0 v0); Unsafe.SkipInit(out T1 v1); Unsafe.SkipInit(out T2 v2); Unsafe.SkipInit(out T3 v3); Unsafe.SkipInit(out T4 v4); Unsafe.SkipInit(out T5 v5); Unsafe.SkipInit(out T6 v6); Unsafe.SkipInit(out T7 v7); Unsafe.SkipInit(out T8 v8); Unsafe.SkipInit(out T9 v9); Unsafe.SkipInit(out T10 v10); Unsafe.SkipInit(out T11 v11); Unsafe.SkipInit(out T12 v12); Unsafe.SkipInit(out T13 v13); Unsafe.SkipInit(out T14 v14); Unsafe.SkipInit(out T15 v15); Unsafe.SkipInit(out T16 v16); Unsafe.SkipInit(out T17 v17); Unsafe.SkipInit(out T18 v18); Unsafe.SkipInit(out T19 v19); Unsafe.SkipInit(out T20 v20); Unsafe.SkipInit(out T21 v21); Unsafe.SkipInit(out T22 v22); Unsafe.SkipInit(out T23 v23);

        int index;
        ref T data = ref record._data;
        ref uint fields = ref MemoryMarshal.GetReference(record._fields);

        uint f0 = Unsafe.Add(ref fields, -1);
        uint f1 = Unsafe.Add(ref fields, 0);
        if (typeof(T0) != typeof(CsvIgnored) && !_converter0.TryParse(record.GetFieldUnsafe(ref data, f0, f1), out v0))
        { index = 0; goto Fail; }

        uint f2 = Unsafe.Add(ref fields, 1);
        if (typeof(T1) != typeof(CsvIgnored) && !_converter1.TryParse(record.GetFieldUnsafe(ref data, f1, f2), out v1))
        { index = 1; goto Fail; }

        uint f3 = Unsafe.Add(ref fields, 2);
        if (typeof(T2) != typeof(CsvIgnored) && !_converter2.TryParse(record.GetFieldUnsafe(ref data, f2, f3), out v2))
        { index = 2; goto Fail; }

        uint f4 = Unsafe.Add(ref fields, 3);
        if (typeof(T3) != typeof(CsvIgnored) && !_converter3.TryParse(record.GetFieldUnsafe(ref data, f3, f4), out v3))
        { index = 3; goto Fail; }

        uint f5 = Unsafe.Add(ref fields, 4);
        if (typeof(T4) != typeof(CsvIgnored) && !_converter4.TryParse(record.GetFieldUnsafe(ref data, f4, f5), out v4))
        { index = 4; goto Fail; }

        uint f6 = Unsafe.Add(ref fields, 5);
        if (typeof(T5) != typeof(CsvIgnored) && !_converter5.TryParse(record.GetFieldUnsafe(ref data, f5, f6), out v5))
        { index = 5; goto Fail; }

        uint f7 = Unsafe.Add(ref fields, 6);
        if (typeof(T6) != typeof(CsvIgnored) && !_converter6.TryParse(record.GetFieldUnsafe(ref data, f6, f7), out v6))
        { index = 6; goto Fail; }

        uint f8 = Unsafe.Add(ref fields, 7);
        if (typeof(T7) != typeof(CsvIgnored) && !_converter7.TryParse(record.GetFieldUnsafe(ref data, f7, f8), out v7))
        { index = 7; goto Fail; }

        uint f9 = Unsafe.Add(ref fields, 8);
        if (typeof(T8) != typeof(CsvIgnored) && !_converter8.TryParse(record.GetFieldUnsafe(ref data, f8, f9), out v8))
        { index = 8; goto Fail; }

        uint f10 = Unsafe.Add(ref fields, 9);
        if (typeof(T9) != typeof(CsvIgnored) && !_converter9.TryParse(record.GetFieldUnsafe(ref data, f9, f10), out v9))
        { index = 9; goto Fail; }

        uint f11 = Unsafe.Add(ref fields, 10);
        if (typeof(T10) != typeof(CsvIgnored) && !_converter10.TryParse(record.GetFieldUnsafe(ref data, f10, f11), out v10))
        { index = 10; goto Fail; }

        uint f12 = Unsafe.Add(ref fields, 11);
        if (typeof(T11) != typeof(CsvIgnored) && !_converter11.TryParse(record.GetFieldUnsafe(ref data, f11, f12), out v11))
        { index = 11; goto Fail; }

        uint f13 = Unsafe.Add(ref fields, 12);
        if (typeof(T12) != typeof(CsvIgnored) && !_converter12.TryParse(record.GetFieldUnsafe(ref data, f12, f13), out v12))
        { index = 12; goto Fail; }

        uint f14 = Unsafe.Add(ref fields, 13);
        if (typeof(T13) != typeof(CsvIgnored) && !_converter13.TryParse(record.GetFieldUnsafe(ref data, f13, f14), out v13))
        { index = 13; goto Fail; }

        uint f15 = Unsafe.Add(ref fields, 14);
        if (typeof(T14) != typeof(CsvIgnored) && !_converter14.TryParse(record.GetFieldUnsafe(ref data, f14, f15), out v14))
        { index = 14; goto Fail; }

        uint f16 = Unsafe.Add(ref fields, 15);
        if (typeof(T15) != typeof(CsvIgnored) && !_converter15.TryParse(record.GetFieldUnsafe(ref data, f15, f16), out v15))
        { index = 15; goto Fail; }

        uint f17 = Unsafe.Add(ref fields, 16);
        if (typeof(T16) != typeof(CsvIgnored) && !_converter16.TryParse(record.GetFieldUnsafe(ref data, f16, f17), out v16))
        { index = 16; goto Fail; }

        uint f18 = Unsafe.Add(ref fields, 17);
        if (typeof(T17) != typeof(CsvIgnored) && !_converter17.TryParse(record.GetFieldUnsafe(ref data, f17, f18), out v17))
        { index = 17; goto Fail; }

        uint f19 = Unsafe.Add(ref fields, 18);
        if (typeof(T18) != typeof(CsvIgnored) && !_converter18.TryParse(record.GetFieldUnsafe(ref data, f18, f19), out v18))
        { index = 18; goto Fail; }

        uint f20 = Unsafe.Add(ref fields, 19);
        if (typeof(T19) != typeof(CsvIgnored) && !_converter19.TryParse(record.GetFieldUnsafe(ref data, f19, f20), out v19))
        { index = 19; goto Fail; }

        uint f21 = Unsafe.Add(ref fields, 20);
        if (typeof(T20) != typeof(CsvIgnored) && !_converter20.TryParse(record.GetFieldUnsafe(ref data, f20, f21), out v20))
        { index = 20; goto Fail; }

        uint f22 = Unsafe.Add(ref fields, 21);
        if (typeof(T21) != typeof(CsvIgnored) && !_converter21.TryParse(record.GetFieldUnsafe(ref data, f21, f22), out v21))
        { index = 21; goto Fail; }

        uint f23 = Unsafe.Add(ref fields, 22);
        if (typeof(T22) != typeof(CsvIgnored) && !_converter22.TryParse(record.GetFieldUnsafe(ref data, f22, f23), out v22))
        { index = 22; goto Fail; }

        uint f24 = Unsafe.Add(ref fields, 23);
        if (typeof(T23) != typeof(CsvIgnored) && !_converter23.TryParse(record.GetFieldUnsafe(ref data, f23, f24), out v23))
        { index = 23; goto Fail; }

        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);
        return _valueFactory(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23);

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
        0 => (typeof(T0), _converter0),
        1 => (typeof(T1), _converter1),
        2 => (typeof(T2), _converter2),
        3 => (typeof(T3), _converter3),
        4 => (typeof(T4), _converter4),
        5 => (typeof(T5), _converter5),
        6 => (typeof(T6), _converter6),
        7 => (typeof(T7), _converter7),
        8 => (typeof(T8), _converter8),
        9 => (typeof(T9), _converter9),
        10 => (typeof(T10), _converter10),
        11 => (typeof(T11), _converter11),
        12 => (typeof(T12), _converter12),
        13 => (typeof(T13), _converter13),
        14 => (typeof(T14), _converter14),
        15 => (typeof(T15), _converter15),
        16 => (typeof(T16), _converter16),
        17 => (typeof(T17), _converter17),
        18 => (typeof(T18), _converter18),
        19 => (typeof(T19), _converter19),
        20 => (typeof(T20), _converter20),
        21 => (typeof(T21), _converter21),
        22 => (typeof(T22), _converter22),
        23 => (typeof(T23), _converter23),
        _ => base.GetExceptionMetadata(index),
    };
}

