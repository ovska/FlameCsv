<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    // Max supported generics
    const int TotalCount = 24;
    var genericTypes = Enumerable.Range(0, TotalCount).Select(i => $"T{i}").ToArray();
    var values = Enumerable.Range(0, TotalCount).Select(i => $"v{i}").ToArray();
#>
// <auto-generated />
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using FlameCsv.Binding;
using FlameCsv.Exceptions;

namespace FlameCsv.Reading;

[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal static class Materializer<T>
{
    /// <summary>
    /// Returns the constructor info for materializer of <typeparamref name="TResult"/>.
    /// </summary>
    /// <param name="bindings">Bindings of the collection used to create the materializer</param>
    /// <typeparam name="TResult">Type of the object/struct being read</typeparam>
    [ExcludeFromCodeCoverage]
    [RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
    internal static ConstructorInfo GetConstructor<TResult>(ReadOnlySpan<CsvBinding<TResult>> bindings)
    {
        Type[] types = new Type[bindings.Length + 2];

        for (int i = 0; i < bindings.Length; i++)
        {
            types[i + 1] = bindings[i].Type;
        }

        types[0] = typeof(T);
        types[^1] = typeof(TResult);

        return (types.Length switch
        {
<#
    for (var i = 1; i <= TotalCount; i++)
    {
        Write("            ");
        Write((i + 2).ToString()); // T + generics# + TResult
        Write(" => typeof(Materializer<,,");

        for (var j = 1; j < i; j++)
        {
            Write(",");
        }

        WriteLine(">),");
    }
#>
            _ => throw new NotSupportedException($"Unsupported type param count (max: <#= TotalCount #>, got: {types.Length - 2})"),
        }).MakeGenericType(types).GetConstructors()[0];
    }
}

<#
    for (var current = 1; current <= TotalCount; current++)
    {
        var generics = string.Join(", ", genericTypes.Take(current)) + ", TResult";
#>
/// <inheritdoc />
[ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
[RDC(Messages.DynamicCode), RUF(Messages.Reflection)]
internal sealed class Materializer<T, <#= generics #>> : Materializer<T, TResult> where T : unmanaged, IBinaryInteger<T>
{
    public delegate TResult Factory(<#
        for (var i = 0; i < current; i++)
        {
            Write(genericTypes[i]);
            Write(" v");
            Write(i.ToString());
            if (i != current - 1)
                Write(", ");
        }
    #>);

    private readonly Factory _valueFactory;
    private readonly int[] _ignoredIndexes;

    public Materializer(Factory valueFactory, CsvBindingCollection<TResult> bindingCollection, CsvOptions<T> options) : base(bindingCollection)
    {
        ReadOnlySpan<CsvBinding<TResult>> bindings = bindingCollection.Bindings;
        _valueFactory = valueFactory;
        _ignoredIndexes = GetIgnoredIndexes(bindings, options);
<#
        for (var i = 0; i < current; i++)
        {
            var ix = i.ToString();
            Write("        _converter");
            Write(ix);
            Write(" = ResolveConverter<");
            Write(genericTypes[i]);
            Write(">(bindings[");
            Write(ix);
            WriteLine("], options);");
        }
#>
}

<#
        for (var i = 0; i < current; i++)
        {
            WriteLine($"    private readonly CsvConverter<T, T{i}> _converter{i};");
        }
#>

    [SkipLocalsInit]
    public override TResult Parse(CsvRecordRef<T> record)
    {
        int index;
        if (record.FieldCount != <#= current #>) CsvReadException.ThrowForInvalidFieldCount(<#= current #>, record);
<#
        for (var i = 0; i < current; i++)
        {
            Write("        if (!_converter");
            Write(i.ToString());
            Write(".TryParse(record.GetFieldUnsafe(index = ");
            Write(i.ToString());
            Write("), out ");
            Write(genericTypes[i]);
            Write(" ");
            Write(values[i]);
            WriteLine(")) goto Fail;");
        }
        
        WriteLine("        if (_ignoredIndexes is not null) record.ValidateFieldsUnsafe(_ignoredIndexes);");

        Write("        return _valueFactory(");
        for (var i = 0; i < current; i++)
        {
            if (i != 0)
                Write(", ");
            Write(values[i]);
        }
        WriteLine(");");
#>

        Fail:
        return ThrowParseException(index);
    }

    protected override (Type type, object converter) GetExceptionMetadata(int index) => index switch
    {
<#
        for (var i = 0; i < current; i++)
        {
            Write("        ");
            Write(i.ToString());
            Write(" => (typeof(");
            Write(genericTypes[i]);
            Write("), _converter");
            Write(i.ToString());
            WriteLine("),");
        }
#>
        _ => base.GetExceptionMetadata(index),
    };
}

<#
    }
#>
