<#@ template language="C#" #>
// <auto-generated />
#nullable enable
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Text;
using FlameCsv.Binding;
using FlameCsv.Enumeration;
using FlameCsv.Extensions;
using FlameCsv.IO;

namespace FlameCsv;

static partial class CsvReader
{
<#
    const string docSource = "<param name=\"csv\">CSV data to read</param>";
    const string docStream = "<param name=\"stream\">Stream to read the CSV data from</param>";
    const string docTextReader = "<param name=\"reader\">TextReader to read the CSV data from</param>";
    const string docPath = "<param name=\"path\">Path of the source file</param>";
    const string docOptions = "<param name=\"options\">Options to use, <see cref=\"CsvOptions{T}.Default\"/> used by default</param>";
    const string docIOOpts = "<param name=\"ioOptions\">Options to configure the buffer size and other IO related options</param>";
    const string docEncoding = "<param name=\"encoding\">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>";
    const string docEnumerateRemarks =
        """
        <remarks>
            /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
            /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
            /// Improper use will throw a runtime exception.
            /// </remarks>
        """;
    const string docEnumerateReturns =
        """
        <returns>
            /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
            /// </returns>
        """;
    const string docReadReturns =
        """
        <returns>
            /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
            /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
            /// </returns>
        """;

    (string source, string type)[] dataSources =
    [
        ("string?", "char"),
        ("StringBuilder?", "char"),
        ("ReadOnlyMemory<char>", "char"),
        ("in ReadOnlySequence<char>", "char"),
        ("ReadOnlyMemory<byte>", "byte"),
        ("in ReadOnlySequence<byte>", "byte"),
    ];

    foreach (var sourceGen in (bool[])[false, true])
    {
        string enumerable = sourceGen
            ? "CsvTypeMapEnumerable"
            : "CsvValueEnumerable";

        string docSuffix = sourceGen
            ? " using the type map"
            : " using reflection";

        string attrs = sourceGen
            ? ""
            : "[RUF(Messages.Reflection), RDC(Messages.DynamicCode)]\n    ";

        string typeAttrs = sourceGen
            ? ""
            : "[DAM(Messages.ReflectionBound)] ";

        string typeMapByte = sourceGen
            ? "\r\n        CsvTypeMap<byte, TValue> typeMap,"
            : "";

        string typeMapChar = sourceGen
            ? "\r\n        CsvTypeMap<char, TValue> typeMap,"
            : "";

        string validateTypeMap = sourceGen
            ? "\r\n        ArgumentNullException.ThrowIfNull(typeMap);"
            : "";

        string typeMapArg = sourceGen ? ", typeMap" : "";

        string typeMapDocs = sourceGen
            ? "\r\n    /// <param name=\"typeMap\">Type map used to bind the CSV data</param>"
            : "";
#>

#region Parse (<#= sourceGen ? "sourcegen" : "reflection" #>)

    /// <summary>
    /// Parses CSV records from the CSV data<#= docSuffix #>.
    /// </summary>
    /// <#= docTextReader #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docReadReturns #>
    <#= attrs #>public static <#= enumerable #><char, TValue> Read<<#= typeAttrs #>TValue>(
        TextReader reader,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(reader);<#= validateTypeMap #>
        options ??= CsvOptions<char>.Default;
        return new <#= enumerable #><char, TValue>(CsvBufferReader.Create(reader, options.Allocator, ioOptions), options<#= typeMapArg #>);
    }

    /// <summary>
    /// Parses CSV records from the CSV data<#= docSuffix #> and the specified encoding.
    /// </summary>
    /// <#= docStream #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docIOOpts #>
    /// <#= docReadReturns #>
    <#= attrs #>public static <#= enumerable #><char, TValue> Read<<#= typeAttrs #>TValue>(
        Stream stream,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);<#= validateTypeMap #>
        options ??= CsvOptions<char>.Default;
        return new <#= enumerable #><char, TValue>(CsvBufferReader.Create(stream, encoding, options.Allocator, ioOptions), options<#= typeMapArg #>);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data<#= docSuffix #>.
    /// </summary>
    /// <#= docStream #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docReadReturns #>
    [OverloadResolutionPriority(1000)] // prefer byte overload for stream
    <#= attrs #>public static <#= enumerable #><byte, TValue> Read<<#= typeAttrs #>TValue>(
        Stream stream,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);<#= validateTypeMap #>
        options ??= CsvOptions<byte>.Default;
        return new <#= enumerable #><byte, TValue>(CsvBufferReader.Create(stream, options.Allocator, ioOptions), options<#= typeMapArg #>);
    }

    /// <summary>
    /// Parses CSV records from the specified file<#= docSuffix #> and the specified encoding.
    /// </summary>
    /// <#= docPath #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docIOOpts #>
    /// <#= docReadReturns #>
    <#= attrs #>public static <#= enumerable #><char, TValue> ReadFromFile<<#= typeAttrs #>TValue>(
        string path,<#= typeMapChar #>
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<char>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new <#= enumerable #><char, TValue>(
            new ReaderFactory<char>(isAsync => GetFileBufferReader(path, encoding, isAsync, options.Allocator, ioOptions)),
            options<#= typeMapArg #>);
    }
    
    /// <summary>
    /// Parses CSV records from the specified file<#= docSuffix #>.
    /// </summary>
    /// <#= docPath #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docReadReturns #>
    <#= attrs #>public static <#= enumerable #><byte, TValue> ReadFromFile<<#= typeAttrs #>TValue>(
        string path,<#= typeMapByte #>
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<byte>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new <#= enumerable #><byte, TValue>(
            new ReaderFactory<byte>(isAsync => GetFileBufferReader(path, isAsync, options.Allocator, ioOptions)),
            options<#= typeMapArg #>);
    }

<#
    foreach ((string source, string type) in dataSources)
    {
        string dataPrefix = type == "byte" ? "UTF8 " : "";
#>
    /// <summary>
    /// Parses CSV records from the <#= dataPrefix #>CSV data.
    /// </summary>
    /// <#= docSource #><#= typeMapDocs #>
    /// <#= docOptions #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    <#= attrs #>public static <#= enumerable #><<#= type #>, TValue> Read<<#= typeAttrs #>TValue>(
        <#= source #> csv,<#= type == "byte" ? typeMapByte : typeMapChar #>
        CsvOptions<<#= type #>>? options = null)
    {<#= validateTypeMap #>
        return new <#= enumerable #><<#= type #>, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<<#= type #>>.Default<#= typeMapArg #>);
    }

<#
    }
#>
#endregion // Parse (<#= sourceGen ? "sourcegen" : "reflection" #>)
<#
    }
#>

#region Enumerate

    /// <summary>
    /// Reads CSV records from the specified file using the specified encoding.
    /// </summary>
    /// <#= docPath #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docIOOpts #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    public static CsvRecordEnumerable<char> EnumerateFromFile(
        string path,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<char>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvRecordEnumerable<char>(
            new ReaderFactory<char>(isAsync => GetFileBufferReader(path, encoding, isAsync, options.Allocator, ioOptions)),
            options);
    }
    
    /// <summary>
    /// Reads CSV records from the specified file.
    /// </summary>
    /// <#= docPath #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    [OverloadResolutionPriority(1000)] // prefer byte overload for file
    public static CsvRecordEnumerable<byte> EnumerateFromFile(
        string path,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<byte>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvRecordEnumerable<byte>(
            new ReaderFactory<byte>(isAsync => GetFileBufferReader(path, isAsync, options.Allocator, ioOptions)),
            options);
    }

<#
    foreach ((string source, string type) in dataSources)
    {
        string dataPrefix = type == "byte" ? "UTF8 " : "";
#>
    /// <summary>
    /// Reads CSV records from the <#= dataPrefix #>CSV data.
    /// </summary>
    /// <#= docSource #>
    /// <#= docOptions #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    public static CsvRecordEnumerable<<#= type #>> Enumerate(<#= source #> csv, CsvOptions<<#= type #>>? options = null)
    {
        return new CsvRecordEnumerable<<#= type #>>(CsvBufferReader.Create(csv), options ?? CsvOptions<<#= type #>>.Default);
    }

<#
    }
#>
    /// <summary>
    /// Reads CSV records from the text reader.
    /// </summary>
    /// <#= docTextReader #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    public static CsvRecordEnumerable<char> Enumerate(
        TextReader reader,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(reader);
        return new CsvRecordEnumerable<char>(
            CsvBufferReader.Create(reader, options?.Allocator, ioOptions),
            options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the stream using the specified encoding.
    /// </summary>
    /// <#= docStream #>
    /// <#= docOptions #>
    /// <#= docEncoding #>
    /// <#= docIOOpts #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    public static CsvRecordEnumerable<char> Enumerate(
        Stream stream,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        return new CsvRecordEnumerable<char>(
            CsvBufferReader.Create(stream, encoding, options?.Allocator, ioOptions),
            options ?? CsvOptions<char>.Default);
    }
    
    /// <summary>
    /// Reads CSV records from the UTF8 stream.
    /// </summary>
    /// <#= docStream #>
    /// <#= docOptions #>
    /// <#= docIOOpts #>
    /// <#= docEnumerateRemarks #>
    /// <#= docEnumerateReturns #>
    [OverloadResolutionPriority(1000)] // prefer byte overload for stream
    public static CsvRecordEnumerable<byte> Enumerate(
        Stream stream,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        return new CsvRecordEnumerable<byte>(
            CsvBufferReader.Create(stream, options?.Allocator, ioOptions),
            options ?? CsvOptions<byte>.Default);
    }

#endregion // Enumerate
}
