// <auto-generated />
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.Wasm;
using System.Runtime.Intrinsics.X86;
using System.Text;

#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value

namespace FlameCsv.Intrinsics;

/// <summary>Generic type wrapping a byte vector.</summary>
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal interface ISimdVector<T, TVector>
    where T : unmanaged, IBinaryInteger<T>
    where TVector : struct, ISimdVector<T, TVector>
{
    /// <summary>
    /// Returns <c>true</c> if the vector type is hardware accelerated (on release configuration).
    /// </summary>
    static abstract bool IsSupported { get; }

    /// <summary>
    /// Returns the number of bytes in the vector.
    /// </summary>
    static abstract int Count { get; }

    /// <summary>
    /// Returns a vector with all elements set to zero.
    /// </summary>
    static abstract TVector Zero { get; }

    /// <summary>
    /// Returns an equality vector of the two input vectors.
    /// </summary>
    static abstract TVector Equals(TVector left, TVector right);

    /// <summary>
    /// Creates a vector with all elements set to the specified value.
    /// </summary>
    static abstract TVector Create(T value);
    
    /// <summary>
    /// Creates a vector with all elements set to the specified value.
    /// </summary>
    static abstract TVector Create([ConstantExpected(Min = (byte)'\n', Max = (byte)'\r')] byte value);

    /// <summary>
    /// Loads a vector from the specified address.
    /// </summary>
    static abstract TVector LoadUnaligned(ref readonly T source, nuint offset);

    /// <summary>
    /// Returns a bitwise OR of the two input vectors.
    /// </summary>
    static abstract TVector operator |(TVector left, TVector right);

    /// <summary>
    /// Returns <c>true</c> if the two vectors are equal; otherwise, <c>false</c>.
    /// </summary>
    static abstract bool operator ==(TVector left, TVector right);

    /// <summary>
    /// Returns <c>true</c> if the two vectors are not equal; otherwise, <c>false</c>.
    /// </summary>
    static abstract bool operator !=(TVector left, TVector right);

    /// <summary>
    /// Creates a bitmask of the vector.
    /// </summary>
    [JetBrains.Annotations.Pure] nuint ExtractMostSignificantBits();

    /// <summary>
    /// Returns the bytes of the vector allocated to a new array.
    /// </summary>
    [JetBrains.Annotations.Pure] byte[] ToArray();
}


[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec128Char : ISimdVector<char, Vec128Char>
{
    private readonly Vector128<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128<byte>.Count;
    }

    public static Vec128Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Char Equals(Vec128Char left, Vec128Char right) => Vector128.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Char Create(char value)
    {
        Debug.Assert(value < 128);
        return Vector128.Create(unchecked((byte)value));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Char Create([ConstantExpected] byte value)
    {
        Debug.Assert(value < 128);
        return Vector128.Create(value);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Char LoadUnaligned(ref readonly char source, nuint offset)
    {
        if (Avx512BW.VL.IsSupported)
        {
            var v = Vector256.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset);
            return Avx512BW.VL.ConvertToVector128ByteWithSaturation(v);
        }

        var v0 = Vector128.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset);
        var v1 = Vector128.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset + ((nuint)Vector128<byte>.Count / sizeof(ushort)));

        // prefer architecture specific intrinsic as they don't perform additional AND like Vector128.Narrow does
        if (Sse2.IsSupported)
        {
            return Sse2.PackUnsignedSaturate(v0.AsInt16(), v1.AsInt16());
        }
        else if (AdvSimd.IsSupported)
        {
            var lower = AdvSimd.ExtractNarrowingSaturateUnsignedLower(v0.AsInt16());
            var upper = AdvSimd.ExtractNarrowingSaturateUnsignedLower(v1.AsInt16());
            return Vector128.Create(lower, upper);
        }
        else if (PackedSimd.IsSupported)
        {
            return PackedSimd.ConvertNarrowingSaturateUnsigned(v0.AsInt16(), v1.AsInt16());
        }
        else
        {
            var lower = Vector128.Min(v0, Vector128.Create((ushort)127));
            var upper = Vector128.Min(v1, Vector128.Create((ushort)127));
            return Vector128.Narrow(lower, upper);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(uint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Char operator |(Vec128Char left, Vec128Char right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec128Char left, Vec128Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec128Char left, Vec128Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec128Char(Vector128<byte> value) => Unsafe.As<Vector128<byte>, Vec128Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector128<byte>(Vec128Char value) => Unsafe.As<Vec128Char, Vector128<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec256Char : ISimdVector<char, Vec256Char>
{
    private readonly Vector256<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256<byte>.Count;
    }

    public static Vec256Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Char Equals(Vec256Char left, Vec256Char right) => Vector256.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Char Create(char value)
    {
        Debug.Assert(value < 128);
        return Vector256.Create(unchecked((byte)value));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Char Create([ConstantExpected] byte value)
    {
        Debug.Assert(value < 128);
        return Vector256.Create(value);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Char LoadUnaligned(ref readonly char source, nuint offset)
    {
        if (Avx512BW.IsSupported)
        {
            var v = Vector512.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset);
            return Avx512BW.ConvertToVector256ByteWithSaturation(v);
        }

        var v0 = Vector256.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset);
        var v1 = Vector256.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset + ((nuint)Vector256<byte>.Count / sizeof(ushort)));

        if (Avx2.IsSupported)
        {
            // Avx2.PackUnsignedSaturate(Vector256.Create((short)1), Vector256.Create((short)2)) will result in
            // 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2
            // We want to swap the X and Y bits
            // 1, 1, 1, 1, 1, 1, 1, 1, X, X, X, X, X, X, X, X, Y, Y, Y, Y, Y, Y, Y, Y, 2, 2, 2, 2, 2, 2, 2, 2
            var packed = Avx2.PackUnsignedSaturate(v0.AsInt16(), v1.AsInt16());
            return Avx2.Permute4x64(packed.AsInt64(), 0b_11_01_10_00).AsByte();
        }
        else
        {
            var lower = Vector256.Min(v0, Vector256.Create((ushort)127));
            var upper = Vector256.Min(v1, Vector256.Create((ushort)127));
            return Vector256.Narrow(lower, upper);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(uint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Char operator |(Vec256Char left, Vec256Char right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec256Char left, Vec256Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec256Char left, Vec256Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec256Char(Vector256<byte> value) => Unsafe.As<Vector256<byte>, Vec256Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector256<byte>(Vec256Char value) => Unsafe.As<Vec256Char, Vector256<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec512Char : ISimdVector<char, Vec512Char>
{
    private readonly Vector512<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512<byte>.Count;
    }

    public static Vec512Char Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Char Equals(Vec512Char left, Vec512Char right) => Vector512.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Char Create(char value)
    {
        Debug.Assert(value < 128);
        return Vector512.Create(unchecked((byte)value));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Char Create([ConstantExpected] byte value)
    {
        Debug.Assert(value < 128);
        return Vector512.Create(value);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Char LoadUnaligned(ref readonly char source, nuint offset)
    {
        var v0 = Vector512.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset);
        var v1 = Vector512.LoadUnsafe(ref Unsafe.As<char, ushort>(ref Unsafe.AsRef(in source)), offset + ((nuint)Vector512<byte>.Count / sizeof(ushort)));

       if (Avx512BW.IsSupported && Avx512F.IsSupported)
       {
          var packed = Avx512BW.PackUnsignedSaturate(v0.AsInt16(), v1.AsInt16());

          // Avx512BW.PackUnsignedSaturate will interleave the inputs in 8-byte blocks.
          // We want to preserve the order of the two input vectors, so we deinterleave the packed value.
          return Avx512F.PermuteVar8x64(packed.AsInt64(), Vector512.Create(0, 2, 4, 6, 1, 3, 5, 7)).AsByte();
       }
       else
       {
           var lower = Vector512.Min(v0, Vector512.Create((ushort)127));
           var upper = Vector512.Min(v1, Vector512.Create((ushort)127));
           return Vector512.Narrow(lower, upper);
       }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(ulong)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Char operator |(Vec512Char left, Vec512Char right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec512Char left, Vec512Char right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec512Char left, Vec512Char right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec512Char(Vector512<byte> value) => Unsafe.As<Vector512<byte>, Vec512Char>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector512<byte>(Vec512Char value) => Unsafe.As<Vec512Char, Vector512<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec128Byte : ISimdVector<byte, Vec128Byte>
{
    private readonly Vector128<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128<byte>.Count;
    }

    public static Vec128Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector128<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Byte Equals(Vec128Byte left, Vec128Byte right) => Vector128.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Byte Create(byte value)
    {
        Debug.Assert(value < 128);
        return Vector128.Create(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Byte LoadUnaligned(ref readonly byte source, nuint offset) => Vector128.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(uint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec128Byte operator |(Vec128Byte left, Vec128Byte right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec128Byte left, Vec128Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec128Byte left, Vec128Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec128Byte(Vector128<byte> value) => Unsafe.As<Vector128<byte>, Vec128Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector128<byte>(Vec128Byte value) => Unsafe.As<Vec128Byte, Vector128<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec256Byte : ISimdVector<byte, Vec256Byte>
{
    private readonly Vector256<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256<byte>.Count;
    }

    public static Vec256Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector256<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Byte Equals(Vec256Byte left, Vec256Byte right) => Vector256.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Byte Create(byte value)
    {
        Debug.Assert(value < 128);
        return Vector256.Create(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Byte LoadUnaligned(ref readonly byte source, nuint offset) => Vector256.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(uint)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec256Byte operator |(Vec256Byte left, Vec256Byte right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec256Byte left, Vec256Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec256Byte left, Vec256Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec256Byte(Vector256<byte> value) => Unsafe.As<Vector256<byte>, Vec256Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector256<byte>(Vec256Byte value) => Unsafe.As<Vec256Byte, Vector256<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

[SkipLocalsInit]
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[System.CodeDom.Compiler.GeneratedCode(Messages.T4Template, null)]
internal readonly struct Vec512Byte : ISimdVector<byte, Vec512Byte>
{
    private readonly Vector512<byte> _value;

    public static bool IsSupported
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512.IsHardwareAccelerated;
    }

    public static int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512<byte>.Count;
    }

    public static Vec512Byte Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
        get => Vector512<byte>.Zero;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Byte Equals(Vec512Byte left, Vec512Byte right) => Vector512.Equals(left._value, right._value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Byte Create(byte value)
    {
        Debug.Assert(value < 128);
        return Vector512.Create(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Byte LoadUnaligned(ref readonly byte source, nuint offset) => Vector512.LoadUnsafe(in source, offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public nuint ExtractMostSignificantBits() => (nuint)(ulong)_value.ExtractMostSignificantBits();

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static Vec512Byte operator |(Vec512Byte left, Vec512Byte right) => left._value | right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator ==(Vec512Byte left, Vec512Byte right) => left._value == right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static bool operator !=(Vec512Byte left, Vec512Byte right) => left._value != right._value;

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static implicit operator Vec512Byte(Vector512<byte> value) => Unsafe.As<Vector512<byte>, Vec512Byte>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public static explicit operator Vector512<byte>(Vec512Byte value) => Unsafe.As<Vec512Byte, Vector512<byte>>(ref value);

    [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerStepThrough]
    public byte[] ToArray()
    {
        byte[] values = new byte[Count];
        _value.CopyTo(values);
        return values;
    }

    public override string ToString() => $"{_value} - \"{System.Text.Encoding.ASCII.GetString(ToArray())}\"";

    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

/// <summary>Vector type that is not supported and does nothing.</summary>
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
internal readonly struct NoOpVector<T> : ISimdVector<T, NoOpVector<T>> where T : unmanaged, IBinaryInteger<T>
{
    public static bool IsSupported => false;
    public static int Count => 0;
    public static NoOpVector<T> Zero => default;
    public static NoOpVector<T> Equals(NoOpVector<T> left, NoOpVector<T> right) => default;
    public static NoOpVector<T> Create(T value) => default;
    public static NoOpVector<T> Create(byte value) => default;
    public static NoOpVector<T> LoadUnaligned(ref readonly T source, nuint offset) => default;
    public static NoOpVector<T> LoadAligned(ref T source, nuint offset) => default;
    public nuint ExtractMostSignificantBits() => 0;
    public NoOpVector<T> WithZeroFirstElement() => default;
    public static NoOpVector<T> operator |(NoOpVector<T> left, NoOpVector<T> right) => default;
    public static bool operator ==(NoOpVector<T> left, NoOpVector<T> right) => false;
    public static bool operator !=(NoOpVector<T> left, NoOpVector<T> right) => false;
    public byte[] ToArray() => [];
    public override bool Equals(object obj) => throw new NotSupportedException();
    public override int GetHashCode() => throw new NotSupportedException();
}

// some of the char -> byte narrowing code is from .NET Runtime's Ascii.Utility.cs, MIT license:

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

