// <auto-generated />
#nullable enable
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Text;
using FlameCsv.Binding;
using FlameCsv.Enumeration;
using FlameCsv.Extensions;
using FlameCsv.IO;

namespace FlameCsv;

static partial class CsvReader
{

#region Parse (reflection)

    /// <summary>
    /// Parses CSV records from the CSV data using reflection.
    /// </summary>
    /// <param name="reader">TextReader to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        TextReader reader,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(reader);
        options ??= CsvOptions<char>.Default;
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(reader, in ioOptions), options);
    }

    /// <summary>
    /// Parses CSV records from the CSV data using reflection and the specified encoding.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        options ??= CsvOptions<char>.Default;
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(stream, encoding, in ioOptions), options);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data using reflection.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for stream
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<byte, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        Stream stream,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        options ??= CsvOptions<byte>.Default;
        return new CsvValueEnumerable<byte, TValue>(CsvBufferReader.Create(stream, in ioOptions), options);
    }

    /// <summary>
    /// Parses CSV records from the specified file using reflection and the specified encoding.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> ReadFromFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<char>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvValueEnumerable<char, TValue>(
            new ReaderFactory<char>(isAsync => GetFileBufferReader(path, encoding, isAsync, in ioOptions)),
            options);
    }
    
    /// <summary>
    /// Parses CSV records from the specified file using reflection.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for files
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<byte, TValue> ReadFromFile<[DAM(Messages.ReflectionBound)] TValue>(
        string path,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<byte>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvValueEnumerable<byte, TValue>(
            new ReaderFactory<byte>(isAsync => GetFileBufferReader(path, isAsync, in ioOptions)),
            options);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        string? csv,
        CsvOptions<char>? options = null)
    {
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        StringBuilder? csv,
        CsvOptions<char>? options = null)
    {
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        ReadOnlyMemory<char> csv,
        CsvOptions<char>? options = null)
    {
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<char, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        in ReadOnlySequence<char> csv,
        CsvOptions<char>? options = null)
    {
        return new CsvValueEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<byte, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        ReadOnlyMemory<byte> csv,
        CsvOptions<byte>? options = null)
    {
        return new CsvValueEnumerable<byte, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [RUF(Messages.Reflection), RDC(Messages.DynamicCode)]
    public static CsvValueEnumerable<byte, TValue> Read<[DAM(Messages.ReflectionBound)] TValue>(
        in ReadOnlySequence<byte> csv,
        CsvOptions<byte>? options = null)
    {
        return new CsvValueEnumerable<byte, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default);
    }

#endregion // Parse (reflection)

#region Parse (sourcegen)

    /// <summary>
    /// Parses CSV records from the CSV data using the type map.
    /// </summary>
    /// <param name="reader">TextReader to read the CSV data from</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        TextReader reader,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(reader);
        ArgumentNullException.ThrowIfNull(typeMap);
        options ??= CsvOptions<char>.Default;
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(reader, in ioOptions), options, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the CSV data using the type map and the specified encoding.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        Stream stream,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        ArgumentNullException.ThrowIfNull(typeMap);
        options ??= CsvOptions<char>.Default;
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(stream, encoding, in ioOptions), options, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data using the type map.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for stream
    public static CsvTypeMapEnumerable<byte, TValue> Read<TValue>(
        Stream stream,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        ArgumentNullException.ThrowIfNull(typeMap);
        options ??= CsvOptions<byte>.Default;
        return new CsvTypeMapEnumerable<byte, TValue>(CsvBufferReader.Create(stream, in ioOptions), options, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the specified file using the type map and the specified encoding.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> ReadFromFile<TValue>(
        string path,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<char>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvTypeMapEnumerable<char, TValue>(
            new ReaderFactory<char>(isAsync => GetFileBufferReader(path, encoding, isAsync, in ioOptions)),
            options, typeMap);
    }
    
    /// <summary>
    /// Parses CSV records from the specified file using the type map.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <returns>
    /// An enumerable that parses <typeparam name="TValue"/> instances from the CSV data in a forward-only fashion.
    /// The enumerable can be used with <c>foreach</c> or <c>await foreach</c>, and with LINQ.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for files
    public static CsvTypeMapEnumerable<byte, TValue> ReadFromFile<TValue>(
        string path,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<byte>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvTypeMapEnumerable<byte, TValue>(
            new ReaderFactory<byte>(isAsync => GetFileBufferReader(path, isAsync, in ioOptions)),
            options, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        string? csv,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        StringBuilder? csv,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        ReadOnlyMemory<char> csv,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<char, TValue> Read<TValue>(
        in ReadOnlySequence<char> csv,
        CsvTypeMap<char, TValue> typeMap,
        CsvOptions<char>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<char, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<byte, TValue> Read<TValue>(
        ReadOnlyMemory<byte> csv,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<byte, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default, typeMap);
    }

    /// <summary>
    /// Parses CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="typeMap">Type map used to bind the CSV data</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvTypeMapEnumerable<byte, TValue> Read<TValue>(
        in ReadOnlySequence<byte> csv,
        CsvTypeMap<byte, TValue> typeMap,
        CsvOptions<byte>? options = null)
    {
        ArgumentNullException.ThrowIfNull(typeMap);
        return new CsvTypeMapEnumerable<byte, TValue>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default, typeMap);
    }

#endregion // Parse (sourcegen)

#region Enumerate

    /// <summary>
    /// Reads CSV records from the specified file using the specified encoding.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> EnumerateFromFile(
        string path,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<char>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvRecordEnumerable<char>(
            new ReaderFactory<char>(isAsync => GetFileBufferReader(path, encoding, isAsync, in ioOptions)),
            options);
    }
    
    /// <summary>
    /// Reads CSV records from the specified file.
    /// </summary>
    /// <param name="path">Path of the source file</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for file
    public static CsvRecordEnumerable<byte> EnumerateFromFile(
        string path,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(path);
        options ??= CsvOptions<byte>.Default;
        ioOptions = ioOptions.ForFileIO();
        return new CsvRecordEnumerable<byte>(
            new ReaderFactory<byte>(isAsync => GetFileBufferReader(path, isAsync, in ioOptions)),
            options);
    }

    /// <summary>
    /// Reads CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(string? csv, CsvOptions<char>? options = null)
    {
        return new CsvRecordEnumerable<char>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(StringBuilder? csv, CsvOptions<char>? options = null)
    {
        return new CsvRecordEnumerable<char>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(ReadOnlyMemory<char> csv, CsvOptions<char>? options = null)
    {
        return new CsvRecordEnumerable<char>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(in ReadOnlySequence<char> csv, CsvOptions<char>? options = null)
    {
        return new CsvRecordEnumerable<char>(CsvBufferReader.Create(csv), options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<byte> Enumerate(ReadOnlyMemory<byte> csv, CsvOptions<byte>? options = null)
    {
        return new CsvRecordEnumerable<byte>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default);
    }

    /// <summary>
    /// Reads CSV records from the UTF8 CSV data.
    /// </summary>
    /// <param name="csv">CSV data to read</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<byte> Enumerate(in ReadOnlySequence<byte> csv, CsvOptions<byte>? options = null)
    {
        return new CsvRecordEnumerable<byte>(CsvBufferReader.Create(csv), options ?? CsvOptions<byte>.Default);
    }

    /// <summary>
    /// Reads CSV records from the text reader.
    /// </summary>
    /// <param name="reader">TextReader to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(
        TextReader reader,
        CsvOptions<char>? options = null,
        CsvIOOptions ioOptions = default)
    {
        ArgumentNullException.ThrowIfNull(reader);
        return new CsvRecordEnumerable<char>(
            CsvBufferReader.Create(reader, in ioOptions),
            options ?? CsvOptions<char>.Default);
    }

    /// <summary>
    /// Reads CSV records from the stream using the specified encoding.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="encoding">Encoding to use. If null, UTF8, or ASCII, a specialized UTF8 reader is used instead of a StreamReader</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    public static CsvRecordEnumerable<char> Enumerate(
        Stream stream,
        CsvOptions<char>? options = null,
        Encoding? encoding = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        return new CsvRecordEnumerable<char>(
            CsvBufferReader.Create(stream, encoding, in ioOptions),
            options ?? CsvOptions<char>.Default);
    }
    
    /// <summary>
    /// Reads CSV records from the UTF8 stream.
    /// </summary>
    /// <param name="stream">Stream to read the CSV data from</param>
    /// <param name="options">Options to use, <see cref="CsvOptions{T}.Default"/> used by default</param>
    /// <param name="ioOptions">Options to configure the buffer size and other IO related options</param>
    /// <remarks>
    /// <see cref="CsvRecord{T}"/> instances are only valid until <c>MoveNext()</c> is called again.
    /// The returned enumerator is intended to be used in a <c>foreach</c> loop.
    /// Improper use will throw a runtime exception.
    /// </remarks>
    /// <returns>
    /// An enumerable that can be used with <c>foreach</c> or <c>await foreach</c> to read the CSV records.
    /// </returns>
    [OverloadResolutionPriority(1000)] // prefer byte overload for stream
    public static CsvRecordEnumerable<byte> Enumerate(
        Stream stream,
        CsvOptions<byte>? options = null,
        CsvIOOptions ioOptions = default)
    {
        Throw.IfNotReadable(stream);
        return new CsvRecordEnumerable<byte>(
            CsvBufferReader.Create(stream, in ioOptions),
            options ?? CsvOptions<byte>.Default);
    }

#endregion // Enumerate
}
