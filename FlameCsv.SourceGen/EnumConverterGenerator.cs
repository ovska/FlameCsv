using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class EnumConverterGenerator : IIncrementalGenerator
{
    private const string AggressiveInlining
        = "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(EnumModel model, EquatableArray<Diagnostic> diagnostics, bool result)>
            modelAndDiagnostics = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvEnumConverterAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        bool result = EnumModel.TryGet(
                            context.TargetSymbol,
                            context.Attributes[0],
                            cancellationToken,
                            out var diagnostics,
                            out var model);

                        // no values in enum?
                        result = result && !model.Values.IsEmpty;
                        return (model, diagnostics, result);
                    })
                .WithTrackingName("FlameCsv_EnumSourceGen");

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Select(static (tuple, _) => tuple.diagnostics)
                .WithTrackingName("FlameCsv_EnumSourceGen_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Where(static tuple => tuple.diagnostics.IsEmpty && tuple.result)
                .WithTrackingName("FlameCsv_EnumSourceGen_Model"),
            static (context, tuple) => Execute(in tuple.model, context));
    }

    private static void Execute(in EnumModel model, SourceProductionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(GlobalConstants.GeneratedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();

        writer.WriteLine("using System;"); // TODO: remove and call SequenceEqual and EndsWith directly
        writer.WriteLine("using __Unsafe = global::System.Runtime.CompilerServices.Unsafe;");
        writer.WriteLine("using __MemoryMarshal = global::System.Runtime.InteropServices.MemoryMarshal;");
        writer.WriteLineIf(model.TokenType.IsByte(), "using __BitConverter = global::System.BitConverter;");
        writer.WriteLine();

        if (model.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {model.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in model.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(GlobalConstants.CodeDomAttribute);
        writer.WriteLine(
            $"partial class {model.ConverterType.Name} : global::FlameCsv.CsvConverter<{model.TokenType.Name}, {model.EnumType.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            writer.WriteLine("private readonly string? _format;");
            writer.WriteLine("private readonly global::System.IFormatProvider? _provider;");
            writer.WriteLine("private readonly bool _ignoreCase;");
            writer.WriteLine("private readonly bool _writeNumbers;");
            writer.WriteLine("private readonly bool _allowUndefinedValues;");

            writer.WriteLine();
            writer.WriteLine($"public {model.ConverterType.Name}(CsvOptions<{model.TokenType.Name}> options)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("global::System.ArgumentNullException.ThrowIfNull(options);");
                /*
                 *         _allowUndefinedValues = options.AllowUndefinedEnumValues;
                            _ignoreCase = options.IgnoreEnumCase;
                            _formatProvider = options.GetFormatProvider(typeof(TEnum));
                            _format = options.GetFormat(typeof(TEnum), options.EnumFormat);
                 */

                writer.WriteLine("_ignoreCase = options.IgnoreEnumCase;");
                writer.WriteLine(
                    $"_provider = options.GetFormatProvider(typeof({model.EnumType.FullyQualifiedName}));");
                writer.WriteLine(
                    $"_format = options.GetFormat(typeof({model.EnumType.FullyQualifiedName}), options.EnumFormat);");
                writer.WriteLine("_writeNumbers = _format is \"D\" or \"d\";");
                writer.WriteLine("_allowUndefinedValues = options.AllowUndefinedEnumValues;");
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryParse(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
            using (writer.WriteBlock())
            {
                WriteParseMethod(in model, writer, context.CancellationToken);
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryFormat(global::System.Span<{model.TokenType.Name}> destination, {model.EnumType.FullyQualifiedName} value, out int charsWritten)");
            using (writer.WriteBlock())
            {
                WriteFormatMethod(model, writer, context.CancellationToken);
            }

            writer.WriteLine();
            WriteDefinedCheck(in model, writer, context.CancellationToken);

            if (model.TokenType.IsByte())
            {
                writer.WriteLine();
                writer.WriteLine(
                    $"private bool TryParseSlow(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
                using (writer.WriteBlock())
                {
                    WriteParseSlow(writer, context.CancellationToken);
                }

                writer.WriteLine();
                writer.WriteLine("[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]");
                writer.WriteLine(
                    $"private static global::System.ReadOnlySpan<char> GetChars(global::System.ReadOnlySpan<{model.TokenType.Name}> source, global::System.Span<char> buffer, out char[]? toReturn)");
                using (writer.WriteBlock())
                {
                    WriteGetChars(writer, context.CancellationToken);
                }
            }
        }

        foreach (ref readonly var nestedType in model.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        context.CancellationToken.ThrowIfCancellationRequested();

        string sourceName = GlobalConstants.GetFileName(model.ConverterType.Name, model.WrappingTypes);
        context.AddSource(sourceName, writer.ToString());
    }

    private static void WriteDefinedCheck(
        in EnumModel model,
        IndentedTextWriter writer,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        writer.WriteLine("/// <summary>");
        writer.WriteLine("/// Determines whether a specified value is defined for the enumeration.");
        writer.WriteLine("/// </summary>");
        writer.WriteLineIf(model.ContiguousFromZero, AggressiveInlining);
        writer.WriteLine($"public static bool IsDefined({model.EnumType.FullyQualifiedName} value)");
        using var _ = writer.WriteBlock();

        if (model.ContiguousFromZero)
        {
            writer.WriteLine($"return (uint)value < {model.Values.Length}U;");
            return;
        }

        writer.WriteLine("return value switch");

        writer.WriteLine("{");
        writer.IncreaseIndent();

        foreach (var value in model.Values.DistinctBy(v => v.Value))
        {
            writer.WriteLine($"{model.EnumType.FullyQualifiedName}.{value.Name} => true,");
        }

        writer.WriteLine("_ => false,");
        writer.DecreaseIndent();
        writer.WriteLine("};");
    }
}
