using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class EnumConverterGenerator : IIncrementalGenerator
{
    private const string AggressiveInlining
        = "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(EnumModel model, EquatableArray<Diagnostic> diagnostics, bool result)>
            modelAndDiagnostics = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvEnumConverterAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        bool result = EnumModel.TryGet(
                            context.TargetSymbol,
                            context.Attributes[0],
                            cancellationToken,
                            out var diagnostics,
                            out var model);

                        // no values in enum?
                        result = result && !model.Values.IsEmpty;
                        return (model, diagnostics, result);
                    })
                .WithTrackingName("FlameCsv_EnumSourceGen");

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Select(static (tuple, _) => tuple.diagnostics)
                .WithTrackingName("FlameCsv_EnumSourceGen_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Where(static tuple => tuple.diagnostics.IsEmpty && tuple.result)
                .WithTrackingName("FlameCsv_EnumSourceGen_Model"),
            static (context, tuple) => Execute(in tuple.model, context));
    }

    private static void Execute(in EnumModel model, SourceProductionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(GlobalConstants.GeneratedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();

        writer.WriteLine("using System;"); // TODO: remove and call SequenceEqual and EndsWith directly
        writer.WriteLine("using __Unsafe = global::System.Runtime.CompilerServices.Unsafe;");
        writer.WriteLine("using __MemoryMarshal = global::System.Runtime.InteropServices.MemoryMarshal;");
        writer.WriteLineIf(model.TokenType.IsByte(), "using __BitConverter = global::System.BitConverter;");
        writer.WriteLine();

        if (model.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {model.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in model.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(GlobalConstants.CodeDomAttribute);
        writer.WriteLine(
            $"partial class {model.ConverterType.Name} : global::FlameCsv.CsvConverter<{model.TokenType.Name}, {model.EnumType.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            writer.WriteLine("private static WriteNumberImpl WriteNumberStrategy { get; } = new();");
            writer.WriteLine("private static WriteStringImpl WriteStringStrategy { get; } = new();");
            writer.WriteLine("private static ReadOrdinalImpl OrdinalStrategy { get; } = new();");
            writer.WriteLine("private static ReadIgnoreCaseImpl IgnoreCaseStrategy { get; } = new();");
            writer.WriteLine();

            writer.Write("private readonly global::FlameCsv.Converters.Enums.EnumParseStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine(" _parseStrategy;");
            writer.Write("private readonly global::FlameCsv.Converters.Enums.EnumFormatStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine(" _formatStrategy;");
            writer.WriteLine("private readonly bool _allowUndefinedValues;");
            writer.WriteLine("private readonly bool _ignoreCase;");
            writer.WriteLine("private readonly string? _format;");

            writer.WriteLine();
            writer.WriteLine($"public {model.ConverterType.Name}(CsvOptions<{model.TokenType.Name}> options)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("global::System.ArgumentNullException.ThrowIfNull(options);");
                writer.WriteLine("_allowUndefinedValues = options.AllowUndefinedEnumValues;");
                writer.WriteLine("_ignoreCase = options.IgnoreEnumCase;");
                writer.WriteLine(
                    $"_format = options.GetFormat(typeof({model.EnumType.FullyQualifiedName}), options.EnumFormat);");

                writer.Write("_parseStrategy = ");
                writer.WriteIf(
                    model.HasFlagsAttribute,
                    $"new global::FlameCsv.Converters.Enums.CsvEnumFlagsParseStrategy<{model.TokenType.Name}, {model.EnumType.FullyQualifiedName}>(options, ");
                writer.Write("_ignoreCase ? IgnoreCaseStrategy : OrdinalStrategy");
                writer.WriteIf(model.HasFlagsAttribute, ")");
                writer.WriteLine(";");

                writer.WriteLine("_formatStrategy = _format switch");
                writer.WriteLine("{");
                writer.IncreaseIndent();
                writer.WriteLine("null or \"g\" or \"G\" => WriteStringStrategy,");
                writer.WriteLine("\"d\" or \"D\" => WriteNumberStrategy,");
                writer.Write("\"x\" or \"X\" => global::FlameCsv.Converters.Enums.EnumFormatStrategy");
                WriteStrategyGenerics(in model, writer, context.CancellationToken);
                writer.WriteLine(".None, // always defer to Enum.TryFormat");

                writer.Write("\"f\" or \"F\" => ");
                if (model.HasFlagsAttribute)
                {
                    string specifier = model.TokenType.IsByte() ? "Utf8" : "Text";
                    writer.WriteLine(
                        $"new global::FlameCsv.Converters.Enums.CsvEnumFlags{specifier}FormatStrategy<{model.EnumType.FullyQualifiedName}>(options, WriteStringStrategy),");
                }
                else
                {
                    writer.WriteLine(
                        $"throw new global::System.NotSupportedException(\"Flags-format not supported for non-flags enum {model.EnumType.Name}\"),");
                }

                writer.WriteLine(
                    "{ } configuredFormat => throw new global::System.NotSupportedException(\"Invalid enum format specified: \" + configuredFormat)");
                writer.DecreaseIndent();
                writer.WriteLine("};");
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryParse(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
            using (writer.WriteBlock())
            {
                WriteParseMethod(in model, writer, context.CancellationToken);
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryFormat(global::System.Span<{model.TokenType.Name}> destination, {model.EnumType.FullyQualifiedName} value, out int charsWritten)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("if (destination.IsEmpty)");
                using (writer.WriteBlock())
                {
                    writer.WriteLine("__Unsafe.SkipInit(out charsWritten);");
                    writer.WriteLine("return false;");
                }

                writer.WriteLine();
                writer.WriteLine(
                    "global::System.Buffers.OperationStatus status = _formatStrategy.TryFormat(destination, value, out charsWritten);");
                writer.WriteLine("if (status == global::System.Buffers.OperationStatus.Done) return true;");
                writer.WriteLine(
                    "if (status == global::System.Buffers.OperationStatus.DestinationTooSmall) return false;");
                writer.WriteLine();
                writer.WriteLine("// unknown value, defer to Enum.TryFormat");
                if (model.TokenType.SpecialType is SpecialType.System_Byte)
                {
                    // TODO: simplify when Enum implements IUtf8Formattable
                    writer.WriteLine(
                        "var handler = new global::System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler(" +
                        "0, 1, destination, out bool shouldAppend);");
                    writer.WriteLine("if (shouldAppend)");
                    using (writer.WriteBlock())
                    {
                        writer.WriteLine("handler.AppendFormatted(value, _format);");
                        writer.WriteLine(
                            "return global::System.Text.Unicode.Utf8.TryWrite(destination, ref handler, out charsWritten);");
                    }

                    writer.WriteLine();
                    writer.WriteLine("charsWritten = 0;");
                    writer.WriteLine("return false;");
                }
                else
                {
                    writer.WriteLine(
                        "return ((global::System.ISpanFormattable)value).TryFormat(destination, out charsWritten, _format, provider: null);");
                }
            }

            writer.WriteLine();
            WriteDefinedCheck(in model, writer, context.CancellationToken);

            if (model.TokenType.IsByte())
            {
                writer.WriteLine();
                writer.WriteLine(
                    $"private bool TryParseSlow(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
                using (writer.WriteBlock())
                {
                    WriteParseSlow(writer, context.CancellationToken);
                }

                writer.WriteLine();
                writer.WriteLine(
                    "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]");
                writer.WriteLine(
                    $"private static global::System.ReadOnlySpan<char> GetChars(global::System.ReadOnlySpan<{model.TokenType.Name}> source, global::System.Span<char> buffer, out char[]? toReturn)");
                using (writer.WriteBlock())
                {
                    WriteGetChars(writer, context.CancellationToken);
                }
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.Write("private sealed class ReadOrdinalImpl : global::FlameCsv.Converters.Enums.EnumParseStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine();
            using (writer.WriteBlock())
            {
                WriteSwitch(in model, writer, ignoreCase: false, context.CancellationToken);
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.Write("private sealed class ReadIgnoreCaseImpl : global::FlameCsv.Converters.Enums.EnumParseStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine();
            using (writer.WriteBlock())
            {
                WriteSwitch(in model, writer, ignoreCase: true, context.CancellationToken);
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.Write("private sealed class WriteNumberImpl : global::FlameCsv.Converters.Enums.EnumFormatStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine();
            using (writer.WriteBlock())
            {
                if (!model.HasFlagsAttribute)
                {
                    WriteFormatMethod(model, numbers: true, writer, context.CancellationToken);
                }
                else
                {
                    WriteFlagsFormat(in model, writer, context.CancellationToken);
                }
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.Write("private sealed class WriteStringImpl : global::FlameCsv.Converters.Enums.EnumFormatStrategy");
            WriteStrategyGenerics(in model, writer, context.CancellationToken);
            writer.WriteLine();
            using (writer.WriteBlock())
            {
                WriteFormatMethod(model, numbers: false, writer, context.CancellationToken);
            }

            if (model.HasFlagsAttribute)
            {
                writer.WriteLine();
                writer.WriteLine(GlobalConstants.CodeDomAttribute);
                WriteFlagsImplementation(in model, writer, context.CancellationToken);
            }
        }

        foreach (ref readonly var nestedType in model.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        context.CancellationToken.ThrowIfCancellationRequested();

        string sourceName = GlobalConstants.GetFileName(model.ConverterType.Name, model.WrappingTypes);
        context.AddSource(sourceName, writer.ToString());
    }

    private static void WriteDefinedCheck(
        in EnumModel model,
        IndentedTextWriter writer,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        writer.WriteLine("/// <summary>");
        writer.WriteLine("/// Determines whether a specified value is defined for the enumeration.");
        writer.WriteLine("/// </summary>");
        writer.WriteLineIf(model.ContiguousFromZero, AggressiveInlining);
        writer.WriteLine($"public static bool IsDefined({model.EnumType.FullyQualifiedName} value)");
        using var _ = writer.WriteBlock();

        if (model.ContiguousFromZero)
        {
            writer.WriteLine($"return (uint)value < {model.Values.Length}U;");
            return;
        }

        writer.WriteLine("return value switch");

        writer.WriteLine("{");
        writer.IncreaseIndent();

        foreach (var value in model.Values.DistinctBy(v => v.Value))
        {
            writer.WriteLine($"{model.EnumType.FullyQualifiedName}.{value.Name} => true,");
        }

        writer.WriteLine("_ => false,");
        writer.DecreaseIndent();
        writer.WriteLine("};");
    }

    private static void WriteStrategyGenerics(
        in EnumModel model,
        IndentedTextWriter writer,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        writer.Write("<");
        writer.Write(model.TokenType.Name);
        writer.Write(", ");
        writer.Write(model.EnumType.FullyQualifiedName);
        writer.Write(">");
    }
}
