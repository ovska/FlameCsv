using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class EnumConverterGenerator : IIncrementalGenerator
{
    private const string AggressiveInlining
        = "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(EnumModel model, EquatableArray<Diagnostic> diagnostics, bool result)>
            modelAndDiagnostics = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvEnumConverterAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        bool result = EnumModel.TryGet(
                            context.TargetSymbol,
                            context.Attributes[0],
                            cancellationToken,
                            out var diagnostics,
                            out var model);

                        // no values in enum?
                        result = result && !model.Values.IsEmpty;
                        return (model, diagnostics, result);
                    })
                .WithTrackingName("FlameCsv_EnumSourceGen");

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Select(static (tuple, _) => tuple.diagnostics)
                .WithTrackingName("FlameCsv_EnumSourceGen_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            modelAndDiagnostics
                .Where(static tuple => tuple.diagnostics.IsEmpty && tuple.result)
                .WithTrackingName("FlameCsv_EnumSourceGen_Model"),
            static (context, tuple) => Execute(in tuple.model, context));
    }

    private static void Execute(in EnumModel model, SourceProductionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(GlobalConstants.GeneratedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();

        writer.WriteLine("using System;"); // TODO: remove and call SequenceEqual and EndsWith directly
        writer.WriteLine("using __Unsafe = global::System.Runtime.CompilerServices.Unsafe;");
        writer.WriteLine("using __MemoryMarshal = global::System.Runtime.InteropServices.MemoryMarshal;");
        writer.WriteLineIf(model.TokenType.IsByte(), "using __BitConverter = global::System.BitConverter;");
        writer.WriteLine();

        if (model.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {model.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in model.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(GlobalConstants.CodeDomAttribute);
        writer.WriteLine(
            $"partial class {model.ConverterType.Name} : global::FlameCsv.CsvConverter<{model.TokenType.Name}, {model.EnumType.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            writer.WriteLine("private static WriteNumberImpl WriteNumberStrategy { get; } = new();");
            writer.WriteLine("private static WriteStringImpl WriteStringStrategy { get; } = new();");
            writer.WriteLine("private static ReadOrdinalImpl OrdinalStrategy { get; } = new();");
            writer.WriteLine("private static ReadIgnoreCaseImpl IgnoreCaseStrategy { get; } = new();");
            writer.WriteLine();

            writer.WriteLine("private readonly ParseStrategy _parseStrategy;");
            writer.WriteLine("private readonly FormatStrategy _formatStrategy;");
            writer.WriteLine("private readonly bool _allowUndefinedValues;");
            writer.WriteLine("private readonly bool _ignoreCase;");
            writer.WriteLine("private readonly string? _format;");

            writer.WriteLine();
            writer.WriteLine($"public {model.ConverterType.Name}(CsvOptions<{model.TokenType.Name}> options)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("global::System.ArgumentNullException.ThrowIfNull(options);");
                writer.WriteLine("_allowUndefinedValues = options.AllowUndefinedEnumValues;");
                writer.WriteLine("_ignoreCase = options.IgnoreEnumCase;");
                writer.WriteLine($"_format = options.GetFormat(typeof({model.EnumType.FullyQualifiedName}), options.EnumFormat);");
                writer.WriteLine("_parseStrategy = _ignoreCase ? IgnoreCaseStrategy : OrdinalStrategy;");
                writer.WriteLine($"_formatStrategy = _format switch");
                writer.WriteLine("{");
                writer.IncreaseIndent();
                writer.WriteLine("null or \"g\" or \"G\" => WriteStringStrategy,");
                writer.WriteLine("\"d\" or \"D\" => WriteNumberStrategy,");
                writer.WriteLine("\"x\" or \"X\" => throw new global::System.NotImplementedException(\"Hex format not supported\"),");
                writer.WriteLine("{ } configuredFormat => throw new global::System.NotSupportedException(\"Invalid enum format specified: \" + configuredFormat)");
                writer.DecreaseIndent();
                writer.WriteLine("};");
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryParse(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
            using (writer.WriteBlock())
            {
                WriteParseMethod(in model, writer, context.CancellationToken);
            }

            writer.WriteLine();

            writer.WriteLine(
                $"public override bool TryFormat(global::System.Span<{model.TokenType.Name}> destination, {model.EnumType.FullyQualifiedName} value, out int charsWritten)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("if (destination.IsEmpty)");
                using (writer.WriteBlock())
                {
                    writer.WriteLine("__Unsafe.SkipInit(out charsWritten);");
                    writer.WriteLine("return false;");
                }
                writer.WriteLine();
                writer.WriteLine("if (_formatStrategy.TryFormat(destination, value, out charsWritten))");
                using (writer.WriteBlock()) writer.WriteLine("return true;");
                writer.WriteLine();
                if (model.TokenType.SpecialType is SpecialType.System_Byte)
                {
                    // TODO: simplify when Enum implements IUtf8Formattable
                    writer.WriteLine(
                        "var handler = new global::System.Text.Unicode.Utf8.TryWriteInterpolatedStringHandler(" +
                        "0, 1, destination, out bool shouldAppend);");
                    writer.WriteLine("if (shouldAppend)");
                    using (writer.WriteBlock())
                    {
                        writer.WriteLine("handler.AppendFormatted(value, _format);");
                        writer.WriteLine(
                            "return global::System.Text.Unicode.Utf8.TryWrite(destination, ref handler, out charsWritten);");
                    }

                    writer.WriteLine();
                    writer.WriteLine("charsWritten = 0;");
                    writer.WriteLine("return false;");
                }
                else
                {
                    writer.WriteLine(
                        "return ((global::System.ISpanFormattable)value).TryFormat(destination, out charsWritten, _format, provider: null);");
                }
            }

            writer.WriteLine();
            WriteDefinedCheck(in model, writer, context.CancellationToken);

            WriteTryFormatCore(in model, writer, context.CancellationToken);

            if (model.TokenType.IsByte())
            {
                writer.WriteLine();
                writer.WriteLine(
                    $"private bool TryParseSlow(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value)");
                using (writer.WriteBlock())
                {
                    WriteParseSlow(writer, context.CancellationToken);
                }

                writer.WriteLine();
                writer.WriteLine(
                    "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]");
                writer.WriteLine(
                    $"private static global::System.ReadOnlySpan<char> GetChars(global::System.ReadOnlySpan<{model.TokenType.Name}> source, global::System.Span<char> buffer, out char[]? toReturn)");
                using (writer.WriteBlock())
                {
                    WriteGetChars(writer, context.CancellationToken);
                }
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private abstract class ParseStrategy");
            using (writer.WriteBlock())
            {
                writer.WriteLine(
                    $"public abstract bool TryParse(global::System.ReadOnlySpan<{model.TokenType.Name}> source, out {model.EnumType.FullyQualifiedName} value);");
            }

            writer.WriteLine();

            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private abstract class FormatStrategy");
            using (writer.WriteBlock())
            {
                writer.WriteLine(
                    $"public abstract bool TryFormat(global::System.Span<{model.TokenType.Name}> destination, {model.EnumType.FullyQualifiedName} value, out int charsWritten);");
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private sealed class ReadOrdinalImpl : ParseStrategy");
            using (writer.WriteBlock())
            {
                WriteSwitch(in model, writer, ignoreCase: false,context.CancellationToken);
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private sealed class ReadIgnoreCaseImpl : ParseStrategy");
            using (writer.WriteBlock())
            {
                WriteSwitch(in model, writer, ignoreCase: true, context.CancellationToken);
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private sealed class WriteNumberImpl : FormatStrategy");
            using (writer.WriteBlock())
            {
                WriteFormatMethod(model, numbers: true, writer, context.CancellationToken);
            }

            writer.WriteLine();
            writer.WriteLine(GlobalConstants.CodeDomAttribute);
            writer.WriteLine("private sealed class WriteStringImpl : FormatStrategy");
            using (writer.WriteBlock())
            {
                WriteFormatMethod(model, numbers: false, writer, context.CancellationToken);
            }
        }

        foreach (ref readonly var nestedType in model.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        context.CancellationToken.ThrowIfCancellationRequested();

        string sourceName = GlobalConstants.GetFileName(model.ConverterType.Name, model.WrappingTypes);
        context.AddSource(sourceName, writer.ToString());
    }

    private static void WriteDefinedCheck(
        in EnumModel model,
        IndentedTextWriter writer,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        writer.WriteLine("/// <summary>");
        writer.WriteLine("/// Determines whether a specified value is defined for the enumeration.");
        writer.WriteLine("/// </summary>");
        writer.WriteLineIf(model.ContiguousFromZero, AggressiveInlining);
        writer.WriteLine($"public static bool IsDefined({model.EnumType.FullyQualifiedName} value)");
        using var _ = writer.WriteBlock();

        if (model.ContiguousFromZero)
        {
            writer.WriteLine($"return (uint)value < {model.Values.Length}U;");
            return;
        }

        writer.WriteLine("return value switch");

        writer.WriteLine("{");
        writer.IncreaseIndent();

        foreach (var value in model.Values.DistinctBy(v => v.Value))
        {
            writer.WriteLine($"{model.EnumType.FullyQualifiedName}.{value.Name} => true,");
        }

        writer.WriteLine("_ => false,");
        writer.DecreaseIndent();
        writer.WriteLine("};");
    }

    private static void WriteTryFormatCore(
        in EnumModel model,
        IndentedTextWriter writer,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        // TODO: investigate perf in unrolled assignments for short inputs
        writer.WriteLine();
        writer.WriteLine(AggressiveInlining);
        writer.Write("static bool TryWriteCore(");
        writer.Write($"global::System.Span<{model.TokenType.Name}> destination, ");
        writer.Write($"global::System.ReadOnlySpan<{model.TokenType.Name}> value, ");
        writer.WriteLine("out int charsWritten)");
        using (writer.WriteBlock())
        {
            writer.WriteLine("if (value.Length == 1)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("if (destination.Length >= 1)");
                using (writer.WriteBlock())
                {
                    writer.WriteLine("destination[0] = value[0];");
                    writer.WriteLine("charsWritten = 1;");
                    writer.WriteLine("return true;");
                }
            }

            writer.WriteLine("else if (value.Length == 2)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("if (destination.Length >= 2)");
                using (writer.WriteBlock())
                {
                    writer.WriteLine("destination[0] = value[0];");
                    writer.WriteLine("destination[1] = value[1];");
                    writer.WriteLine("charsWritten = 2;");
                    writer.WriteLine("return true;");
                }
            }

            writer.WriteLine("else if (destination.Length >= value.Length)");
            using (writer.WriteBlock())
            {
                writer.WriteLine("value.CopyTo(destination);");
                writer.WriteLine("charsWritten = value.Length;");
                writer.WriteLine("return true;");
            }

            writer.WriteLine();
            writer.WriteLine("__Unsafe.SkipInit(out charsWritten);");
            writer.WriteLine("return false;");
        }
    }
}
