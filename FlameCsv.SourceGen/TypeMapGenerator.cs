using System.Collections.Immutable;
using FlameCsv.SourceGen.Bindings;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<CompilationTarget> typeMapTargets = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "FlameCsv.Binding.CsvTypeMapAttribute`2",
                static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax or RecordDeclarationSyntax,
                GetSemanticTargetForGeneration)
            .Where(static target => target.Compilation is not null);

        context.RegisterSourceOutput(typeMapTargets, (spc, source) => Execute(source, spc));
    }

    private void Execute(CompilationTarget target, SourceProductionContext context)
    {
        TypeMapSymbol typeMap = new(target.Compilation, target.TargetClass, target.Attribute, context);

        try
        {
            context.AddSource(
                $"{typeMap.ContainingClass.Name}.G.cs",
                CreateTypeMap(in typeMap));
        }
        catch (DiagnosticException)
        {
        }
    }

    private SourceText CreateTypeMap(ref readonly TypeMapSymbol typeMap)
    {
        typeMap.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        StringBuilder sb = new(capacity: 1024 * 16);

        sb.Append(@"// <auto-generated>
// Generated by ");
        sb.Append(assembly.Name);
        sb.Append(' ');
        sb.Append(assembly.Version.ToString(3));
        sb.Append(@"
// </auto-generated>
#nullable ");
        sb.Append(typeMap.Symbols.Nullable ? "enable" : "disable");
        sb.Append(@"
using FlameCsv.Exceptions;
using FlameCsv.Binding;
using FlameCsv.Converters;
");
        if (typeMap.Scope is BindingScope.All or BindingScope.Read)
        {
            sb.Append(@"using FlameCsv.Reading;
");
        }

        if (typeMap.Scope is BindingScope.All or BindingScope.Write)
        {
            sb.Append(@"using FlameCsv.Writing;
");
        }

        sb.Append(@"
namespace ");
        sb.Append(typeMap.ContainingClass.ContainingNamespace.ToDisplayString());
        sb.Append(@"
{");
        typeMap.WriteWrappedTypes(sb, out int wrappedCount);
        sb.Append(@"
    partial class ");
        sb.Append(typeMap.ContainingClass.Name);
        sb.Append(" : CsvTypeMap<");
        sb.Append(typeMap.Token);
        sb.Append(", ");
        sb.Append(typeMap.ResultName);
        sb.Append(@">
    {
    ");
        WriteStaticInstance(sb, in typeMap);
        GetReadCode(sb, in typeMap);
        GetWriteCode(sb, in typeMap);
        sb.Append(@"
    }");

        if (wrappedCount != 0)
        {
            sb.Append(@"
    ");
            sb.Append('}', wrappedCount);
        }

        sb.Append(@"
}");

        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private void WriteStaticInstance(StringBuilder sb, ref readonly TypeMapSymbol typeMap)
    {
        // check if there is no "Instance" member, and a parameterless exists ctor.
        foreach (var ctor in typeMap.ContainingClass.InstanceConstructors)
        {
            if (ctor.Parameters.IsDefaultOrEmpty)
            {
                if (!typeMap.ContainingClass.MemberNames.Contains("Instance"))
                {
                    sb.Append(@"    public static ");
                    sb.Append(typeMap.ContainingClass.Name);
                    sb.Append(" Instance { get; } = new ");
                    sb.Append(typeMap.ContainingClass.Name);
                    sb.Append(@"();

");
                }

                return;
            }
        }
    }

    private static CompilationTarget GetSemanticTargetForGeneration(
        GeneratorAttributeSyntaxContext context,
        CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        var compilation = context.SemanticModel.Compilation;

        if (context.TargetSymbol is not INamedTypeSymbol typeMapClass)
        {
            // TODO: diagnostic
            return default;
        }

        if (context.Attributes.Length != 1)
        {
            // TODO: diagnostic
            return default;
        }

        return new CompilationTarget(compilation, context.Attributes[0], typeMapClass);
    }

    readonly struct CompilationTarget : IEquatable<CompilationTarget>
    {
        public CompilationTarget(Compilation compilation, AttributeData attribute, INamedTypeSymbol targetClass)
        {
            Compilation = compilation;
            Attribute = attribute;
            TargetClass = targetClass;
        }

        public Compilation Compilation { get; }
        public AttributeData Attribute { get; }
        public INamedTypeSymbol TargetClass { get; }

        public override int GetHashCode()
        {
            if (Compilation is null)
                return 0;

            unchecked
            {
                int hash = SymbolEqualityComparer.Default.GetHashCode(TargetClass);
                hash *= 37;
                hash ^= SymbolEqualityComparer.Default.GetHashCode(Attribute.AttributeClass?.TypeParameters[0]);
                hash *= 37;
                hash ^= SymbolEqualityComparer.Default.GetHashCode(Attribute.AttributeClass?.TypeParameters[1]);
                foreach (var kvp in Attribute.NamedArguments)
                {
                    hash *= 37;
                    hash ^= kvp.Value.GetHashCode();
                }
                return hash;
            }
        }

        public bool Equals(CompilationTarget other)
        {
            return SymbolEqualityComparer.Default.Equals(TargetClass, other.TargetClass)
                && SymbolEqualityComparer.Default.Equals(Attribute.AttributeClass!.TypeParameters[0], other.Attribute.AttributeClass!.TypeParameters[0])
                && SymbolEqualityComparer.Default.Equals(Attribute.AttributeClass!.TypeParameters[1], other.Attribute.AttributeClass!.TypeParameters[1])
                && Attribute.NamedArguments.Length == other.Attribute.NamedArguments.Length
                && ArgumentsEqual(Attribute.NamedArguments, other.Attribute.NamedArguments);
        }

        private static bool ArgumentsEqual(
            ImmutableArray<KeyValuePair<string, TypedConstant>> a,
            ImmutableArray<KeyValuePair<string, TypedConstant>> b)
        {
            if (a.Length != b.Length)
                return false;

            foreach (var argA in a)
            {
                bool found = false;

                foreach (var argB in b)
                {
                    if (argA.Key == argB.Key)
                    {
                        if (!argA.Value.Equals(argB.Value))
                            return false;

                        found = true;
                        break;
                    }
                }

                if (!found)
                    return false;
            }

            return true;
        }
    }
}
