using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    private static readonly string _assemblyNameAndVersion
        = $"{typeof(TypeMapGenerator).Assembly.GetName().Name} v{typeof(TypeMapGenerator).Assembly.GetName().Version.ToString(3)}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(TypeMapModel typeMap, EquatableArray<Diagnostic> diagnostics)> typeMapDiagnostics
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvTypeMapAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol,
                            Attribute: context.Attributes[0]);
                    })
                .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
                .WithTrackingName("FlameCsv_Target")
#if SOURCEGEN_USE_COMPILATION
                .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
                .Select(
                    static (tuple, cancellationToken) =>
                    {
                        var typeMap = new TypeMapModel(
                            compilation: tuple.Right,
                            containingClass: tuple.Left.ContainingClass,
                            attribute: tuple.Left.Attribute,
                            cancellationToken,
                            out EquatableArray<Diagnostic> diagnostics);

                        return (typeMap, diagnostics);
                    })
#else
            .Select(
                static (value, cancellationToken) =>
                {
                    var typeMap = new TypeMapModel(
                        containingClass: value.ContainingClass,
                        attribute: value.Attribute,
                        cancellationToken,
                        out EquatableArray<Diagnostic> diagnostics);

                    return (typeMap, diagnostics);
                })
#endif
                .WithTrackingName("FlameCsv_TypeMapAndDiagnostics");

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.diagnostics).WithTrackingName("FlameCsv_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.typeMap).WithTrackingName("FlameCsv_TypeMap"),
            static (context, source) => Execute(source, context));
    }

    private static void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        if (!typeMap.CanGenerateCode) return;

        string sourceName;

        using (var builder = new ImmutableArrayBuilder<char>())
        {
            foreach (var wrapping in typeMap.WrappingTypes)
            {
                builder.AddRange(wrapping.Name.AsSpan());
                builder.Add('_');
            }

            builder.AddRange(typeMap.TypeMap.Name.AsSpan());
            builder.AddRange(".G.cs".AsSpan());

            sourceName = builder.WrittenSpan.ToString();
        }

        context.AddSource(sourceName, CreateTypeMap(typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine($"// Generated by {_assemblyNameAndVersion}");
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine();

        if (typeMap.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {typeMap.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(
            $"partial class {typeMap.TypeMap.Name} : global::FlameCsv.Binding.CsvTypeMap<{typeMap.Token.FullyQualifiedName}, {typeMap.Type.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            if (typeMap.CanWriteInstance)
            {
                writer.WriteLine(
                    $"public static {typeMap.TypeMap.FullyQualifiedName} Instance {{ get; }} = new {typeMap.TypeMap.FullyQualifiedName}();");
                writer.WriteLine();
            }

            WriteIndexes(writer, typeMap);
            GetReadCode(writer, typeMap, cancellationToken);
            GetWriteCode(writer, typeMap, cancellationToken);
        }

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(writer.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var member in typeMap.AllMembers)
        {
            if (!member.CanRead) continue;

            writer.Write("private const int ");
            member.WriteId(writer);
            writer.WriteLine($" = {index++};");
        }

        writer.WriteLine("private const int @s__MinId = 1;");
        writer.WriteLine($"private const int @s__MaxId = {index};");
        writer.WriteLine();
    }
}
