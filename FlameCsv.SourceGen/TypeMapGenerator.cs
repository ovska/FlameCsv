using System.Collections.Immutable;
using System.Diagnostics;
using FlameCsv.SourceGen.Bindings;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    private KnownSymbols _symbols;
    private TypeBindings _bindings = null!;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
               .CreateSyntaxProvider(
                    static (s, _) => IsSyntaxTargetForGeneration(s),
                    static (s, ct) => GetSemanticTargetForGeneration(s, ct))
               .Where(static c => c is not null)!;

        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
               context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> matches, SourceProductionContext context)
    {
        if (matches.IsDefaultOrEmpty)
            return;

        _symbols = new KnownSymbols(compilation);

        foreach (var classDeclaration in matches)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration, context.CancellationToken);

            if (classSymbol is null)
                continue;

            TypeMapSymbol? typeMap = default;

            foreach (AttributeListSyntax attributeListSyntax in classDeclaration.AttributeLists)
            {
                foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (model.GetSymbolInfo(attributeSyntax, context.CancellationToken).Symbol is IMethodSymbol
                        { ContainingType: INamedTypeSymbol { Arity: 2, IsGenericType: true } attributeType } &&
                        SymbolEqualityComparer.Default.Equals(_symbols.CsvTypeMapAttribute, attributeType.ConstructUnboundGenericType()))
                    {
                        typeMap = new(classSymbol, attributeSyntax, attributeType, context);
                        break;
                    }
                }

                if (typeMap.HasValue)
                    break;
            }

            if (typeMap is null)
                continue;

            try
            {
                context.AddSource(
                    $"{typeMap.Value.ContainingClass.Name}.G.cs",
                    CreateTypeMap(typeMap.Value));
            }
            catch (DiagnosticException)
            {
            }
        }
    }

    private SourceText CreateTypeMap(TypeMapSymbol typeMap)
    {
        typeMap.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        _bindings = ResolveMembers(typeMap);

        StringBuilder sb = new(capacity: 1024 * 16);

        sb.Append(@"// <auto-generated>
// Generated by ");
        sb.Append(assembly.Name);
        sb.Append(' ');
        sb.Append(assembly.Version);
        sb.Append(@"
// </auto-generated>
#nullable ");
        sb.Append(_symbols.Nullable ? "enable" : "disable");
        sb.Append(@"
using FlameCsv.Exceptions;
using FlameCsv.Binding;
using FlameCsv.Converters;
");
        if (typeMap.Scope is BindingScope.All or BindingScope.Read)
        {
            sb.Append(@"using FlameCsv.Reading;
");
        }

        if (typeMap.Scope is BindingScope.All or BindingScope.Write)
        {
            sb.Append(@"using FlameCsv.Writing;
");
        }

        sb.Append(@"
namespace ");
        sb.Append(typeMap.ContainingClass.ContainingNamespace.ToDisplayString());
        sb.Append(@"
{");
        typeMap.WriteWrappedTypes(sb, out int wrappedCount);
        sb.Append(@"
    partial class ");
        sb.Append(typeMap.ContainingClass.Name);
        sb.Append(" : CsvTypeMap<");
        sb.Append(typeMap.Token);
        sb.Append(", ");
        sb.Append(typeMap.ResultName);
        sb.Append(@">
    {
    ");
        WriteStaticInstance(sb, in typeMap);
        GetReadCode(sb, in typeMap);
        GetWriteCode(sb, in typeMap);
        sb.Append(@"
    }");

        if (wrappedCount != 0)
        {
            sb.Append(@"
    ");
            sb.Append('}', wrappedCount);
        }

        sb.Append(@"
}");

        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private void WriteStaticInstance(StringBuilder sb, in TypeMapSymbol typeMap)
    {
        // check if there is no "Instance" member, and a parameterless exists ctor.
        foreach (var ctor in typeMap.ContainingClass.InstanceConstructors)
        {
            if (ctor.Parameters.IsDefaultOrEmpty)
            {
                if (!typeMap.ContainingClass.MemberNames.Contains("Instance"))
                {
                    sb.Append(@"    public static ");
                    sb.Append(typeMap.ContainingClass.Name);
                    sb.Append(" Instance { get; } = new ");
                    sb.Append(typeMap.ContainingClass.Name);
                    sb.Append(@"();

");
                }

                return;
            }
        }
    }

    private TypeBindings ResolveMembers(TypeMapSymbol typeMap)
    {
        var members = ImmutableArray.CreateBuilder<MemberBinding>();
        var parameters = ImmutableArray.CreateBuilder<ParameterBinding>();

        IMethodSymbol? constructor = null;
        IMethodSymbol? parameterlessCtor = null;

        foreach (var member in typeMap.Type.GetPublicMembersRecursive())
        {
            typeMap.ThrowIfCancellationRequested();

            if (member.DeclaredAccessibility == Accessibility.Private)
                continue;

            // TODO: write only
            if (member is IPropertySymbol property && property.ValidForReading(in _symbols))
            {
                var meta = new SymbolMetadata(property, in _symbols);
                members.Add(new MemberBinding(member, property.Type, in meta));

            }
            else if (member is IFieldSymbol field && field.ValidForReading(in _symbols))
            {
                var meta = new SymbolMetadata(field, in _symbols);
                members.Add(new MemberBinding(member, field.Type, in meta));
            }
            else if (
                !typeMap.SkipConstructor &&
                member is IMethodSymbol { MethodKind: MethodKind.Constructor } ctor)
            {
                foreach (var attr in ctor.GetAttributes())
                {
                    if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, _symbols.CsvConstructorAttribute))
                    {
                        if (constructor is not null)
                        {
                            typeMap.Fail(Diagnostics.TwoConstructorsFound(typeMap.Type, constructor));
                        }

                        if (ctor.DeclaredAccessibility == Accessibility.Private)
                        {
                            typeMap.Fail(Diagnostics.PrivateConstructorFound(typeMap.Type, ctor));
                        }

                        constructor = ctor;
                    }
                }

                if (ctor.Parameters.Length == 0)
                {
                    parameterlessCtor ??= ctor;
                }
            }
        }

        if (!typeMap.SkipConstructor)
        {
            constructor ??= parameterlessCtor;
            if (constructor is null)
            {
                typeMap.Fail(Diagnostics.NoConstructorFound(typeMap.Type));
            }

            foreach (var parameter in constructor.Parameters)
            {
                typeMap.ThrowIfCancellationRequested();

                if (parameter.Type.IsRefLikeType)
                {
                    typeMap.Fail(Diagnostics.RefLikeConstructorParameterFound(typeMap.Type, parameter));
                }

                if (parameter.RefKind is not RefKind.None and not RefKind.In)
                {
                    typeMap.Fail(Diagnostics.RefConstructorParameterFound(typeMap.Type, parameter));
                }

                var meta = new SymbolMetadata(parameter, in _symbols);
                Debug.Assert(meta.Scope != BindingScope.Write);
                parameters.Add(new ParameterBinding(parameter, in meta));
            }
        }

        if (members.Count == 0 && parameters.Count == 0)
        {
            typeMap.Fail(Diagnostics.NoWritableMembersOrParametersFound(typeMap.Type));
        }

        parameters.Sort((a, b) => a.ParameterPosition.CompareTo(b.ParameterPosition));
        return new TypeBindings(members.ToImmutable(), parameters.ToImmutable());
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(
        GeneratorSyntaxContext context,
        CancellationToken token)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax, token).Symbol is IMethodSymbol
                    { ContainingType: INamedTypeSymbol { Arity: 2, IsGenericType: true } attributeType } &&
                    attributeType.Name == "CsvTypeMapAttribute" &&
                    attributeType.ContainingNamespace.ContainingAssembly.Name == "FlameCsv.Core")
                {
                    return classDeclarationSyntax;
                }
            }
        }

        return default;
    }
}
