namespace FlameCsv.SourceGen;

[Generator]
public partial class TypeMapGenerator : ISourceGenerator
{
    private KnownSymbols _symbols;
    private List<Binding> _members = null!;

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        _symbols = new KnownSymbols(context.Compilation);

        foreach (var typeMapSymbol in GetTypeMapSymbols(context, receiver))
        {
            context.AddSource($"{typeMapSymbol.ContainingClass.Name}.G.cs", SourceText.From(CreateTypeMap(typeMapSymbol), Encoding.UTF8));
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private string CreateTypeMap(TypeMapSymbol typeMap)
    {
        _members = ResolveMembers(typeMap);

        // TODO: add version to generated code
        return $@"// <auto-generated />
#nullable enable
using FlameCsv.Exceptions;
using FlameCsv.Parsers;
using FlameCsv.Binding;

namespace {typeMap.ContainingClass.ContainingNamespace.ToDisplayString()}
{{
    partial class {typeMap.ContainingClass.Name} : CsvTypeMap<{typeMap.TokenName}, {typeMap.ResultName}>
    {{{WriteStaticInstance(typeMap)}
{string.Join(@"
", WriteFieldConstants())}

        protected override bool IgnoreUnparsable => {(typeMap.IgnoreUnparsable ? "true" : "false")};
{WriteCreateInstance(typeMap)}
        protected override TryParseHandler? BindMember(string name, ref BindingState state)
        {{
{string.Join(@"
", WriteParsers(typeMap))}
            return {(typeMap.IgnoreUnmatched ? "null" : "ThrowUnmatched(name, state.Count, state.ExposeContent)")};
        }}

        protected override void ValidateFields(ReadOnlySpan<string> headers, BindingState state)
        {{{WriteRequiredCheck()}
        }}
    }}
}}";
    }

    private string WriteStaticInstance(TypeMapSymbol typeMap)
    {
        if (!typeMap.SkipStaticInstance)
        {
            return $@"        
        public static {typeMap.ContainingClass.Name} Instance {{ get; }} = new {typeMap.ContainingClass.Name}();
";
        }

        return "";
    }

    private string WriteCreateInstance(TypeMapSymbol typeMap)
    {
        if (!HasCreateInstanceMethod(typeMap))
        {
            return $@"        
        protected override {typeMap.ResultName} CreateInstance() => new {typeMap.ResultName}();
";
        }

        return "";
    }

    private string WriteRequiredCheck()
    {
        var sb = new StringBuilder();

        foreach (var binding in _members.Where(b => b.IsRequired))
        {
            sb.Append($@"
            if (!state.IsFieldRead({binding.IdName}))
                ThrowRequiredNotRead({Stringify(binding.Name)}, headers, state.ExposeContent);
");
        }

        if (sb.Length == 0)
            return "";

        sb.Length--;
        return sb.ToString();
    }

    private List<Binding> ResolveMembers(TypeMapSymbol typeMap)
    {
        int id = 0;
        List<Binding> members = new();

        foreach (var member in typeMap.Type.GetMembers())
        {
            bool isRequired;
            int order;
            IEnumerable<string> names;

            if (member is IPropertySymbol property && IsValidProperty(property))
            {
                GetMemberOptions(typeMap, member, out isRequired, out order, out names);
                members.Add(new Binding(member, property.Type, isRequired, id++, order, names));

            }
            else if (member is IFieldSymbol field && IsValidField(field))
            {
                GetMemberOptions(typeMap, member, out isRequired, out order, out names);
                members.Add(new Binding(member, field.Type, isRequired, id++, order, names));
            }
        }

        if (id == 0)
        {
            // TODO: add diagnostic
            throw new InvalidOperationException("No writable members on type " + typeMap.Type.ToDisplayString());
        }

        members.Sort();
        return members;
    }

    private IEnumerable<string> WriteFieldConstants()
    {
        foreach (var binding in _members.OrderBy(b => b.Id))
        {
            yield return $"        private const byte {binding.IdName} = {binding.Id};";
        }
    }

    private IEnumerable<string> WriteParsers(TypeMapSymbol typeMap)
    {
        foreach (var binding in _members)
        {
            string skipDuplicate = "";
            string checkDuplicate = "";

            if (!typeMap.ThrowOnDuplicate)
            {
                skipDuplicate = $@"!state.IsFieldRead({binding.IdName}) &&
                ";
                checkDuplicate = $"state.SetFieldRead({binding.IdName});";
            }
            else
            {
                checkDuplicate = $@"if (state.SetFieldRead({binding.IdName}))
                    ThrowDuplicate({Stringify(binding.Name)}, name, state.ExposeContent);";
            }

            var names = string.Join(@" ||
                ", binding.Names.Select(n => $"state.FieldMatches(name, {Stringify(n)})"));

            yield return $@"            if ({skipDuplicate}{names}) {(binding.Order == 0 ? "// default order" : $"// order: {binding.Order}")}
            {{
                {checkDuplicate}

                ICsvParser<{typeMap.TokenName}, {binding.MemberType.ToDisplayString()}> parser = {ResolveParser(binding.Symbol, binding.MemberType)};

                return (ref {typeMap.ResultName} instance, ReadOnlySpan<{typeMap.TokenName}> field) =>
                {{
                    if (parser.TryParse(field, out var value))
                    {{
                        instance.{binding.Name} = value;
                        return true;
                    }}
                    return false;
                }};
            }}
";
        }

        string ResolveParser(ISymbol propertyOrField, ITypeSymbol type)
        {
            foreach (var attributeData in propertyOrField.GetAttributes())
            {
                if (attributeData.AttributeClass is { IsGenericType: true } attribute &&
                    SymbolEqualityComparer.Default.Equals(typeMap.Token, attribute.TypeArguments[0]) &&
                    SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvParserOverrideOfTAttribute))
                {
                    return GetParserInitializer(typeMap.Token, type, attribute.TypeArguments[1]);
                }
            }

            return $"state.Options.GetParser<{type.ToDisplayString()}>()";
        }
    }

    private void GetMemberOptions(
        TypeMapSymbol typeMap,
        ISymbol member,
        out bool isRequired,
        out int order,
        [NotNull] out IEnumerable<string>? names)
    {
        order = default;
        isRequired = default;
        names = null;
        bool foundHeader = false;
        bool foundRequired = false;

        foreach (var attributeData in member.GetAttributes())
        {
            if (!isRequired &&
                SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, _symbols.CsvHeaderRequiredAttribute))
            {
                isRequired = true;
                foundRequired = true;
            }

            if (!foundHeader &&
                SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, _symbols.CsvHeaderAttribute))
            {
                var arg = attributeData.ConstructorArguments[0];

                if (arg.Values.IsDefaultOrEmpty)
                {
                    typeMap.Context.ReportDiagnostic(Diagnostics.EmptyHeaderValuesAttribute(typeMap.Type, member));
                }
                else
                {
                    names = arg.Values.Select(v => v.Value?.ToString() ?? "");
                }

                order = attributeData.NamedArguments.FirstOrDefault(x => x.Key == "Order").Value.Value is int _order ? _order : 1;
                foundHeader = true;
            }

            if (foundHeader && foundRequired)
            {
                break;
            }
        }

        names ??= names = new[] { member.Name };
    }

    private IEnumerable<TypeMapSymbol> GetTypeMapSymbols(
        GeneratorExecutionContext context,
        SyntaxReceiver receiver)
    {
        foreach (var candidate in receiver.Candidates)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidate, context.CancellationToken);

            if (classSymbol is not null)
            {
                foreach (var attributeData in classSymbol.GetAttributes())
                {
                    if (attributeData.AttributeClass is { IsGenericType: true } attribute &&
                        SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvTypeMapAttribute))
                    {

                        yield return new TypeMapSymbol(
                            containingClass: (INamedTypeSymbol)classSymbol,
                            attribute: attributeData,
                            context: context);
                    }
                }
            }
        }
    }
}
