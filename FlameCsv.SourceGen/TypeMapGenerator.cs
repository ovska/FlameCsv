using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<TypeMapModel> typeMapTargets = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                "FlameCsv.Binding.CsvTypeMapAttribute`2",
                static (syntaxNode, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return syntaxNode is ClassDeclarationSyntax;
                },
                static (context, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol, Attribute: context.Attributes[0]);
                })
            .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
            .WithTrackingName("FlameCsv_Target")
#if USE_COMPILATION
            .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
            .Select(
                static (tuple, cancellationToken) => new TypeMapModel(
                    compilation: tuple.Right,
                    containingClass: tuple.Left.ContainingClass,
                    attribute: tuple.Left.Attribute,
                    cancellationToken))
#else
            .Select(
                static (value, cancellationToken) => new TypeMapModel(
                    containingClass: value.ContainingClass,
                    attribute: value.Attribute,
                    cancellationToken))
#endif
            .WithTrackingName("FlameCsv_TypeMap");

        context.RegisterSourceOutput(typeMapTargets, static (spc, source) => Execute(source, spc));
    }

    private static void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        if (typeMap.ReportedDiagnostics.Length != 0)
        {
            foreach (var diagnostic in typeMap.ReportedDiagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }

            return;
        }

        StringBuilder sourceName = new(capacity: 32);

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sourceName.Append(wrapping.name);
            sourceName.Append('_');
        }

        sourceName.Append(typeMap.TypeMap.Name);
        sourceName.Append(".G.cs");

        context.AddSource(sourceName.ToString(), CreateTypeMap(typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine($"// Generated by {assembly.Name} {assembly.Version:3}");
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine();

        if (typeMap.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {typeMap.Namespace};");
        }

        writer.WriteLine();

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            writer.WriteLine(wrapping.display);
        }

        writer.WriteLine(
            $"partial class {typeMap.TypeMap.Name} : global::FlameCsv.Binding.CsvTypeMap<{typeMap.Token.FullyQualifiedName}, {typeMap.Type.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            if (typeMap.CanWriteInstance)
            {
                writer.WriteLine(
                    $"public static {typeMap.TypeMap.FullyQualifiedName} Instance {{ get; }} = new {typeMap.TypeMap.FullyQualifiedName}();");
                writer.WriteLine();
            }

            WriteIndexes(writer, typeMap);
            GetReadCode(writer, typeMap, cancellationToken);
            GetWriteCode(writer, typeMap, cancellationToken);
        }

        foreach (var _ in typeMap.WrappingTypes)
        {
            writer.WriteLine("}");
        }

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(writer.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var member in typeMap.AllMembers)
        {
            if (!member.CanRead) continue;

            writer.Write("private const int ");
            member.WriteId(writer);
            writer.WriteLine($" = {index++};");
        }

        writer.WriteLine("private const int s__MinIndex = 1;");
        writer.WriteLine($"private const int s__MaxIndex = {index};");
        writer.WriteLine();
    }
}
