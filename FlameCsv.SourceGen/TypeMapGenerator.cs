using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<TypeMapModel> typeMapTargets = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                "FlameCsv.Binding.CsvTypeMapAttribute`2",
                static (syntaxNode, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return syntaxNode is ClassDeclarationSyntax;
                },
                static (context, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol, Attribute: context.Attributes[0]);
                })
            .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
            .WithTrackingName("FlameCsv_Target")
            .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
            .Select(
                static (tuple, cancellationToken) => new TypeMapModel(
                    compilation: tuple.Right,
                    containingClass: tuple.Left.ContainingClass,
                    attribute: tuple.Left.Attribute,
                    cancellationToken))
            .WithTrackingName("FlameCsv_TypeMap");

        context.RegisterSourceOutput(typeMapTargets, static (spc, source) => Execute(source, spc));
    }

    private static void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        if (typeMap.ReportedDiagnostics.Length != 0)
        {
            foreach (var diagnostic in typeMap.ReportedDiagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }

            return;
        }

        StringBuilder sourceName = new(capacity: 32);

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sourceName.Append(wrapping.name);
            sourceName.Append('_');
        }

        sourceName.Append(typeMap.TypeMap.Name);
        sourceName.Append(".G.cs");

        context.AddSource(sourceName.ToString(), CreateTypeMap(typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        StringBuilder sb = new(capacity: 1024 * 16);

        sb.Append(
            @"// <auto-generated>
// Generated by ");
        sb.Append(assembly.Name);
        sb.Append(' ');
        sb.Append(assembly.Version.ToString(3));
        sb.Append(
            @"
// </auto-generated>
");

        if (typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
// <global namespace>");
        }
        else
        {
            sb.Append(
                @"
namespace ");
            sb.Append(typeMap.Namespace);
            sb.Append(
                @"
{");
        }

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sb.Append(
                @"
    ");
            sb.Append(wrapping.display);
        }

        sb.Append(
            @"
    partial class ");
        sb.Append(typeMap.TypeMap.Name);
        sb.Append(" : global::FlameCsv.Binding.CsvTypeMap<");
        sb.Append(typeMap.Token.FullyQualifiedName);
        sb.Append(", ");
        sb.Append(typeMap.Type.FullyQualifiedName);
        sb.Append(
            @">
    {
    ");

        if (typeMap.CanWriteInstance)
        {
            sb.Append(@"    public static ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(" Instance { get; } = new ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(
                @"();
");
        }

        WriteIndexes(sb, typeMap);
        GetReadCode(sb, typeMap, cancellationToken);
        GetWriteCode(sb, typeMap, cancellationToken);
        sb.Append(
            @"
    }");

        if (typeMap.WrappingTypes.Length != 0)
        {
            sb.Append(
                @"
    ");
            sb.Append('}', typeMap.WrappingTypes.Length);
        }

        if (!typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
}");
        }

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(StringBuilder sb, TypeMapModel typeMap)
    {
        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var member in typeMap.AllMembers)
        {
            if (!member.CanRead) continue;

            sb.Append(
                @"
        private const int ");
            member.WriteId(sb);
            sb.Append(" = ");
            sb.Append(index++);
            sb.Append(';');
        }

        sb.Append(
            @"
        private const int @s__MinIndex = 1;
        private const int @s__MaxIndex = ");
        sb.Append(index);
        sb.Append(';');


        sb.Append(
            @"

");
    }
}
