using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection.Metadata;
using FlameCsv.SourceGen.Bindings;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    private KnownSymbols _symbols;
    private TypeBindings _bindings = null!;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
               .CreateSyntaxProvider(
                    static (s, _) => IsSyntaxTargetForGeneration(s),
                    static (s, ct) => GetSemanticTargetForGeneration(s, ct))
               .Where(static c => c is not null)!;

        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
               context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> matches, SourceProductionContext context)
    {
        if (matches.IsDefaultOrEmpty)
            return;

        _symbols = new KnownSymbols(compilation);

        foreach (var classDeclaration in matches)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration, context.CancellationToken);

            if (classSymbol is null)
                continue;

            TypeMapSymbol? typeMap = default;

            foreach (AttributeListSyntax attributeListSyntax in classDeclaration.AttributeLists)
            {
                foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (model.GetSymbolInfo(attributeSyntax, context.CancellationToken).Symbol is IMethodSymbol
                        { ContainingType: INamedTypeSymbol { Arity: 2, IsGenericType: true } attributeType } &&
                        SymbolEqualityComparer.Default.Equals(_symbols.CsvTypeMapAttribute, attributeType.ConstructUnboundGenericType()))
                    {
                        typeMap = new(classSymbol, attributeSyntax, attributeType, context);
                        break;
                    }
                }

                if (typeMap.HasValue)
                    break;
            }

            if (typeMap is null)
                continue;

            try
            {
                context.AddSource(
                    $"{typeMap.Value.ContainingClass.Name}.G.cs",
                    SourceText.From(CreateTypeMap(typeMap.Value), Encoding.UTF8));
            }
            catch (DiagnosticException)
            {
            }
        }
    }

    private string CreateTypeMap(TypeMapSymbol typeMap)
    {
        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        _bindings = ResolveMembers(typeMap);

        return $@"// <auto-generated>
// Generated by {assembly.Name} {assembly.Version}
// </auto-generated>
#nullable enable
using FlameCsv.Exceptions;
using FlameCsv.Binding;
using FlameCsv.Converters;
using FlameCsv.Reading;

namespace {typeMap.ContainingClass.ContainingNamespace.ToDisplayString()}
{{{typeMap.GetWrappedTypes(out int wrappedCount)}
    partial class {typeMap.ContainingClass.Name} : CsvTypeMap<{typeMap.Token}, {typeMap.ResultName}>
    {{{WriteStaticInstance(in typeMap)}
{GetReadCode(in typeMap)}
    }}{(wrappedCount == 0 ? "" : "\n    " + new string('}', wrappedCount))}
}}";
    }

    private string WriteStaticInstance(in TypeMapSymbol typeMap)
    {
        if (CreateStaticInstance(typeMap.ContainingClass))
        {
            return $@"        
        public static {typeMap.ContainingClass.Name} Instance {{ get; }} = new {typeMap.ContainingClass.Name}();
";
        }

        return "";
    }

    private TypeBindings ResolveMembers(TypeMapSymbol typeMap)
    {
        var members = ImmutableArray.CreateBuilder<MemberBinding>();
        var parameters = ImmutableArray.CreateBuilder<ParameterBinding>();

        IMethodSymbol? constructor = null;
        IMethodSymbol? parameterlessCtor = null;

        foreach (var member in typeMap.Type.GetPublicMembersRecursive())
        {
            typeMap.ThrowIfCancellationRequested();

            if (member.DeclaredAccessibility == Accessibility.Private)
                continue;

            // TODO: write only
            if (member is IPropertySymbol property && property.ValidForReading(in _symbols))
            {
                var meta = new SymbolMetadata(property, in _symbols);
                members.Add(new MemberBinding(member, property.Type, in meta));

            }
            else if (member is IFieldSymbol field && field.ValidForReading(in _symbols))
            {
                var meta = new SymbolMetadata(field, in _symbols);
                members.Add(new MemberBinding(member, field.Type, in meta));
            }
            else if (
                !typeMap.SkipConstructor &&
                member is IMethodSymbol { MethodKind: MethodKind.Constructor } ctor)
            {
                foreach (var attr in ctor.GetAttributes())
                {
                    if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, _symbols.CsvConstructorAttribute))
                    {
                        if (constructor is not null)
                        {
                            typeMap.Fail(Diagnostics.TwoConstructorsFound(typeMap.Type, constructor));
                        }

                        if (ctor.DeclaredAccessibility == Accessibility.Private)
                        {
                            typeMap.Fail(Diagnostics.PrivateConstructorFound(typeMap.Type, ctor));
                        }

                        constructor = ctor;
                    }
                }

                if (ctor.Parameters.Length == 0)
                {
                    parameterlessCtor ??= ctor;
                }
            }
        }

        if (!typeMap.SkipConstructor)
        {
            constructor ??= parameterlessCtor;
            if (constructor is null)
            {
                typeMap.Fail(Diagnostics.NoConstructorFound(typeMap.Type));
            }

            foreach (var parameter in constructor.Parameters)
            {
                typeMap.ThrowIfCancellationRequested();

                if (parameter.Type.IsRefLikeType)
                {
                    typeMap.Fail(Diagnostics.RefLikeConstructorParameterFound(typeMap.Type, parameter));
                }

                if (parameter.RefKind is not RefKind.None and not RefKind.In)
                {
                    typeMap.Fail(Diagnostics.RefConstructorParameterFound(typeMap.Type, parameter));
                }

                var meta = new SymbolMetadata(parameter, in _symbols);
                Debug.Assert(meta.Scope != BindingScope.Write);
                parameters.Add(new ParameterBinding(parameter, in meta));
            }
        }

        if (members.Count == 0 && parameters.Count == 0)
        {
            typeMap.Fail(Diagnostics.NoWritableMembersOrParametersFound(typeMap.Type));
        }

        parameters.Sort((a, b) => a.ParameterPosition.CompareTo(b.ParameterPosition));
        return new TypeBindings(members.ToImmutable(), parameters.ToImmutable());
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(
        GeneratorSyntaxContext context,
        CancellationToken token)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax, token).Symbol is IMethodSymbol
                    { ContainingType: INamedTypeSymbol { Arity: 2, IsGenericType: true } attributeType } &&
                        attributeType.ToDisplayString().StartsWith("FlameCsv.Binding.CsvTypeMapAttribute<"))
                {
                    return classDeclarationSyntax;
                }
            }
        }

        return default;
    }
}
