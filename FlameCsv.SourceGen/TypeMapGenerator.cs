using System.Collections.Immutable;

namespace FlameCsv.SourceGen;

[Generator]
public partial class TypeMapGenerator : ISourceGenerator
{
    private KnownSymbols _symbols;
    private TypeBindings _bindings = null!;

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        _symbols = new KnownSymbols(context.Compilation);

        foreach (var typeMapSymbol in GetTypeMapSymbols(context, receiver))
        {
            try
            {
                context.AddSource(
                    $"{typeMapSymbol.ContainingClass.Name}.G.cs",
                    SourceText.From(CreateTypeMap(typeMapSymbol), Encoding.UTF8));
            }
            catch (DiagnosticException)
            {
            }
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private string CreateTypeMap(TypeMapSymbol typeMap)
    {
        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        _bindings = ResolveMembers(typeMap);

        return $@"// <auto-generated>
// Generated by {assembly.Name} {assembly.Version}
// </auto-generated>
#nullable enable
using FlameCsv.Exceptions;
using FlameCsv.Binding;
using FlameCsv.Converters;
using FlameCsv.Reading;

namespace {typeMap.ContainingClass.ContainingNamespace.ToDisplayString()}
{{
    partial class {typeMap.ContainingClass.Name} : CsvTypeMap<{typeMap.Token}, {typeMap.ResultName}>
    {{
        /// <summary>
        /// Callback for parsing a single field and writing the value to the object.
        /// </summary>
        private delegate bool TryParseHandler{typeMap.HandlerArgs};
{WriteStaticInstance(typeMap)}
        protected override IMaterializer<{typeMap.Token}, {typeMap.ResultName}> BindMembers(
            ReadOnlySpan<string> headers,
            bool exposeContent,
            CsvOptions<{typeMap.Token}> options)
        {{
            TypeMapMaterializer materializer = new TypeMapMaterializer(headers.Length);
            bool anyFieldBound = false;

            for (int index = 0; index < headers.Length; index++)
            {{
                string name = headers[index];

{string.Join(@"
", WriteMatchers(typeMap))}
                {(typeMap.IgnoreUnmatched
                    ? $"materializer.Handlers[index] = {typeMap.HandlerArgs} => true; // ignored"
                    : "ThrowUnmatched(name, index, exposeContent);")}
            }}

            if (!anyFieldBound)
                ThrowNoFieldsBound(headers, exposeContent);
{WriteRequiredCheck()}
            return materializer;
        }}

        protected override IMaterializer<{typeMap.Token}, {typeMap.ResultName}> BindMembers(
            bool exposeContent,
            CsvOptions<{typeMap.Token}> options)
        {{
            throw new NotSupportedException(""{typeMap.ContainingClass.MetadataName} does not support index binding."");
        }}

        private static IEnumerable<string> GetMissingRequiredFields(TypeMapMaterializer materializer)
        {{
            {WriteMissingRequiredFields()}
        }}

        private struct ParseState
        {{
            {string.Join(@"
            ", _bindings.AllBindings.Select(b => $"public {b.Type.ToDisplayString()} {b.Name};"))}
        }}

        private struct TypeMapMaterializer : IMaterializer<{typeMap.Token}, {typeMap.ResultName}>
        {{
            {string.Join(@"
            ", WriteParserMembers(typeMap))}

            public readonly TryParseHandler[] Handlers;

            public TypeMapMaterializer(int length)
            {{
                Handlers = new TryParseHandler[length];
            }}

            public int FieldCount => Handlers.Length;

            public {typeMap.ResultName} Parse<TReader>(ref TReader reader) where TReader : ICsvFieldReader<{typeMap.Token}>
            {{
                // If possible, throw early if there are an invalid amount of fields
                reader.TryEnsureFieldCount(fieldCount: Handlers.Length);

                ParseState state = default;{WriteDefaultParameterValues()}
                
                int index = 0;

                while (reader.TryReadNext(out ReadOnlyMemory<{typeMap.Token}> field))
                {{
                    if (Handlers[index++](ref this, ref state, field.Span))
                    {{
                        continue;
                    }}

                    reader.ThrowParseFailed(field, null);
                }}

                // Ensure there were no leftover fields
                reader.EnsureFullyConsumed(fieldCount: Handlers.Length);

                // Create the value from parsed values. Required members are validated when creating the materializer,
                // optional members are assigned only if parsed to not overwrite possible default values.
                {typeMap.ResultName} obj = new {typeMap.ResultName}{WriteSetters()}
                return obj;
            }}

            {string.Join(@"

            ", WriteParserHandlers(typeMap))}
        }}
    }}
}}";
    }

    private string WriteDefaultParameterValues()
    {
        // we always write these; they are always compile time constants
        if (_bindings.Parameters.Length == 0)
            return "";

        var sb = new StringBuilder(64);

        sb.Append(@"
");

        bool commentWritten = false;

        foreach (var binding in _bindings.Parameters)
        {
            // Don't write common default values
            if (binding.IsRequired ||
                binding.DefaultValue is null or false or 0 or 0u or 0L or 0D)
            {
                continue;
            }

            if (!commentWritten)
            {
                commentWritten = true;
                sb.Append(@"
                // Preassign compile time defaults for optional parameters in case they don't get parsed
");
            }

            sb.Append("                state.");
            sb.Append(binding.Name);
            sb.Append(" = ");
            sb.Append(binding.DefaultValue switch
            {
                null => "default", // should be handled above
                string s => Stringify(s),
                bool b => b ? "true" : "false",
                IFormattable f => f.ToString(null, System.Globalization.CultureInfo.InvariantCulture),
                _ => binding.DefaultValue.ToString()
            });
            sb.Append(@";
");
        }

        sb.Length--;

        return sb.ToString();
    }

    private string WriteSetters()
    {
        var sb = new StringBuilder(256);

        sb.Append('(');

        if (_bindings.Parameters.Length != 0)
        {
            foreach (var binding in _bindings.Parameters)
            {
                sb.Append(@"
                    ");
                sb.Append(binding.ParameterName);
                sb.Append(": ");

                if (binding.HasInModifier)
                {
                    sb.Append("in ");
                }

                sb.Append("state.");
                sb.Append(binding.Name);
                sb.Append("!,");
            }

            sb.Length--;
        }

        sb.Append(')');

        if (_bindings.RequiredMembers.Length != 0)
        {
            sb.Append(@"
                {
                ");

            foreach (var binding in _bindings.RequiredMembers)
            {
                sb.Append("    ");
                sb.Append(binding.Name);
                sb.Append(" = state.");
                sb.Append(binding.Name);
                sb.Append(@"!,
                ");
            }

            sb.Append('}');
        }

        sb.Append(@";
");

        foreach (var binding in _bindings.Members.OrderBy(b => b.IsRequired))
        {
            if (binding.IsRequired)
                continue; // already handled

            sb.Append("                if (");
            sb.Append(binding.ParserId);
            sb.Append(" != null) ");
            sb.Append("obj.");
            sb.Append(binding.Name);
            sb.Append(" = state.");
            sb.Append(binding.Name);
            sb.Append(@"!;
");
        }

        sb.Length--;
        return sb.ToString();
    }

    private string WriteStaticInstance(TypeMapSymbol typeMap)
    {
        if (!typeMap.SkipStaticInstance)
        {
            return $@"        
        public static {typeMap.ContainingClass.Name} Instance {{ get; }} = new {typeMap.ContainingClass.Name}();
";
        }

        return "";
    }

    private string WriteRequiredCheck()
    {
        if (_bindings.RequiredMembers.Length == 0 && _bindings.Parameters.Length == 0)
            return "";

        var sb = new StringBuilder(128);

        sb.Append(@"
            if (");

        for (int i = 0; i < _bindings.RequiredBindings.Length; i++)
        {
            if (i != 0)
            {
                sb.Append(@" ||
                ");
            }

            sb.Append("materializer.");
            sb.Append(_bindings.RequiredBindings[i].ParserId);
            sb.Append(" == null");
        }

        return sb.Append(@")
                ThrowRequiredNotRead(GetMissingRequiredFields(materializer), headers, exposeContent);
").ToString();
    }

    private string WriteMissingRequiredFields()
    {
        string result = string.Join(@"
            ", _bindings.RequiredBindings.Select(b => $"if (materializer.{b.ParserId} == null) yield return {Stringify(b.Name)};"));

        if (result.Length == 0)
            return "return System.Array.Empty<string>();";

        return result;
    }

    private TypeBindings ResolveMembers(TypeMapSymbol typeMap)
    {
        var members = ImmutableArray.CreateBuilder<MemberBinding>();
        var parameters = ImmutableArray.CreateBuilder<ParameterBinding>();

        IMethodSymbol? constructor = null;
        IMethodSymbol? parameterlessCtor = null;

        foreach (var member in typeMap.Type.GetMembers())
        {
            if (member.DeclaredAccessibility == Accessibility.Private)
                continue;

            bool isRequired;
            int order;
            IEnumerable<string> names;

            if (member is IPropertySymbol property && IsValidProperty(property))
            {
                GetSymbolOptions(member, out isRequired, out order, out names);
                members.Add(new MemberBinding(member, property.Type, isRequired || property.IsRequired, order, names));

            }
            else if (member is IFieldSymbol field && IsValidField(field))
            {
                GetSymbolOptions(member, out isRequired, out order, out names);
                members.Add(new MemberBinding(member, field.Type, isRequired, order, names));
            }
            else if (member is IMethodSymbol { MethodKind: MethodKind.Constructor } ctor)
            {
                foreach (var attr in ctor.GetAttributes())
                {
                    if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, _symbols.CsvConstructorAttribute))
                    {
                        if (constructor is not null)
                        {
                            typeMap.Fail(Diagnostics.TwoConstructorsFound(typeMap.Type, constructor));
                        }

                        if (ctor.DeclaredAccessibility == Accessibility.Private)
                        {
                            typeMap.Fail(Diagnostics.PrivateConstructorFound(typeMap.Type, ctor));
                        }

                        constructor = ctor;
                    }
                }

                if (ctor.Parameters.Length == 0)
                {
                    parameterlessCtor ??= ctor;
                }
            }
        }

        constructor ??= parameterlessCtor;

        if (constructor is null)
        {
            typeMap.Fail(Diagnostics.NoConstructorFound(typeMap.Type));
        }

        foreach (var parameter in constructor.Parameters)
        {
            if (parameter.Type.IsRefLikeType)
            {
                typeMap.Fail(Diagnostics.RefLikeConstructorParameterFound(typeMap.Type, parameter));
            }

            if (parameter.RefKind is not RefKind.None and not RefKind.In)
            {
                typeMap.Fail(Diagnostics.RefConstructorParameterFound(typeMap.Type, parameter));
            }

            GetSymbolOptions(parameter, out bool isRequired, out int order, out var names);
            parameters.Add(new ParameterBinding(parameter, parameter.Type, order, isRequired, names));
        }

        if (members.Count == 0 && parameters.Count == 0)
        {
            typeMap.Fail(Diagnostics.NoWritableMembersOrParametersFound(typeMap.Type));
        }

        parameters.Sort((a, b) => a.ParameterPosition.CompareTo(b.ParameterPosition));
        return new TypeBindings(members.ToImmutable(), parameters.ToImmutable());
    }

    private IEnumerable<string> WriteParserMembers(TypeMapSymbol symbol)
    {
        foreach (var binding in _bindings.Members)
        {
            yield return $"public CsvConverter<{symbol.Token}, {binding.Type.ToDisplayString()}>? {binding.ParserId};";
        }

        foreach (var binding in _bindings.Parameters)
        {
            yield return $"public CsvConverter<{symbol.Token}, {binding.Type.ToDisplayString()}>? {binding.ParserId};";
        }
    }

    private IEnumerable<string> WriteParserHandlers(TypeMapSymbol symbol)
    {
        foreach (var binding in _bindings.AllBindings)
        {
            yield return $@"public static readonly TryParseHandler {binding.HandlerId} = {symbol.HandlerArgs} =>
            {{
                if (materializer.{binding.ParserId}!.TryParse(field, out var result))
                {{
                    state.{binding.Name} = result;
                    return true;
                }}
                return false;
            }};";
        }
    }

    private IEnumerable<string> WriteMatchers(TypeMapSymbol typeMap)
    {
        foreach (var binding in _bindings.AllBindings
            .OrderByDescending(b => b.Order)
            .ThenByDescending(b => b is ParameterBinding)
            .ThenByDescending(b => b.IsRequired))
        {
            string skipDuplicate = "";
            string checkDuplicate = "";

            if (!typeMap.ThrowOnDuplicate)
            {
                skipDuplicate = $@"materializer.{binding.ParserId} == null &&
                    ";
            }
            else
            {
                checkDuplicate = $@"
                    if (materializer.{binding.ParserId} != null) ThrowDuplicate({Stringify(binding.Name)}, name, headers, exposeContent);
";
            }

            var names = string.Join(@" ||
                    ", binding.Names.Select(n => $"options.Comparer.Equals(name, {Stringify(n)})"));

            yield return $@"                if ({skipDuplicate}{names}) {(binding.Order == 0 ? "// default order" : $"// order: {binding.Order}")}
                {{{checkDuplicate}
                    materializer.{binding.ParserId} = {ResolveParser(binding.Symbol, binding.Type)};
                    materializer.Handlers[index] = TypeMapMaterializer.{binding.HandlerId};
                    anyFieldBound = true;
                    continue;
                }}
";
        }

        string ResolveParser(ISymbol propertyOrField, ITypeSymbol type)
        {
            foreach (var attributeData in propertyOrField.GetAttributes())
            {
                if (attributeData.AttributeClass is { IsGenericType: true } attribute &&
                    SymbolEqualityComparer.Default.Equals(typeMap.TokenSymbol, attribute.TypeArguments[0]) &&
                    SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvConverterOfTAttribute))
                {
                    return GetParserInitializer(typeMap.TokenSymbol, type, attribute.TypeArguments[1]);
                }
            }

            return $"options.GetConverter<{type.ToDisplayString()}>()";
        }
    }

    private void GetSymbolOptions(
        ISymbol symbol,
        out bool isRequired,
        out int order,
        [NotNull] out IEnumerable<string>? names)
    {
        order = default;
        isRequired = default;
        names = null;

        foreach (var attributeData in symbol.GetAttributes())
        {
            if (SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, _symbols.CsvHeaderAttribute))
            {
                var arg = attributeData.ConstructorArguments[0];

                if (!arg.Values.IsDefaultOrEmpty)
                {
                    names = arg.Values.Select(v => v.Value?.ToString() ?? "");
                }

                isRequired = attributeData.NamedArguments.FindValueOrDefault(x => x.Key == "Required").Value.Value is bool b && b;
                order = attributeData.NamedArguments.FindValueOrDefault(x => x.Key == "Order").Value.Value is int _order ? _order : 1;
                break;
            }
        }

        names ??= names = new[] { symbol.Name };
    }

    private IEnumerable<TypeMapSymbol> GetTypeMapSymbols(
        GeneratorExecutionContext context,
        SyntaxReceiver receiver)
    {
        foreach (var candidate in receiver.Candidates)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidate, context.CancellationToken);

            if (classSymbol is not null)
            {
                foreach (var attributeData in classSymbol.GetAttributes())
                {
                    if (attributeData.AttributeClass is { IsGenericType: true, Arity: 2 } attribute &&
                        SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvTypeMapAttribute))
                    {
                        yield return new TypeMapSymbol(
                            containingClass: (INamedTypeSymbol)classSymbol,
                            csvTypeMapAttribute: attributeData,
                            context: context);
                    }
                }
            }
        }
    }
}
