namespace FlameCsv.SourceGen;

[Generator]
public partial class TypeMapGenerator : ISourceGenerator
{
    private KnownSymbols _symbols;
    private List<Binding> _members = null!;

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        _symbols = new KnownSymbols(context.Compilation);

        foreach (var typeMapSymbol in GetTypeMapSymbols(context, receiver))
        {
            context.AddSource($"{typeMapSymbol.ContainingClass.Name}.G.cs", SourceText.From(CreateTypeMap(typeMapSymbol), Encoding.UTF8));
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private string CreateTypeMap(TypeMapSymbol typeMap)
    {
        _members = ResolveMembers(typeMap);

        // TODO: add version to generated code
        return $@"// <auto-generated />
#nullable enable
using System.Runtime.CompilerServices;
using FlameCsv.Exceptions;
using FlameCsv.Parsers;
using FlameCsv.Binding;

namespace {typeMap.ContainingClass.ContainingNamespace.ToDisplayString()}
{{
    partial class {typeMap.ContainingClass.Name} : CsvTypeMap<{typeMap.TokenName}, {typeMap.ResultName}>
    {{
        private delegate bool TryParseHandler{typeMap.HandlerArgs};
{WriteStaticInstance(typeMap)}
        protected override bool IgnoreUnparsable => {(typeMap.IgnoreUnparsable ? "true" : "false")};
{WriteCreateInstance(typeMap)}
        protected override object BindMembers(ReadOnlySpan<string> headers, bool exposeContent, CsvReaderOptions<{typeMap.TokenName}> options)
        {{
            TypeMapState state = new TypeMapState(headers.Length);
            bool anyFieldBound = false;

            for (int index = 0; index < headers.Length; index++)
            {{
                string name = headers[index];

{string.Join(@"
", WriteMatchers(typeMap))}
                {(typeMap.IgnoreUnmatched
                    ? $"state._handlers[index] = static {typeMap.HandlerArgs} => true; // ignored"
                    : "ThrowUnmatched(name, index, exposeContent);")}
            }}

            if (!anyFieldBound)
                ThrowNoFieldsBound(headers, exposeContent);
{WriteRequiredCheck()}
            return new TypeMapMaterializer<TypeMapState>(CreateInstance, state);
        }}

        private struct TypeMapState : ITypeMapState
        {{
            {string.Join(@"
            ", WriteParserMembers(typeMap))}

            public readonly TryParseHandler[] _handlers;

            public TypeMapState(int length)
            {{
                _handlers = new TryParseHandler[length];
            }}

            readonly int ITypeMapState.Count => _handlers.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            bool ITypeMapState.TryParse(int index, ref {typeMap.ResultName} value, ReadOnlySpan<{typeMap.TokenName}> data)
            {{
                return _handlers[index](ref this, ref value, data);
            }}

            {string.Join(@"

            ", WriteParserHandlers(typeMap))}
        }}
    }}
}}";
    }

    private string WriteStaticInstance(TypeMapSymbol typeMap)
    {
        if (!typeMap.SkipStaticInstance)
        {
            return $@"        
        public static {typeMap.ContainingClass.Name} Instance {{ get; }} = new {typeMap.ContainingClass.Name}();
";
        }

        return "";
    }

    private string WriteCreateInstance(TypeMapSymbol typeMap)
    {
        if (!HasCreateInstanceMethod(typeMap))
        {
            return $@"        
        protected override {typeMap.ResultName} CreateInstance() => new {typeMap.ResultName}();
";
        }

        return "";
    }

    private string WriteRequiredCheck()
    {
        var sb = new StringBuilder();

        foreach (var binding in _members.Where(b => b.IsRequired))
        {
            sb.Append($@"
            if (state.{binding.ParserId} == null)
                ThrowRequiredNotRead({Stringify(binding.Name)}, headers, exposeContent);
");
        }

        if (sb.Length == 0)
        {
            return "";
        }    

        sb.Length--;
        return sb.Append(@"
").ToString();
    }

    private List<Binding> ResolveMembers(TypeMapSymbol typeMap)
    {
        List<Binding> members = new();

        foreach (var member in typeMap.Type.GetMembers())
        {
            bool isRequired;
            int order;
            IEnumerable<string> names;

            if (member is IPropertySymbol property && IsValidProperty(property))
            {
                GetMemberOptions(typeMap, member, out isRequired, out order, out names);
                members.Add(new Binding(member, property.Type, isRequired, order, names));

            }
            else if (member is IFieldSymbol field && IsValidField(field))
            {
                GetMemberOptions(typeMap, member, out isRequired, out order, out names);
                members.Add(new Binding(member, field.Type, isRequired, order, names));
            }
        }

        if (members.Count == 0)
        {
            // TODO: add diagnostic
            throw new InvalidOperationException("No writable members on type " + typeMap.Type.ToDisplayString());
        }

        //members.Sort();
        return members;
    }

    private IEnumerable<string> WriteParserMembers(TypeMapSymbol symbol)
    {
        foreach (var binding in _members)
        {
            yield return $"public ICsvParser<{symbol.TokenName}, {binding.MemberType.ToDisplayString()}>? {binding.ParserId};";
        }
    }

    private IEnumerable<string> WriteParserHandlers(TypeMapSymbol symbol)
    {
        foreach (var binding in _members)
        {
            yield return $@"public static readonly TryParseHandler {binding.HandlerId} = static {symbol.HandlerArgs} =>
            {{
                if (state.{binding.ParserId}!.TryParse(field, out var result))
                {{
                    value.{binding.Name} = result;
                    return true;
                }}
                return false;
            }};";
        }
    }

    private IEnumerable<string> WriteMatchers(TypeMapSymbol typeMap)
    {
        foreach (var binding in _members)
        {
            string skipDuplicate = "";
            string checkDuplicate = "";

            if (!typeMap.ThrowOnDuplicate)
            {
                skipDuplicate = $@"state.{binding.ParserId} == null &&
                    ";
            }
            else
            {
                checkDuplicate = $@"
                    if (state.{binding.ParserId} != null)
                        ThrowDuplicate({Stringify(binding.Name)}, name, exposeContent);
";
            }

            var names = string.Join(@" ||
                    ", binding.Names.Select(n => $"options.Comparer.Equals(name, {Stringify(n)})"));

            yield return $@"                if ({skipDuplicate}{names}) {(binding.Order == 0 ? "// default order" : $"// order: {binding.Order}")}
                {{{checkDuplicate}
                    state.{binding.ParserId} = {ResolveParser(binding.Symbol, binding.MemberType)};
                    state._handlers[index] = TypeMapState.{binding.HandlerId};
                    anyFieldBound = true;
                    continue;
                }}
";
        }

        string ResolveParser(ISymbol propertyOrField, ITypeSymbol type)
        {
            foreach (var attributeData in propertyOrField.GetAttributes())
            {
                if (attributeData.AttributeClass is { IsGenericType: true } attribute &&
                    SymbolEqualityComparer.Default.Equals(typeMap.Token, attribute.TypeArguments[0]) &&
                    SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvParserOverrideOfTAttribute))
                {
                    return GetParserInitializer(typeMap.Token, type, attribute.TypeArguments[1]);
                }
            }

            return $"options.GetParser<{type.ToDisplayString()}>()";
        }
    }

    private void GetMemberOptions(
        TypeMapSymbol typeMap,
        ISymbol member,
        out bool isRequired,
        out int order,
        [NotNull] out IEnumerable<string>? names)
    {
        order = default;
        isRequired = default;
        names = null;
        bool foundHeader = false;
        bool foundRequired = false;

        foreach (var attributeData in member.GetAttributes())
        {
            if (!isRequired &&
                SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, _symbols.CsvHeaderRequiredAttribute))
            {
                isRequired = true;
                foundRequired = true;
            }

            if (!foundHeader &&
                SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, _symbols.CsvHeaderAttribute))
            {
                var arg = attributeData.ConstructorArguments[0];

                if (arg.Values.IsDefaultOrEmpty)
                {
                    typeMap.Context.ReportDiagnostic(Diagnostics.EmptyHeaderValuesAttribute(typeMap.Type, member));
                }
                else
                {
                    names = arg.Values.Select(v => v.Value?.ToString() ?? "");
                }

                order = attributeData.NamedArguments.FirstOrDefault(x => x.Key == "Order").Value.Value is int _order ? _order : 1;
                foundHeader = true;
            }

            if (foundHeader && foundRequired)
            {
                break;
            }
        }

        names ??= names = new[] { member.Name };
    }

    private IEnumerable<TypeMapSymbol> GetTypeMapSymbols(
        GeneratorExecutionContext context,
        SyntaxReceiver receiver)
    {
        foreach (var candidate in receiver.Candidates)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidate, context.CancellationToken);

            if (classSymbol is not null)
            {
                foreach (var attributeData in classSymbol.GetAttributes())
                {
                    if (attributeData.AttributeClass is { IsGenericType: true } attribute &&
                        SymbolEqualityComparer.Default.Equals(attribute.ConstructUnboundGenericType(), _symbols.CsvTypeMapAttribute))
                    {

                        yield return new TypeMapSymbol(
                            containingClass: (INamedTypeSymbol)classSymbol,
                            attribute: attributeData,
                            context: context);
                    }
                }
            }
        }
    }
}
