using FlameCsv.SourceGen.Helpers;
using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    static TypeMapGenerator()
    {
        string assemblyName = typeof(TypeMapGenerator).Assembly.GetName().Name;
        string version = typeof(TypeMapGenerator).Assembly.GetName().Version.ToString(3);

        _generatedCodeComment = $"// Generated by {assemblyName} v{version}";
        _codeDomAttribute
            = $"[global::System.CodeDom.Compiler.GeneratedCode({assemblyName.ToStringLiteral()}, {version.ToStringLiteral()})]";
    }

    private static readonly string _generatedCodeComment;
    private static readonly string _codeDomAttribute;

    const string DoesNotReturnAttr = "[global::System.Diagnostics.CodeAnalysis.DoesNotReturn]";

    const string NoInliningAttr
        = "[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]";

    const string EditorBrowsableNever
        = "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(TypeMapModel typeMap, EquatableArray<Diagnostic> diagnostics)> typeMapDiagnostics
            = context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    "FlameCsv.Attributes.CsvTypeMapAttribute`2",
                    static (syntaxNode, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return syntaxNode is ClassDeclarationSyntax;
                    },
                    static (context, cancellationToken) =>
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol,
                            Attribute: context.Attributes[0]);
                    })
                .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
                .WithTrackingName("FlameCsv_Target")
#if SOURCEGEN_USE_COMPILATION
                .Combine(context.CompilationProvider.WithTrackingName("FlameCsv_Compilation"))
                .Select(
                    static (tuple, cancellationToken) =>
                    {
                        var typeMap = new TypeMapModel(
                            compilation: tuple.Right,
                            containingClass: tuple.Left.ContainingClass,
                            attribute: tuple.Left.Attribute,
                            cancellationToken,
                            out EquatableArray<Diagnostic> diagnostics);

                        return (typeMap, diagnostics);
                    })
#else
            .Select(
                static (value, cancellationToken) =>
                {
                    var typeMap = new TypeMapModel(
                        containingClass: value.ContainingClass,
                        attribute: value.Attribute,
                        cancellationToken,
                        out EquatableArray<Diagnostic> diagnostics);

                    return (typeMap, diagnostics);
                })
#endif
                .WithTrackingName("FlameCsv_TypeMapAndDiagnostics");

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.diagnostics).WithTrackingName("FlameCsv_Diagnostics"),
            static (context, diagnostics) =>
            {
                foreach (var diagnostic in diagnostics) context.ReportDiagnostic(diagnostic);
            });

        context.RegisterSourceOutput(
            typeMapDiagnostics.Select(static (tuple, _) => tuple.typeMap).WithTrackingName("FlameCsv_TypeMap"),
            static (context, source) => Execute(source, context));
    }

    private static void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        if (!typeMap.CanGenerateCode) return;

        string sourceName;

        using (var builder = new ImmutableArrayBuilder<char>())
        {
            foreach (var wrapping in typeMap.WrappingTypes)
            {
                builder.AddRange(wrapping.Name.AsSpan());
                builder.Add('_');
            }

            builder.AddRange(typeMap.TypeMap.Name.AsSpan());
            builder.AddRange(".G.cs".AsSpan());

            sourceName = builder.WrittenSpan.ToString();
        }

        context.AddSource(sourceName, CreateTypeMap(typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        using var writer = new IndentedTextWriter();

        writer.WriteLine("// <auto-generated>");
        writer.WriteLine(_generatedCodeComment);
        writer.WriteLine("// </auto-generated>");
        writer.WriteLine();

        if (typeMap.InGlobalNamespace)
        {
            writer.WriteLine("// <global namespace>");
        }
        else
        {
            writer.WriteLine($"namespace {typeMap.Namespace};");
        }

        writer.WriteLine();

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            nestedType.WriteTo(writer);
        }

        writer.WriteLine(_codeDomAttribute);
        writer.WriteLine(
            $"partial class {typeMap.TypeMap.Name} : global::FlameCsv.Binding.CsvTypeMap<{typeMap.Token.FullyQualifiedName}, {typeMap.Type.FullyQualifiedName}>");

        using (writer.WriteBlock())
        {
            cancellationToken.ThrowIfCancellationRequested();
            WriteDefaultInstance(writer, typeMap);
            cancellationToken.ThrowIfCancellationRequested();
            WriteIndexes(writer, typeMap);
            cancellationToken.ThrowIfCancellationRequested();
            WriteInitializers(writer, typeMap);
            GetReadCode(writer, typeMap, cancellationToken);
            GetWriteCode(writer, typeMap, cancellationToken);
        }

        foreach (var nestedType in typeMap.WrappingTypes)
        {
            writer.WriteLine($"}} // {nestedType.Name}");
        }

        writer.WriteLine();

        cancellationToken.ThrowIfCancellationRequested();
        return SourceText.From(writer.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var member in typeMap.AllMembers)
        {
            if (!member.CanRead) continue;

            writer.Write("private const int ");
            member.WriteId(writer);
            writer.WriteLine($" = {index++};");
        }

        writer.WriteLine("private const int @s__MinId = 1;");
        writer.WriteLine($"private const int @s__MaxId = {index - 1};");
        writer.WriteLine();
    }

    private static void WriteInitializers(IndentedTextWriter writer, TypeMapModel typeMap)
    {
        writer.WriteLine("#nullable enable");
        foreach (var member in typeMap.AllMembers)
        {
            writer.Write("static partial void Initialize_");
            writer.Write(member.Identifier);
            writer.Write("(global::FlameCsv.CsvOptions<");
            writer.Write(typeMap.Token.Name);
            writer.Write("> options, ref global::FlameCsv.CsvConverter<");
            writer.Write(typeMap.Token.Name);
            writer.Write(", ");
            writer.Write(member.Type.FullyQualifiedName);
            writer.WriteLine(">? converter);");
        }

        writer.WriteLine("#nullable disable");

        writer.WriteLine();
    }
}
