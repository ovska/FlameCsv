using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<FlameSymbols> flameCsvSymbols = context
            .CompilationProvider
            .Select((compilation, _) => new FlameSymbols(compilation));

        IncrementalValuesProvider<TypeMapModel> typeMapTargets = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                "FlameCsv.Binding.CsvTypeMapAttribute`2",
                static (syntaxNode, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return syntaxNode is ClassDeclarationSyntax or RecordDeclarationSyntax;
                },
                static (context, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return (ContainingClass: (INamedTypeSymbol)context.TargetSymbol, Attribute: context.Attributes[0]);
                })
            // .Where(static tuple => tuple.ContainingClass.CanBeReferencedByName)
            .Combine(flameCsvSymbols)
            .Select(
                static (tuple, cancellationToken) =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    return new TypeMapModel(
                        symbols: tuple.Right,
                        containingClass: tuple.Left.ContainingClass,
                        attribute: tuple.Left.Attribute);
                })
            .WithTrackingName("FlameCsvSourceGen");

        context.RegisterSourceOutput(typeMapTargets, static (spc, source) => Execute(source, spc));
    }

    private static void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        if (typeMap.HasDiagnostics(out var diagnostics))
        {
            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }

            return;
        }

        StringBuilder sourceName = new(capacity: 32);

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sourceName.Append(wrapping.name);
            sourceName.Append('_');
        }

        sourceName.Append(typeMap.TypeMap.Name);
        sourceName.Append(".G.cs");

        context.AddSource(
            sourceName.ToString(),
            CreateTypeMap(typeMap.GetSymbols(), typeMap, context.CancellationToken));
    }

    private static SourceText CreateTypeMap(
        FlameSymbols symbols,
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        StringBuilder sb = new(capacity: 1024 * 16);

        sb.Append(
            @"// <auto-generated>
// Generated by ");
        sb.Append(assembly.Name);
        sb.Append(' ');
        sb.Append(assembly.Version.ToString(3));
        sb.Append(
            @"
// </auto-generated>
#nullable ");
        sb.Append(symbols.NullableContext ? "enable" : "disable");
        sb.Append(
            @"
");

        if (typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
// <global namespace>");
        }
        else
        {
            sb.Append(
                @"
namespace ");
            sb.Append(typeMap.Namespace);
            sb.Append(
                @"
{");
        }

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sb.Append(
                @"
    ");
            sb.Append(wrapping.display);
        }

        sb.Append(
            @"
    partial class ");
        sb.Append(typeMap.TypeMap.Name);
        sb.Append(" : FlameCsv.Binding.CsvTypeMap<");
        sb.Append(typeMap.Token.FullyQualifiedName);
        sb.Append(", ");
        sb.Append(typeMap.Type.FullyQualifiedName);
        sb.Append(
            @">
    {
    ");

        if (typeMap.CanWriteInstance)
        {
            sb.Append(@"    public static ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(" Instance { get; } = new ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(
                @"();
");
        }

        WriteIndexes(sb, typeMap);
        GetReadCode(sb, symbols, typeMap, cancellationToken);
        GetWriteCode(sb, symbols, typeMap, cancellationToken);
        sb.Append(
            @"
    }");

        if (typeMap.WrappingTypes.Count != 0)
        {
            sb.Append(
                @"
    ");
            sb.Append('}', typeMap.WrappingTypes.Count);
        }

        if (!typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
}");
        }

        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private static void WriteIndexes(StringBuilder sb, TypeMapModel typeMap)
    {
        if (typeMap.Scope == CsvBindingScope.Write) return;

        // start from 1 so uninitialized members are zero and fail as expected
        int index = 1;

        foreach (var conversion in typeMap.PropertiesAndParameters)
        {
            if (!conversion.CanRead) return;

            sb.Append(
                @"
        private const int ");
            sb.Append(conversion.IndexPrefix);
            sb.Append(conversion.Name);
            sb.Append(" = ");
            sb.Append(index++);
            sb.Append(';');
        }

        sb.Append(
            @"
        private const int @s__MinIndex = 1;
        private const int @s__MaxIndex = ");
        sb.Append(index);
        sb.Append(';');


        sb.Append(
            @"

");
    }
}
