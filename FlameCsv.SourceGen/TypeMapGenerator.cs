using FlameCsv.SourceGen.Models;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FlameCsv.SourceGen;

[Generator(LanguageNames.CSharp)]
public partial class TypeMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<TypeMapModel> typeMapTargets = context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                "FlameCsv.Binding.CsvTypeMapAttribute`2",
                static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (context, token) =>
                {
                    token.ThrowIfCancellationRequested();

                    return new TypeMapModel(
                        new FlameSymbols(context.SemanticModel.Compilation),
                        (INamedTypeSymbol)context.TargetSymbol,
                        context.Attributes[0]);
                });

        context.RegisterSourceOutput(typeMapTargets, (spc, source) => Execute(source, spc));
    }

    private void Execute(TypeMapModel typeMap, SourceProductionContext context)
    {
        StringBuilder sourceName = new(capacity: 32);

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sourceName.Append(wrapping.name);
            sourceName.Append('_');
        }

        sourceName.Append(typeMap.TypeMap.Name);
        sourceName.Append(".G.cs");

        context.AddSource(
            sourceName.ToString(),
            CreateTypeMap(typeMap.GetSymbols(), typeMap, context.CancellationToken));
    }

    private SourceText CreateTypeMap(
        FlameSymbols symbols,
        TypeMapModel typeMap,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var assembly = typeof(TypeMapGenerator).Assembly.GetName();
        StringBuilder sb = new(capacity: 1024 * 16);

        sb.Append(
            @"// <auto-generated>
// Generated by ");
        sb.Append(assembly.Name);
        sb.Append(' ');
        sb.Append(assembly.Version.ToString(3));
        sb.Append(
            @"
// </auto-generated>
#nullable ");
        sb.Append(symbols.NullableContext ? "enable" : "disable");
        sb.Append(
            @"
");

        if (typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
// <global namespace>");
        }
        else
        {
            sb.Append(
                @"
namespace ");
            sb.Append(typeMap.Namespace);
            sb.Append(
                @"
{");
        }

        foreach (var wrapping in typeMap.WrappingTypes)
        {
            sb.Append(
                @"
    ");
            sb.Append(wrapping.display);
        }

        sb.Append(
            @"
    partial class ");
        sb.Append(typeMap.TypeMap.Name);
        sb.Append(" : FlameCsv.Binding.CsvTypeMap<");
        sb.Append(typeMap.Token.FullyQualifiedName);
        sb.Append(", ");
        sb.Append(typeMap.Type.FullyQualifiedName);
        sb.Append(
            @">
    {
    ");

        if (typeMap.CanWriteInstance)
        {
            sb.Append(@"    public static ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(" Instance { get; } = new ");
            sb.Append(typeMap.TypeMap.FullyQualifiedName);
            sb.Append(
                @"();
");
        }

        WriteIndexes(sb, typeMap);
        GetReadCode(sb, symbols, typeMap, cancellationToken);
        GetWriteCode(sb, symbols, typeMap, cancellationToken);
        sb.Append(
            @"
    }");

        if (typeMap.WrappingTypes.Count != 0)
        {
            sb.Append(
                @"
    ");
            sb.Append('}', typeMap.WrappingTypes.Count);
        }

        if (!typeMap.InGlobalNamespace)
        {
            sb.Append(
                @"
}");
        }

        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private void WriteIndexes(StringBuilder sb, TypeMapModel typeMap)
    {
        if (typeMap.Scope == CsvBindingScope.Write) return;

        int max = -1;

        foreach (var conversion in typeMap.PropertiesAndParameters)
        {
            if (!conversion.CanRead) return;

            int index = typeMap.GetIndex(conversion);
            max = Math.Max(max, index);

            sb.Append(
                @"
        private const int ");
            sb.Append(conversion.IndexPrefix);
            sb.Append(conversion.Name);
            sb.Append(" = ");
            sb.Append(index);
            sb.Append(';');
        }

        sb.Append(
            @"
        private const int @s__MinIndex = 1;
        private const int @s__MaxIndex = ");
        sb.Append(max);
        sb.Append(';');


        sb.Append(
            @"

");
    }
}
